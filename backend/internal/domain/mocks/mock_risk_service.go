// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"

	model "github.com/RyanLisse/go-crypto-bot-clean/backend/internal/domain/model"
	mock "github.com/stretchr/testify/mock"
)

// RiskService is an autogenerated mock type for the RiskService type
type RiskService struct {
	mock.Mock
}

// AddConstraint provides a mock function with given fields: ctx, constraint
func (_m *RiskService) AddConstraint(ctx context.Context, constraint *model.RiskConstraint) error {
	ret := _m.Called(ctx, constraint)

	if len(ret) == 0 {
		panic("no return value specified for AddConstraint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.RiskConstraint) error); ok {
		r0 = rf(ctx, constraint)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AssessOrderRisk provides a mock function with given fields: ctx, userID, orderRequest
func (_m *RiskService) AssessOrderRisk(ctx context.Context, userID string, orderRequest *model.OrderRequest) ([]*model.RiskAssessment, error) {
	ret := _m.Called(ctx, userID, orderRequest)

	if len(ret) == 0 {
		panic("no return value specified for AssessOrderRisk")
	}

	var r0 []*model.RiskAssessment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.OrderRequest) ([]*model.RiskAssessment, error)); ok {
		return rf(ctx, userID, orderRequest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.OrderRequest) []*model.RiskAssessment); ok {
		r0 = rf(ctx, userID, orderRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.RiskAssessment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *model.OrderRequest) error); ok {
		r1 = rf(ctx, userID, orderRequest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssessPortfolioRisk provides a mock function with given fields: ctx, userID
func (_m *RiskService) AssessPortfolioRisk(ctx context.Context, userID string) ([]*model.RiskAssessment, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for AssessPortfolioRisk")
	}

	var r0 []*model.RiskAssessment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*model.RiskAssessment, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.RiskAssessment); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.RiskAssessment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssessPositionRisk provides a mock function with given fields: ctx, userID, position
func (_m *RiskService) AssessPositionRisk(ctx context.Context, userID string, position *model.Position) ([]*model.RiskAssessment, error) {
	ret := _m.Called(ctx, userID, position)

	if len(ret) == 0 {
		panic("no return value specified for AssessPositionRisk")
	}

	var r0 []*model.RiskAssessment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.Position) ([]*model.RiskAssessment, error)); ok {
		return rf(ctx, userID, position)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.Position) []*model.RiskAssessment); ok {
		r0 = rf(ctx, userID, position)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.RiskAssessment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *model.Position) error); ok {
		r1 = rf(ctx, userID, position)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateRiskMetrics provides a mock function with given fields: ctx, userID
func (_m *RiskService) CalculateRiskMetrics(ctx context.Context, userID string) (*model.RiskMetrics, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for CalculateRiskMetrics")
	}

	var r0 *model.RiskMetrics
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.RiskMetrics, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.RiskMetrics); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.RiskMetrics)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckConstraints provides a mock function with given fields: ctx, userID, orderRequest
func (_m *RiskService) CheckConstraints(ctx context.Context, userID string, orderRequest *model.OrderRequest) (bool, []*model.RiskConstraint, error) {
	ret := _m.Called(ctx, userID, orderRequest)

	if len(ret) == 0 {
		panic("no return value specified for CheckConstraints")
	}

	var r0 bool
	var r1 []*model.RiskConstraint
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.OrderRequest) (bool, []*model.RiskConstraint, error)); ok {
		return rf(ctx, userID, orderRequest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.OrderRequest) bool); ok {
		r0 = rf(ctx, userID, orderRequest)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *model.OrderRequest) []*model.RiskConstraint); ok {
		r1 = rf(ctx, userID, orderRequest)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*model.RiskConstraint)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, *model.OrderRequest) error); ok {
		r2 = rf(ctx, userID, orderRequest)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DeleteConstraint provides a mock function with given fields: ctx, constraintID
func (_m *RiskService) DeleteConstraint(ctx context.Context, constraintID string) error {
	ret := _m.Called(ctx, constraintID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConstraint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, constraintID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetActiveConstraints provides a mock function with given fields: ctx, userID
func (_m *RiskService) GetActiveConstraints(ctx context.Context, userID string) ([]*model.RiskConstraint, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveConstraints")
	}

	var r0 []*model.RiskConstraint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*model.RiskConstraint, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.RiskConstraint); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.RiskConstraint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetActiveRisks provides a mock function with given fields: ctx, userID
func (_m *RiskService) GetActiveRisks(ctx context.Context, userID string) ([]*model.RiskAssessment, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveRisks")
	}

	var r0 []*model.RiskAssessment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*model.RiskAssessment, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.RiskAssessment); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.RiskAssessment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserRiskProfile provides a mock function with given fields: ctx, userID
func (_m *RiskService) GetUserRiskProfile(ctx context.Context, userID string) (*model.RiskProfile, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserRiskProfile")
	}

	var r0 *model.RiskProfile
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.RiskProfile, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.RiskProfile); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.RiskProfile)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IgnoreRisk provides a mock function with given fields: ctx, riskID
func (_m *RiskService) IgnoreRisk(ctx context.Context, riskID string) error {
	ret := _m.Called(ctx, riskID)

	if len(ret) == 0 {
		panic("no return value specified for IgnoreRisk")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, riskID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResolveRisk provides a mock function with given fields: ctx, riskID
func (_m *RiskService) ResolveRisk(ctx context.Context, riskID string) error {
	ret := _m.Called(ctx, riskID)

	if len(ret) == 0 {
		panic("no return value specified for ResolveRisk")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, riskID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateConstraint provides a mock function with given fields: ctx, constraint
func (_m *RiskService) UpdateConstraint(ctx context.Context, constraint *model.RiskConstraint) error {
	ret := _m.Called(ctx, constraint)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConstraint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.RiskConstraint) error); ok {
		r0 = rf(ctx, constraint)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateUserRiskProfile provides a mock function with given fields: ctx, profile
func (_m *RiskService) UpdateUserRiskProfile(ctx context.Context, profile *model.RiskProfile) error {
	ret := _m.Called(ctx, profile)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserRiskProfile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.RiskProfile) error); ok {
		r0 = rf(ctx, profile)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewRiskService creates a new instance of RiskService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRiskService(t interface {
	mock.TestingT
	Cleanup(func())
}) *RiskService {
	mock := &RiskService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
