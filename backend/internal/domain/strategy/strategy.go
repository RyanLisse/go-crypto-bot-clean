package strategy

import (
	"context"
	"time"

	"go-crypto-bot-clean/backend/internal/domain/models"
)

// Signal represents a trading signal generated by a strategy
type Signal struct {
	Symbol          string                 // The trading pair symbol
	Type            SignalType             // Buy, sell, or hold
	Confidence      float64                // Signal confidence score (0-1.0)
	Price           float64                // Current price when signal was generated
	TargetPrice     float64                // Target price if applicable
	StopLoss        float64                // Recommended stop-loss level
	TakeProfit      float64                // Recommended take-profit level
	Timeframe       string                 // Timeframe this signal is based on (e.g., "15m", "1h")
	Timestamp       time.Time              // When this signal was generated
	ExpirationTime  time.Time              // When this signal should be considered invalid
	Metadata        map[string]interface{} // Additional strategy-specific information
	RecommendedSize float64                // Recommended position size (0-1.0)
}

// SignalType represents the type of trading signal
type SignalType string

const (
	SignalBuy   SignalType = "BUY"
	SignalSell  SignalType = "SELL"
	SignalHold  SignalType = "HOLD"
	SignalClose SignalType = "CLOSE"
)

// Strategy defines the interface that all trading strategies must implement
type Strategy interface {
	// GetName returns the name of the strategy
	GetName() string

	// Initialize prepares the strategy with initial configuration
	Initialize(ctx context.Context, config map[string]interface{}) error

	// UpdateParameters updates the strategy parameters
	UpdateParameters(ctx context.Context, params map[string]interface{}) error

	// OnPriceUpdate processes a new price update and may generate a signal
	OnPriceUpdate(ctx context.Context, priceUpdate *models.PriceUpdate) (*Signal, error)

	// OnCandleUpdate processes a new candle and may generate a signal
	OnCandleUpdate(ctx context.Context, candle *models.Candle) (*Signal, error)

	// OnTradeUpdate processes a new trade and may generate a signal
	OnTradeUpdate(ctx context.Context, trade *models.Trade) (*Signal, error)

	// OnMarketDepthUpdate processes a new market depth update and may generate a signal
	OnMarketDepthUpdate(ctx context.Context, depth *models.OrderBook) (*Signal, error)

	// OnTimerEvent processes a scheduled timer event
	OnTimerEvent(ctx context.Context, eventType string) (*Signal, error)

	// GetTimeframes returns the timeframes this strategy requires
	GetTimeframes() []string

	// GetRequiredDataTypes returns the types of data this strategy needs
	GetRequiredDataTypes() []string

	// PerformBacktest runs a backtest of the strategy on historical data
	PerformBacktest(ctx context.Context, historicalData []*models.Candle, params map[string]interface{}) ([]*Signal, *models.BacktestResult, error)
}

// AdvancedStrategy extends the base Strategy interface with advanced capabilities
type AdvancedStrategy interface {
	Strategy

	// GetMarketRegime determines the current market regime (trending, ranging, etc.)
	GetMarketRegime(ctx context.Context, symbol string, timeframe string) (string, error)

	// OptimizeParameters optimizes strategy parameters based on recent performance
	OptimizeParameters(ctx context.Context, historicalData []*models.Candle) (map[string]interface{}, error)

	// GetConfidenceMetrics returns metrics about strategy confidence in current market
	GetConfidenceMetrics(ctx context.Context) (map[string]float64, error)

	// GetIndicatorValues returns the current values of internal technical indicators
	GetIndicatorValues(ctx context.Context) (map[string]interface{}, error)

	// SwitchTimeframeMode adapts the strategy to use different timeframe combinations
	SwitchTimeframeMode(ctx context.Context, mode string) error
}

// StrategyFactory creates different types of trading strategies
type StrategyFactory interface {
	// CreateStrategy creates a strategy by name
	CreateStrategy(ctx context.Context, name string, config map[string]interface{}) (Strategy, error)

	// ListAvailableStrategies returns all available strategy names
	ListAvailableStrategies() []string

	// GetDefaultConfig returns the default configuration for a strategy
	GetDefaultConfig(strategyName string) map[string]interface{}

	// ValidateConfig checks if a configuration is valid for a strategy
	ValidateConfig(strategyName string, config map[string]interface{}) (bool, []string, error)

	// GetStrategyForMarketRegime returns the appropriate strategy for the current market regime
	GetStrategyForMarketRegime(ctx context.Context, marketData *MarketData) (Strategy, error)
}

// StrategyManager manages multiple strategies and selects the best one
type StrategyManager interface {
	// RegisterStrategy adds a strategy to the manager
	RegisterStrategy(strategy Strategy, weight float64) error

	// UnregisterStrategy removes a strategy from the manager
	UnregisterStrategy(strategyName string) error

	// GetBestSignal gets the best signal from all registered strategies
	GetBestSignal(ctx context.Context, symbol string) (*Signal, error)

	// UpdateStrategyWeights updates the weights used to blend strategy signals
	UpdateStrategyWeights(ctx context.Context, weights map[string]float64) error

	// GetRegisteredStrategies returns all registered strategies
	GetRegisteredStrategies() map[string]Strategy
}
