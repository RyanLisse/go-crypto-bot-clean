// Package execution provides the core framework for managing and executing trading strategies.
package execution

import (
	"context"
	"errors"
	"fmt"
	"sync"
)

// Strategy defines the lifecycle methods every strategy must implement.
type Strategy interface {
	// Initialize prepares the strategy with necessary context or configuration.
	Initialize(ctx context.Context) error
	// Start begins the strategy's execution.
	Start(ctx context.Context) error
	// Stop halts the strategy's execution gracefully.
	Stop(ctx context.Context) error
}

// Signal represents a trading signal input.
type Signal struct {
	StrategyID string
	Type       string
	Payload    map[string]interface{}
}

// Order represents an order output generated by a strategy.
type Order struct {
	StrategyID string
	Symbol     string
	Side       string
	Quantity   float64
	Price      float64
	Meta       map[string]interface{}
}

// EventHook defines callbacks for various execution events.
type EventHook interface {
	OnSignalReceived(signal Signal)
	OnOrderPlaced(order Order)
	OnStatusUpdate(strategyID string, status string, err error)
}

// StrategyExecutor manages multiple strategies, their lifecycle, and signal/order flow.
type StrategyExecutor struct {
	strategies map[string]Strategy
	hooks      []EventHook
	mu         sync.RWMutex

	// Advanced fields
	signalCh  chan Signal
	orderCh   chan Order
	controlCh chan func()
	stopCh    chan struct{}
	wg        sync.WaitGroup

	// Hot-reloadable parameters per strategy
	params sync.Map // map[string]map[string]interface{}

	// Plugins
	riskPlugins    []RiskPlugin
	metricsPlugins []MetricsPlugin
}

// NewStrategyExecutor creates a new StrategyExecutor instance.
func NewStrategyExecutor() *StrategyExecutor {
	se := &StrategyExecutor{
		strategies: make(map[string]Strategy),
		hooks:      []EventHook{},
		signalCh:   make(chan Signal, 1000),
		orderCh:    make(chan Order, 1000),
		controlCh:  make(chan func(), 100),
		stopCh:     make(chan struct{}),
	}
	se.startDispatcher()
	return se
}

// RegisterHook adds an event hook for callbacks.
func (se *StrategyExecutor) RegisterHook(hook EventHook) {
	se.mu.Lock()
	defer se.mu.Unlock()
	se.hooks = append(se.hooks, hook)
}

// RegisterRiskPlugin adds a risk plugin
func (se *StrategyExecutor) RegisterRiskPlugin(plugin RiskPlugin) {
	se.mu.Lock()
	defer se.mu.Unlock()
	se.riskPlugins = append(se.riskPlugins, plugin)
}

// RegisterMetricsPlugin adds a metrics plugin
func (se *StrategyExecutor) RegisterMetricsPlugin(plugin MetricsPlugin) {
	se.mu.Lock()
	defer se.mu.Unlock()
	se.metricsPlugins = append(se.metricsPlugins, plugin)
}

// AddStrategy registers a new strategy with a unique ID.
func (se *StrategyExecutor) AddStrategy(id string, strategy Strategy) error {
	se.mu.Lock()
	defer se.mu.Unlock()
	if _, exists := se.strategies[id]; exists {
		return fmt.Errorf("strategy with ID %s already exists", id)
	}
	se.strategies[id] = strategy
	return nil
}

// RemoveStrategy removes a strategy by ID.
func (se *StrategyExecutor) RemoveStrategy(id string) error {
	se.mu.Lock()
	defer se.mu.Unlock()
	if _, exists := se.strategies[id]; !exists {
		return fmt.Errorf("strategy with ID %s does not exist", id)
	}
	delete(se.strategies, id)
	return nil
}

// InitializeAll initializes all registered strategies.
func (se *StrategyExecutor) InitializeAll(ctx context.Context) error {
	se.mu.RLock()
	defer se.mu.RUnlock()
	for id, strat := range se.strategies {
		if err := strat.Initialize(ctx); err != nil {
			se.notifyStatus(id, "initialize_failed", err)
			return err
		}
		se.notifyStatus(id, "initialized", nil)
	}
	return nil
}

// StartAll starts all registered strategies.
func (se *StrategyExecutor) StartAll(ctx context.Context) error {
	se.mu.RLock()
	defer se.mu.RUnlock()
	for id, strat := range se.strategies {
		if err := strat.Start(ctx); err != nil {
			se.notifyStatus(id, "start_failed", err)
			return err
		}
		se.notifyStatus(id, "running", nil)
	}
	return nil
}

// StopAll stops all running strategies.
func (se *StrategyExecutor) StopAll(ctx context.Context) error {
	se.mu.RLock()
	defer se.mu.RUnlock()
	for id, strat := range se.strategies {
		if err := strat.Stop(ctx); err != nil {
			se.notifyStatus(id, "stop_failed", err)
			return err
		}
		se.notifyStatus(id, "stopped", nil)
	}
	return nil
}

// HandleSignal processes an incoming signal and dispatches it to the appropriate strategy.
func (se *StrategyExecutor) HandleSignal(signal Signal) error {
	select {
	case se.signalCh <- signal:
		return nil
	default:
		return errors.New("signal queue full")
	}
}

// PlaceOrder handles order placement logic and notifies hooks.
func (se *StrategyExecutor) PlaceOrder(order Order) error {
	select {
	case se.orderCh <- order:
		return nil
	default:
		return errors.New("order queue full")
	}
}

func (se *StrategyExecutor) notifySignal(signal Signal) {
	se.mu.RLock()
	defer se.mu.RUnlock()
	for _, hook := range se.hooks {
		go hook.OnSignalReceived(signal)
	}
}

func (se *StrategyExecutor) notifyOrder(order Order) {
	se.mu.RLock()
	defer se.mu.RUnlock()
	for _, hook := range se.hooks {
		go hook.OnOrderPlaced(order)
	}
}

func (se *StrategyExecutor) notifyStatus(strategyID string, status string, err error) {
	se.mu.RLock()
	defer se.mu.RUnlock()
	for _, hook := range se.hooks {
		go hook.OnStatusUpdate(strategyID, status, err)
	}
}

type RiskPlugin interface {
	BeforeOrder(order *Order) error
}

type MetricsPlugin interface {
	RecordEvent(event string, data map[string]interface{})
}

// startDispatcher launches the async processing loop
func (se *StrategyExecutor) startDispatcher() {
	se.wg.Add(1)
	go func() {
		defer se.wg.Done()
		for {
			select {
			case sig := <-se.signalCh:
				go se.processSignal(sig)
			case ord := <-se.orderCh:
				go se.processOrder(ord)
			case ctrl := <-se.controlCh:
				ctrl()
			case <-se.stopCh:
				return
			}
		}
	}()
}

// StopDispatcher stops async processing
func (se *StrategyExecutor) StopDispatcher() {
	close(se.stopCh)
	se.wg.Wait()
}

// processSignal handles a signal asynchronously
func (se *StrategyExecutor) processSignal(signal Signal) {
	defer se.recoverAndLog("processSignal", signal.StrategyID)
	se.notifySignal(signal)

	se.mu.RLock()
	strategy, exists := se.strategies[signal.StrategyID]
	se.mu.RUnlock()
	if !exists {
		return
	}
	_ = strategy

	// Here you can pass the signal to the strategy, e.g., via a method or channel
	// For now, just log
	se.logEvent("signal_processed", map[string]interface{}{"strategy_id": signal.StrategyID})
}

// processOrder handles an order asynchronously
func (se *StrategyExecutor) processOrder(order Order) {
	defer se.recoverAndLog("processOrder", order.StrategyID)

	// Risk checks
	for _, plugin := range se.riskPlugins {
		if err := plugin.BeforeOrder(&order); err != nil {
			se.logEvent("order_blocked", map[string]interface{}{"strategy_id": order.StrategyID, "error": err.Error()})
			return
		}
	}

	// Notify hooks
	se.notifyOrder(order)

	// Metrics
	se.logEvent("order_placed", map[string]interface{}{"strategy_id": order.StrategyID})
}

// recoverAndLog handles panics gracefully
func (se *StrategyExecutor) recoverAndLog(context string, strategyID string) {
	if r := recover(); r != nil {
		se.notifyStatus(strategyID, context+"_panic", fmt.Errorf("%v", r))
		se.logEvent("panic_recovered", map[string]interface{}{"context": context, "strategy_id": strategyID, "error": r})
	}
}

// logEvent sends event data to metrics plugins
func (se *StrategyExecutor) logEvent(event string, data map[string]interface{}) {
	for _, plugin := range se.metricsPlugins {
		plugin.RecordEvent(event, data)
	}
}

// UpdateStrategyParams hot-reloads parameters for a strategy
func (se *StrategyExecutor) UpdateStrategyParams(id string, params map[string]interface{}) {
	se.params.Store(id, params)
	se.logEvent("params_updated", map[string]interface{}{"strategy_id": id})
}

// HotReloadStrategy safely updates a strategy implementation at runtime
func (se *StrategyExecutor) HotReloadStrategy(id string, newStrategy Strategy) error {
	done := make(chan error, 1)
	se.controlCh <- func() {
		se.mu.Lock()
		defer se.mu.Unlock()
		if _, exists := se.strategies[id]; !exists {
			done <- fmt.Errorf("strategy %s not found", id)
			return
		}
		se.strategies[id] = newStrategy
		done <- nil
	}
	return <-done
}
