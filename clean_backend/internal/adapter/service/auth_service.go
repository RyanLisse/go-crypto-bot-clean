package service

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/RyanLisse/go-crypto-bot-clean/clean_backend/internal/apperror"
	"github.com/RyanLisse/go-crypto-bot-clean/clean_backend/internal/config"
	"github.com/RyanLisse/go-crypto-bot-clean/clean_backend/internal/domain/model"
	"github.com/RyanLisse/go-crypto-bot-clean/clean_backend/internal/domain/port"
	"github.com/rs/zerolog"
)

// ClerkAuthService implements the AuthServiceInterface using Clerk
type ClerkAuthService struct {
	logger     *zerolog.Logger
	config     *config.Config
	userCache  map[string]*model.User
	cacheMutex sync.RWMutex
}

// NewClerkAuthService creates a new ClerkAuthService
func NewClerkAuthService(config *config.Config, logger *zerolog.Logger) port.AuthServiceInterface {
	// Check if Clerk secret key is set
	if config.Auth.ClerkSecretKey == "" {
		logger.Warn().Msg("CLERK_SECRET_KEY not set, authentication will not work properly")
	}

	return &ClerkAuthService{
		logger:     logger,
		config:     config,
		userCache:  make(map[string]*model.User),
		cacheMutex: sync.RWMutex{},
	}
}

// GetUserByID retrieves a user by their ID
func (s *ClerkAuthService) GetUserByID(ctx context.Context, userID string) (*model.User, error) {
	// Check cache first
	s.cacheMutex.RLock()
	if user, ok := s.userCache[userID]; ok {
		s.cacheMutex.RUnlock()
		return user, nil
	}
	s.cacheMutex.RUnlock()

	// In a real implementation, we would call the Clerk API here
	// For now, we'll create a mock user
	user := &model.User{
		ID:        userID,
		Email:     fmt.Sprintf("%s@example.com", userID),
		Name:      fmt.Sprintf("User %s", userID),
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Cache user
	s.cacheMutex.Lock()
	s.userCache[userID] = user
	s.cacheMutex.Unlock()

	return user, nil
}

// GetUserRoles retrieves the roles for a given user ID
func (s *ClerkAuthService) GetUserRoles(ctx context.Context, userID string) ([]string, error) {
	// In a real implementation, we would call the Clerk API here
	// For now, we'll return default roles

	// If userID contains "admin", add admin role
	roles := []string{"user"} // Default role
	if strings.Contains(userID, "admin") {
		roles = append(roles, "admin")
	}

	return roles, nil
}

// GetUserFromToken retrieves a user based on an authentication token
func (s *ClerkAuthService) GetUserFromToken(ctx context.Context, token string) (*model.User, error) {
	// In a real implementation, we would verify the token with Clerk
	// For now, we'll extract the user ID from the token

	// Simple token format: "user_<user_id>"
	if !strings.HasPrefix(token, "user_") {
		return nil, apperror.NewUnauthorized("Invalid token format", nil)
	}

	userID := strings.TrimPrefix(token, "user_")

	// Get user by ID
	return s.GetUserByID(ctx, userID)
}

// ValidateToken validates an authentication token
func (s *ClerkAuthService) ValidateToken(ctx context.Context, token string) (bool, error) {
	// In a real implementation, we would verify the token with Clerk
	// For now, we'll just check if the token has the expected format

	// Simple token format: "user_<user_id>"
	if !strings.HasPrefix(token, "user_") {
		return false, apperror.NewUnauthorized("Invalid token format", nil)
	}

	return true, nil
}

// GenerateToken generates an authentication token for a user
func (s *ClerkAuthService) GenerateToken(ctx context.Context, userID string) (string, error) {
	// This is not supported by Clerk directly
	// Tokens are generated by Clerk frontend SDK
	return "", apperror.NewInternal(errors.New("Token generation not supported by Clerk"))
}

// RevokeToken revokes an authentication token
func (s *ClerkAuthService) RevokeToken(ctx context.Context, token string) error {
	// This is not supported by Clerk directly
	// Token revocation is handled by Clerk
	return apperror.NewInternal(errors.New("Token revocation not supported by Clerk"))
}

// TestAuthService implements the AuthServiceInterface for testing
type TestAuthService struct {
	users map[string]*model.User
	roles map[string][]string
}

// NewTestAuthService creates a new TestAuthService
func NewTestAuthService() port.AuthServiceInterface {
	// Create some test users
	users := map[string]*model.User{
		"test_user_id": {
			ID:        "test_user_id",
			Email:     "test@example.com",
			Name:      "Test User",
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		},
		"admin_user_id": {
			ID:        "admin_user_id",
			Email:     "admin@example.com",
			Name:      "Admin User",
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		},
	}

	// Create some test roles
	roles := map[string][]string{
		"test_user_id":  {"user"},
		"admin_user_id": {"user", "admin"},
	}

	return &TestAuthService{
		users: users,
		roles: roles,
	}
}

// GetUserByID retrieves a user by their ID
func (s *TestAuthService) GetUserByID(ctx context.Context, userID string) (*model.User, error) {
	if user, ok := s.users[userID]; ok {
		return user, nil
	}
	return nil, apperror.NewNotFound(fmt.Sprintf("User with ID %s not found", userID), userID, nil)
}

// GetUserRoles retrieves the roles for a given user ID
func (s *TestAuthService) GetUserRoles(ctx context.Context, userID string) ([]string, error) {
	if roles, ok := s.roles[userID]; ok {
		return roles, nil
	}
	return []string{"user"}, nil
}

// GetUserFromToken retrieves a user based on an authentication token
func (s *TestAuthService) GetUserFromToken(ctx context.Context, token string) (*model.User, error) {
	// In test mode, token is the user ID
	return s.GetUserByID(ctx, token)
}

// ValidateToken validates an authentication token
func (s *TestAuthService) ValidateToken(ctx context.Context, token string) (bool, error) {
	// In test mode, all tokens are valid
	return true, nil
}

// GenerateToken generates an authentication token for a user
func (s *TestAuthService) GenerateToken(ctx context.Context, userID string) (string, error) {
	// In test mode, token is the user ID
	return userID, nil
}

// RevokeToken revokes an authentication token
func (s *TestAuthService) RevokeToken(ctx context.Context, token string) error {
	// In test mode, do nothing
	return nil
}

// AuthServiceFactory creates authentication services
type AuthServiceFactory struct {
	config *config.Config
	logger *zerolog.Logger
}

// NewAuthServiceFactory creates a new AuthServiceFactory
func NewAuthServiceFactory(config *config.Config, logger *zerolog.Logger) *AuthServiceFactory {
	return &AuthServiceFactory{
		config: config,
		logger: logger,
	}
}

// CreateAuthService creates an authentication service based on the configuration
func (f *AuthServiceFactory) CreateAuthService() port.AuthServiceInterface {
	// Check if auth is disabled
	if f.config.Auth.Disabled {
		return NewTestAuthService()
	}

	// Check provider
	switch f.config.Auth.Provider {
	case "clerk":
		return NewClerkAuthService(f.config, f.logger)
	default:
		// Default to test auth service
		return NewTestAuthService()
	}
}
