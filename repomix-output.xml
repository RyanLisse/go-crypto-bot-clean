This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
cmd/
  server/
    main.go
configs/
  config.yaml
internal/
  adapter/
    cache/
      memory/
        generic_cache_test.go
        generic_cache.go
        market_cache.go
        ticker_cache.go
    delivery/
      http/
        router.go
    gateway/
      ai/
        gemini.go
    http/
      handler/
        ai_handler.go
        market_data.go
      router.go
    persistence/
      gorm/
        db.go
        market_repository.go
        order_repository.go
        position_repository.go
        wallet_repository.go
      memory/
        conversation_repository.go
  apperror/
    errors.go
  config/
    config.go
  domain/
    model/
      market/
        candle.go
        orderbook.go
        symbol.go
        ticker.go
      account.go
      ai_types.go
      exchange.go
      order.go
      position.go
      ticker.go
      wallet.go
    port/
      ai_gateway.go
      cache.go
      gateway.go
      market_repository.go
      repository.go
  factory/
    ai_factory.go
    market_factory.go
  platform/
    logger/
      logger.go
    mexc/
      apikeystore/
        keystore_test.go
        keystore.go
      rest/
        api_test.go
        api.go
        client.go
      websocket/
        client.go
  usecase/
    account_uc.go
    ai_uc.go
    market_data.go
migrations/
  000001_create_initial_schema.down.sql
  000001_create_initial_schema.up.sql
pkg/
  ratelimiter/
    ratelimiter.go
  retry/
    retry_test.go
    retry.go
go.mod
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cmd/server/main.go">
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	httpAdapter "github.com/neo/crypto-bot/internal/adapter/http"
	"github.com/neo/crypto-bot/internal/adapter/http/handler"
	gormAdapter "github.com/neo/crypto-bot/internal/adapter/persistence/gorm"
	"github.com/neo/crypto-bot/internal/config"
	"github.com/neo/crypto-bot/internal/factory"
	"github.com/neo/crypto-bot/internal/platform/logger"
)

func main() {
	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// Initialize logger
	l := logger.New(cfg.LogLevel)
	l.Info().Msg("Starting crypto trading bot server...")

	// Setup Database Connection
	dbConn, err := gormAdapter.NewDBConnection(cfg, l)
	if err != nil {
		l.Fatal().Err(err).Msg("Failed to connect to database")
	}
	// Run Migrations
	gormAdapter.AutoMigrateModels(dbConn, l)

	// Set up router
	router := httpAdapter.SetupRouter(l)

	// Create factories
	aiFactory := factory.NewAIFactory(cfg, l)
	marketFactory := factory.NewMarketFactory(cfg, l, dbConn)

	// Create AI handler
	aiHandler, err := aiFactory.CreateAIHandler()
	if err != nil {
		l.Fatal().Err(err).Msg("Failed to create AI handler")
	}

	// Create Market Data Use Case and Handler
	marketUseCase, err := marketFactory.CreateMarketDataUseCase()
	if err != nil {
		l.Fatal().Err(err).Msg("Failed to create Market Data Use Case")
	}
	marketHandler := handler.NewMarketDataHandler(marketUseCase, l)

	// Register AI routes
	// For now, we'll use a dummy auth middleware
	aiHandler.RegisterRoutes(router, func(c *gin.Context) {
		// In a real implementation, this would validate JWT tokens
		c.Next()
	})

	// Register Market Data routes
	apiV1 := router.Group("/api/v1") // Group routes under /api/v1
	marketHandler.RegisterRoutes(apiV1)

	// Start server
	srv := &http.Server{
		Addr:    fmt.Sprintf(":%d", cfg.Server.Port),
		Handler: router,
	}

	// Run server in a goroutine
	go func() {
		l.Info().Msgf("Server is listening on port %d", cfg.Server.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			l.Fatal().Err(err).Msg("Failed to start server")
		}
	}()

	// Set up graceful shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	l.Info().Msg("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		l.Fatal().Err(err).Msg("Server forced to shutdown")
	}

	l.Info().Msg("Server exited properly")
}
</file>

<file path="configs/config.yaml">
# Server configuration
server:
  port: 8080
  host: "0.0.0.0"
  read_timeout: 30s
  write_timeout: 30s
  idle_timeout: 60s

# Environment
env: "development"
log_level: "info"

# Database configuration
database:
  driver: "sqlite"
  path: "./data/crypto_bot.db"
  turso:
    enabled: true
    url: "${TURSO_URL}"
    auth_token: "${TURSO_AUTH_TOKEN}"

# MEXC API configuration
mexc:
  api_key: "${MEXC_API_KEY}"
  api_secret: "${MEXC_SECRET_KEY}"
  base_url: "${MEXC_BASE_URL}"
  ws_base_url: "${MEXC_WEBSOCKET_URL}"
  use_testnet: false
  rate_limit:
    requests_per_minute: 1200
    burst_size: 10

# AI configuration
ai:
  provider: "gemini"
  api_key: "${OPENAI_API_KEY}"
  model: "gpt-4"
  gemini_api_key: "${GOOGLE_API_KEY}"
  gemini_model: "gemini-1.5-flash"
  system_prompt: "You are a crypto trading assistant. You help users understand their portfolio, market trends, and provide trading advice. Keep responses concise and focused on crypto trading."
  temperature: 0.7
  top_p: 0.95
  top_k: 40
  max_tokens: 1024
</file>

<file path="internal/adapter/cache/memory/generic_cache_test.go">
package memory

import (
	"errors"
	"testing"
	"time"
)

type testStruct struct {
	ID   string
	Name string
}

func TestGenericCache_Get(t *testing.T) {
	cache := NewGenericCache[testStruct](time.Second)

	// Initially the cache should be empty
	value, found := cache.Get()
	if found {
		t.Errorf("Expected empty cache to return found=false, got found=true")
	}
	if value != nil {
		t.Errorf("Expected empty cache to return nil value, got %v", value)
	}

	// Set a value and verify we can get it
	testValue := &testStruct{ID: "1", Name: "Test"}
	cache.Set(testValue)

	value, found = cache.Get()
	if !found {
		t.Errorf("Expected value to be found in cache, got found=false")
	}
	if value == nil {
		t.Errorf("Expected non-nil value from cache")
	} else if value.ID != testValue.ID || value.Name != testValue.Name {
		t.Errorf("Expected value %v, got %v", testValue, value)
	}

	// Test expiration
	cache = NewGenericCache[testStruct](10 * time.Millisecond)
	cache.Set(testValue)

	time.Sleep(20 * time.Millisecond)

	value, found = cache.Get()
	if found {
		t.Errorf("Expected value to be expired, got found=true")
	}
	if value != nil {
		t.Errorf("Expected nil value for expired entry, got %v", value)
	}
}

func TestGenericCache_GetOrSet(t *testing.T) {
	cache := NewGenericCache[testStruct](time.Second)

	// Test with successful fetch function
	fetchCalled := false
	fetchFn := func() (*testStruct, error) {
		fetchCalled = true
		return &testStruct{ID: "1", Name: "Test"}, nil
	}

	value, err := cache.GetOrSet(fetchFn)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if value == nil {
		t.Errorf("Expected non-nil value")
	} else if value.ID != "1" || value.Name != "Test" {
		t.Errorf("Expected {ID:1, Name:Test}, got %v", value)
	}
	if !fetchCalled {
		t.Errorf("Expected fetch function to be called")
	}

	// Second call should use cached value
	fetchCalled = false
	value, err = cache.GetOrSet(fetchFn)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if value == nil {
		t.Errorf("Expected non-nil value")
	}
	if fetchCalled {
		t.Errorf("Expected fetch function not to be called on cache hit")
	}

	// Test with failing fetch function
	cache = NewGenericCache[testStruct](time.Second)
	failingFetchFn := func() (*testStruct, error) {
		return nil, errors.New("fetch error")
	}

	value, err = cache.GetOrSet(failingFetchFn)
	if err == nil {
		t.Errorf("Expected error to be returned from failing fetch function")
	}
	if value != nil {
		t.Errorf("Expected nil value on error, got %v", value)
	}
}

func TestGenericCache_Invalidate(t *testing.T) {
	cache := NewGenericCache[testStruct](time.Minute)

	// Set a value
	testValue := &testStruct{ID: "1", Name: "Test"}
	cache.Set(testValue)

	// Verify it's there
	value, found := cache.Get()
	if !found || value == nil {
		t.Errorf("Expected value to be in cache before invalidation")
	}

	// Invalidate and verify it's gone
	cache.Invalidate()

	value, found = cache.Get()
	if found {
		t.Errorf("Expected value not to be found after invalidation")
	}
	if value != nil {
		t.Errorf("Expected nil value after invalidation, got %v", value)
	}
}

func TestGenericCache_UpdateTTL(t *testing.T) {
	cache := NewGenericCache[testStruct](100 * time.Millisecond)

	// Set a value
	testValue := &testStruct{ID: "1", Name: "Test"}
	cache.Set(testValue)

	// Update TTL to longer duration
	cache.UpdateTTL(10 * time.Minute)

	// Sleep past original TTL
	time.Sleep(200 * time.Millisecond)

	// Value should still be present due to extended TTL
	value, found := cache.Get()
	if !found {
		t.Errorf("Expected value to still be in cache after TTL extension")
	}
	if value == nil {
		t.Errorf("Expected non-nil value after TTL extension")
	}

	// Test with invalid TTL (should not change existing TTL)
	cache = NewGenericCache[testStruct](time.Minute)
	cache.Set(testValue)
	cache.UpdateTTL(-10 * time.Second)

	// Verify original TTL is still in effect
	// This is harder to test directly, but we can check that the value is still there
	value, found = cache.Get()
	if !found || value == nil {
		t.Errorf("Expected value to still be in cache after invalid TTL update")
	}
}
</file>

<file path="internal/adapter/cache/memory/generic_cache.go">
package memory

import (
	"sync"
	"time"

	"github.com/neo/crypto-bot/internal/domain/port"
)

// GenericCache provides a generic cache implementation with TTL support
type GenericCache[T any] struct {
	value      *T
	expiration time.Time
	ttl        time.Duration
	mutex      sync.RWMutex
}

// NewGenericCache creates a new cache instance with the specified TTL
func NewGenericCache[T any](ttl time.Duration) port.Cache[T] {
	if ttl <= 0 {
		ttl = 5 * time.Minute // Default TTL
	}

	return &GenericCache[T]{
		value:      nil,
		expiration: time.Time{},
		ttl:        ttl,
		mutex:      sync.RWMutex{},
	}
}

// Get retrieves the cached value if it exists and is not expired
// Returns the value and a boolean indicating if the value was found
func (c *GenericCache[T]) Get() (*T, bool) {
	c.mutex.RLock()
	defer c.mutex.RUnlock()

	if c.value == nil || time.Now().After(c.expiration) {
		return nil, false
	}

	return c.value, true
}

// Set stores a value in the cache with the configured TTL
func (c *GenericCache[T]) Set(value *T) {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	c.value = value
	c.expiration = time.Now().Add(c.ttl)
}

// GetOrSet retrieves the cached value if valid, or sets it using the provided function
func (c *GenericCache[T]) GetOrSet(fetchFn func() (*T, error)) (*T, error) {
	// Check cache first
	if value, found := c.Get(); found {
		return value, nil
	}

	// Fetch new value
	value, err := fetchFn()
	if err != nil {
		return nil, err
	}

	// Store in cache
	c.Set(value)
	return value, nil
}

// Invalidate clears the cached value
func (c *GenericCache[T]) Invalidate() {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	c.value = nil
	c.expiration = time.Time{}
}

// UpdateTTL changes the TTL for the cache
func (c *GenericCache[T]) UpdateTTL(ttl time.Duration) {
	if ttl <= 0 {
		return
	}

	c.mutex.Lock()
	defer c.mutex.Unlock()

	c.ttl = ttl

	// Update expiration for existing value if present
	if c.value != nil && !c.expiration.IsZero() {
		c.expiration = time.Now().Add(ttl)
	}
}
</file>

<file path="internal/adapter/cache/memory/market_cache.go">
package memory

import (
	"context"
	"strings"
	"sync"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model/market"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog"
)

// MarketCache provides in-memory caching for market data
type MarketCache struct {
	// Ticker caches
	tickers           map[string]*market.Ticker // key: exchange:symbol
	latestTickers     map[string]*market.Ticker // key: symbol
	tickersByExchange map[string][]*market.Ticker

	// Candle caches
	candles       map[string]*market.Candle // key: exchange:symbol:interval:timestamp
	latestCandles map[string]*market.Candle // key: exchange:symbol:interval

	// OrderBook caches
	orderbooks map[string]*market.OrderBook // key: exchange:symbol

	// Expiration settings
	tickerExpiry    time.Duration
	candleExpiry    time.Duration
	orderbookExpiry time.Duration

	// Cache metadata
	lastUpdated map[string]time.Time

	// Logger
	logger *zerolog.Logger

	// Mutex for thread safety
	mu sync.RWMutex
}

// NewMarketCache creates a new in-memory market data cache
func NewMarketCache(logger *zerolog.Logger) port.MarketCache {
	return &MarketCache{
		tickers:           make(map[string]*market.Ticker),
		latestTickers:     make(map[string]*market.Ticker),
		tickersByExchange: make(map[string][]*market.Ticker),
		candles:           make(map[string]*market.Candle),
		latestCandles:     make(map[string]*market.Candle),
		orderbooks:        make(map[string]*market.OrderBook),
		lastUpdated:       make(map[string]time.Time),
		tickerExpiry:      5 * time.Minute,  // Default ticker expiry
		candleExpiry:      60 * time.Minute, // Default candle expiry
		orderbookExpiry:   30 * time.Second, // Default orderbook expiry
		logger:            logger,
	}
}

// SetTickerExpiry sets the ticker cache expiration duration
func (c *MarketCache) SetTickerExpiry(d time.Duration) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.tickerExpiry = d
}

// SetCandleExpiry sets the candle cache expiration duration
func (c *MarketCache) SetCandleExpiry(d time.Duration) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.candleExpiry = d
}

// SetOrderbookExpiry sets the orderbook cache expiration duration
func (c *MarketCache) SetOrderbookExpiry(d time.Duration) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.orderbookExpiry = d
}

// CacheTicker stores a ticker in cache
func (c *MarketCache) CacheTicker(ticker *market.Ticker) {
	if ticker == nil {
		return
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	key := c.getTickerKey(ticker.Exchange, ticker.Symbol)
	c.tickers[key] = ticker
	c.latestTickers[ticker.Symbol] = ticker
	c.lastUpdated[key] = time.Now()

	// Update the tickers by exchange cache
	exchangeTickers, exists := c.tickersByExchange[ticker.Exchange]
	if !exists {
		exchangeTickers = make([]*market.Ticker, 0)
	}

	// Check if we already have this symbol in the exchange tickers
	found := false
	for i, t := range exchangeTickers {
		if t.Symbol == ticker.Symbol {
			exchangeTickers[i] = ticker
			found = true
			break
		}
	}

	if !found {
		exchangeTickers = append(exchangeTickers, ticker)
	}

	c.tickersByExchange[ticker.Exchange] = exchangeTickers
	c.logger.Debug().Str("exchange", ticker.Exchange).Str("symbol", ticker.Symbol).Msg("Ticker cached")
}

// GetTicker retrieves a ticker from cache
func (c *MarketCache) GetTicker(ctx context.Context, exchange, symbol string) (*market.Ticker, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := c.getTickerKey(exchange, symbol)
	ticker, exists := c.tickers[key]
	if !exists {
		return nil, false
	}

	// Check if ticker has expired
	lastUpdate, updated := c.lastUpdated[key]
	if !updated || time.Since(lastUpdate) > c.tickerExpiry {
		c.logger.Debug().Str("exchange", exchange).Str("symbol", symbol).Msg("Ticker cache expired")
		return nil, false
	}

	return ticker, true
}

// GetAllTickers retrieves all tickers for an exchange from cache
func (c *MarketCache) GetAllTickers(ctx context.Context, exchange string) ([]*market.Ticker, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	tickers, exists := c.tickersByExchange[exchange]
	if !exists || len(tickers) == 0 {
		return nil, false
	}

	// Check if any exchange tickers have expired
	key := "exchange:" + exchange
	lastUpdate, updated := c.lastUpdated[key]
	if !updated || time.Since(lastUpdate) > c.tickerExpiry {
		c.logger.Debug().Str("exchange", exchange).Msg("Exchange tickers cache expired")
		return nil, false
	}

	return tickers, true
}

// GetLatestTickers retrieves the most recent tickers across all exchanges
func (c *MarketCache) GetLatestTickers(ctx context.Context) ([]*market.Ticker, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	if len(c.latestTickers) == 0 {
		return nil, false
	}

	tickers := make([]*market.Ticker, 0, len(c.latestTickers))
	for _, ticker := range c.latestTickers {
		tickers = append(tickers, ticker)
	}

	return tickers, true
}

// CacheCandle stores a candle in cache
func (c *MarketCache) CacheCandle(candle *market.Candle) {
	if candle == nil {
		return
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	key := c.getCandleKey(candle.Exchange, candle.Symbol, string(candle.Interval), candle.OpenTime)
	c.candles[key] = candle
	c.lastUpdated[key] = time.Now()

	// Update latest candle for this symbol and interval
	latestKey := c.getLatestCandleKey(candle.Exchange, candle.Symbol, string(candle.Interval))

	// Only update if this is a newer candle or there's no existing candle
	existingLatest, exists := c.latestCandles[latestKey]
	if !exists || candle.OpenTime.After(existingLatest.OpenTime) {
		c.latestCandles[latestKey] = candle
		c.logger.Debug().
			Str("exchange", candle.Symbol).
			Str("symbol", candle.Symbol).
			Str("interval", string(candle.Interval)).
			Time("openTime", candle.OpenTime).
			Msg("Latest candle cached")
	}
}

// GetCandle retrieves a candle from cache
func (c *MarketCache) GetCandle(ctx context.Context, exchange, symbol string, interval market.Interval, openTime time.Time) (*market.Candle, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := c.getCandleKey(exchange, symbol, string(interval), openTime)
	candle, exists := c.candles[key]
	if !exists {
		return nil, false
	}

	// Check if candle has expired
	lastUpdate, updated := c.lastUpdated[key]
	if !updated || time.Since(lastUpdate) > c.candleExpiry {
		c.logger.Debug().
			Str("exchange", exchange).
			Str("symbol", symbol).
			Str("interval", string(interval)).
			Time("openTime", openTime).
			Msg("Candle cache expired")
		return nil, false
	}

	return candle, true
}

// GetLatestCandle retrieves the most recent candle for a symbol and interval
func (c *MarketCache) GetLatestCandle(ctx context.Context, exchange, symbol string, interval market.Interval) (*market.Candle, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := c.getLatestCandleKey(exchange, symbol, string(interval))
	candle, exists := c.latestCandles[key]
	if !exists {
		return nil, false
	}

	// Check if candle has expired
	lastUpdate, updated := c.lastUpdated[key]
	if !updated || time.Since(lastUpdate) > c.candleExpiry {
		c.logger.Debug().
			Str("exchange", exchange).
			Str("symbol", symbol).
			Str("interval", string(interval)).
			Msg("Latest candle cache expired")
		return nil, false
	}

	return candle, true
}

// CacheOrderBook stores an orderbook in cache
func (c *MarketCache) CacheOrderBook(orderbook *market.OrderBook) {
	if orderbook == nil {
		return
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	key := c.getOrderBookKey(orderbook.Exchange, orderbook.Symbol)
	c.orderbooks[key] = orderbook
	c.lastUpdated[key] = time.Now()
	c.logger.Debug().
		Str("exchange", orderbook.Exchange).
		Str("symbol", orderbook.Symbol).
		Msg("OrderBook cached")
}

// GetOrderBook retrieves an orderbook from cache
func (c *MarketCache) GetOrderBook(ctx context.Context, exchange, symbol string) (*market.OrderBook, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := c.getOrderBookKey(exchange, symbol)
	orderbook, exists := c.orderbooks[key]
	if !exists {
		return nil, false
	}

	// Check if orderbook has expired
	lastUpdate, updated := c.lastUpdated[key]
	if !updated || time.Since(lastUpdate) > c.orderbookExpiry {
		c.logger.Debug().
			Str("exchange", exchange).
			Str("symbol", symbol).
			Msg("OrderBook cache expired")
		return nil, false
	}

	return orderbook, true
}

// Clear removes all cached data
func (c *MarketCache) Clear() {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.tickers = make(map[string]*market.Ticker)
	c.latestTickers = make(map[string]*market.Ticker)
	c.tickersByExchange = make(map[string][]*market.Ticker)
	c.candles = make(map[string]*market.Candle)
	c.latestCandles = make(map[string]*market.Candle)
	c.orderbooks = make(map[string]*market.OrderBook)
	c.lastUpdated = make(map[string]time.Time)
	c.logger.Debug().Msg("Cache cleared")
}

// Helper method to generate ticker cache keys
func (c *MarketCache) getTickerKey(exchange, symbol string) string {
	return exchange + ":" + symbol
}

// Helper method to generate candle cache keys
func (c *MarketCache) getCandleKey(exchange, symbol, interval string, openTime time.Time) string {
	return exchange + ":" + symbol + ":" + interval + ":" + openTime.Format(time.RFC3339)
}

// Helper method to generate latest candle cache keys
func (c *MarketCache) getLatestCandleKey(exchange, symbol, interval string) string {
	return "latest:" + exchange + ":" + symbol + ":" + interval
}

// Helper method to generate orderbook cache keys
func (c *MarketCache) getOrderBookKey(exchange, symbol string) string {
	return exchange + ":" + symbol
}

// StartCleanupTask starts a periodic task to clean up expired cache entries
func (c *MarketCache) StartCleanupTask(ctx context.Context, interval time.Duration) {
	go func() {
		ticker := time.NewTicker(interval)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				c.cleanupExpiredEntries()
			}
		}
	}()
}

// cleanupExpiredEntries removes expired entries from all caches
func (c *MarketCache) cleanupExpiredEntries() {
	c.mu.Lock()
	defer c.mu.Unlock()

	now := time.Now()

	// Clean up tickers
	for key, lastUpdate := range c.lastUpdated {
		if strings.HasPrefix(key, "exchange:") {
			// Skip exchange keys
			continue
		}

		// Determine which cache this key belongs to
		if strings.Count(key, ":") == 1 {
			// Ticker key: exchange:symbol
			if now.Sub(lastUpdate) > c.tickerExpiry {
				parts := strings.Split(key, ":")
				if len(parts) >= 2 {
					exchange, symbol := parts[0], parts[1]
					delete(c.tickers, key)

					// Also update the exchange tickers
					if exchangeTickers, ok := c.tickersByExchange[exchange]; ok {
						for i, ticker := range exchangeTickers {
							if ticker.Symbol == symbol {
								// Remove this ticker from the slice
								exchangeTickers = append(exchangeTickers[:i], exchangeTickers[i+1:]...)
								break
							}
						}
						if len(exchangeTickers) > 0 {
							c.tickersByExchange[exchange] = exchangeTickers
						} else {
							delete(c.tickersByExchange, exchange)
						}
					}

					// Also clean up from latestTickers if it's there
					if ticker, ok := c.latestTickers[symbol]; ok {
						if ticker.Exchange == exchange {
							delete(c.latestTickers, symbol)
						}
					}

					delete(c.lastUpdated, key)
					c.logger.Debug().Str("key", key).Msg("Expired ticker removed from cache")
				}
			}
		} else if strings.Count(key, ":") == 3 && !strings.HasPrefix(key, "latest:") {
			// Candle key: exchange:symbol:interval:timestamp
			if now.Sub(lastUpdate) > c.candleExpiry {
				delete(c.candles, key)
				delete(c.lastUpdated, key)
				c.logger.Debug().Str("key", key).Msg("Expired candle removed from cache")
			}
		}
	}

	// Clean up latest candles separately
	for key, lastUpdate := range c.lastUpdated {
		if strings.HasPrefix(key, "latest:") && now.Sub(lastUpdate) > c.candleExpiry {
			delete(c.latestCandles, key)
			delete(c.lastUpdated, key)
			c.logger.Debug().Str("key", key).Msg("Expired latest candle removed from cache")
		}
	}

	// Clean up orderbooks
	for key, lastUpdate := range c.lastUpdated {
		if strings.Count(key, ":") == 1 {
			// Could be either a ticker or orderbook, but we've already handled tickers
			if _, exists := c.tickers[key]; !exists {
				if now.Sub(lastUpdate) > c.orderbookExpiry {
					delete(c.orderbooks, key)
					delete(c.lastUpdated, key)
					c.logger.Debug().Str("key", key).Msg("Expired orderbook removed from cache")
				}
			}
		}
	}
}
</file>

<file path="internal/adapter/cache/memory/ticker_cache.go">
package memory

import (
	"context"
	"sync"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model/market"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog"
)

// TickerCache provides specialized caching for ticker data
type TickerCache struct {
	// Cache for tickers by symbol and exchange
	tickersCache map[string]port.Cache[market.Ticker]

	// Cache for latest tickers by symbol
	latestCache map[string]port.Cache[market.Ticker]

	// Cache for tickers by exchange
	exchangeCache map[string]port.Cache[[]*market.Ticker]

	// Mutex for thread safety
	mu sync.RWMutex

	// TTL for different caches
	tickerTTL   time.Duration
	latestTTL   time.Duration
	exchangeTTL time.Duration

	// Logger
	logger *zerolog.Logger
}

// NewTickerCache creates a new ticker cache with the specified TTLs
func NewTickerCache(logger *zerolog.Logger) *TickerCache {
	return &TickerCache{
		tickersCache:  make(map[string]port.Cache[market.Ticker]),
		latestCache:   make(map[string]port.Cache[market.Ticker]),
		exchangeCache: make(map[string]port.Cache[[]*market.Ticker]),
		tickerTTL:     5 * time.Minute,
		latestTTL:     5 * time.Minute,
		exchangeTTL:   5 * time.Minute,
		logger:        logger,
	}
}

// CacheTicker stores a ticker in cache
func (c *TickerCache) CacheTicker(ticker *market.Ticker) {
	if ticker == nil {
		return
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Create key for the ticker
	key := getTickerKey(ticker.Exchange, ticker.Symbol)

	// Get or create cache for this ticker
	cache, exists := c.tickersCache[key]
	if !exists {
		cache = NewGenericCache[market.Ticker](c.tickerTTL)
		c.tickersCache[key] = cache
	}

	// Cache the ticker
	cache.Set(ticker)
	c.logger.Debug().Str("exchange", ticker.Exchange).Str("symbol", ticker.Symbol).Msg("Ticker cached")

	// Also update the latest ticker for this symbol
	latestCache, exists := c.latestCache[ticker.Symbol]
	if !exists {
		latestCache = NewGenericCache[market.Ticker](c.latestTTL)
		c.latestCache[ticker.Symbol] = latestCache
	}
	latestCache.Set(ticker)

	// Update the exchange cache
	c.updateExchangeCache(ticker)
}

// GetTicker retrieves a ticker from cache
func (c *TickerCache) GetTicker(ctx context.Context, exchange, symbol string) (*market.Ticker, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	key := getTickerKey(exchange, symbol)
	cache, exists := c.tickersCache[key]
	if !exists {
		return nil, false
	}

	ticker, found := cache.Get()
	if !found {
		c.logger.Debug().Str("exchange", exchange).Str("symbol", symbol).Msg("Ticker not found in cache or expired")
		return nil, false
	}

	return ticker, true
}

// GetAllTickers retrieves all tickers for an exchange from cache
func (c *TickerCache) GetAllTickers(ctx context.Context, exchange string) ([]*market.Ticker, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	cache, exists := c.exchangeCache[exchange]
	if !exists {
		return nil, false
	}

	tickers, found := cache.Get()
	if !found || tickers == nil || len(*tickers) == 0 {
		c.logger.Debug().Str("exchange", exchange).Msg("Exchange tickers not found in cache or expired")
		return nil, false
	}

	return *tickers, true
}

// GetLatestTickers retrieves the most recent tickers across all exchanges
func (c *TickerCache) GetLatestTickers(ctx context.Context) ([]*market.Ticker, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	if len(c.latestCache) == 0 {
		return nil, false
	}

	tickers := make([]*market.Ticker, 0, len(c.latestCache))
	for symbol, cache := range c.latestCache {
		ticker, found := cache.Get()
		if found && ticker != nil {
			tickers = append(tickers, ticker)
		} else {
			c.logger.Debug().Str("symbol", symbol).Msg("Latest ticker not found or expired")
		}
	}

	if len(tickers) == 0 {
		return nil, false
	}

	return tickers, true
}

// updateExchangeCache updates the cache of tickers by exchange
func (c *TickerCache) updateExchangeCache(newTicker *market.Ticker) {
	// Get the existing cached tickers for this exchange
	cache, exists := c.exchangeCache[newTicker.Exchange]
	if !exists {
		cache = NewGenericCache[[]*market.Ticker](c.exchangeTTL)
		c.exchangeCache[newTicker.Exchange] = cache
	}

	// Get existing tickers or create a new slice
	var exchangeTickers []*market.Ticker
	existing, found := cache.Get()
	if found && existing != nil {
		exchangeTickers = *existing
	} else {
		exchangeTickers = make([]*market.Ticker, 0)
	}

	// Update or add the ticker in the slice
	updated := false
	for i, ticker := range exchangeTickers {
		if ticker.Symbol == newTicker.Symbol {
			exchangeTickers[i] = newTicker
			updated = true
			break
		}
	}

	if !updated {
		exchangeTickers = append(exchangeTickers, newTicker)
	}

	// Cache the updated slice
	cache.Set(&exchangeTickers)
}

// SetTickerTTL sets the TTL for individual ticker caches
func (c *TickerCache) SetTickerTTL(ttl time.Duration) {
	if ttl <= 0 {
		return
	}

	c.mu.Lock()
	defer c.mu.Unlock()
	c.tickerTTL = ttl

	// Update TTL for existing caches
	for _, cache := range c.tickersCache {
		cache.UpdateTTL(ttl)
	}
}

// SetLatestTTL sets the TTL for latest ticker caches
func (c *TickerCache) SetLatestTTL(ttl time.Duration) {
	if ttl <= 0 {
		return
	}

	c.mu.Lock()
	defer c.mu.Unlock()
	c.latestTTL = ttl

	// Update TTL for existing caches
	for _, cache := range c.latestCache {
		cache.UpdateTTL(ttl)
	}
}

// SetExchangeTTL sets the TTL for exchange ticker caches
func (c *TickerCache) SetExchangeTTL(ttl time.Duration) {
	if ttl <= 0 {
		return
	}

	c.mu.Lock()
	defer c.mu.Unlock()
	c.exchangeTTL = ttl

	// Update TTL for existing caches
	for _, cache := range c.exchangeCache {
		cache.UpdateTTL(ttl)
	}
}

// Clear removes all cached ticker data
func (c *TickerCache) Clear() {
	c.mu.Lock()
	defer c.mu.Unlock()

	// Invalidate all caches
	for _, cache := range c.tickersCache {
		cache.Invalidate()
	}
	for _, cache := range c.latestCache {
		cache.Invalidate()
	}
	for _, cache := range c.exchangeCache {
		cache.Invalidate()
	}

	// Reset maps
	c.tickersCache = make(map[string]port.Cache[market.Ticker])
	c.latestCache = make(map[string]port.Cache[market.Ticker])
	c.exchangeCache = make(map[string]port.Cache[[]*market.Ticker])

	c.logger.Debug().Msg("Ticker cache cleared")
}

// Helper function to generate ticker cache keys
func getTickerKey(exchange, symbol string) string {
	return exchange + ":" + symbol
}
</file>

<file path="internal/adapter/delivery/http/router.go">
package http

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/neo/crypto-bot/internal/apperror"
	"github.com/rs/zerolog"
)

// SetupRouter configures and returns the main HTTP router
func SetupRouter(logger zerolog.Logger) *gin.Engine {
	// Set Gin mode based on environment
	if gin.Mode() == gin.DebugMode {
		gin.SetMode(gin.DebugMode)
	} else {
		gin.SetMode(gin.ReleaseMode)
	}

	// Create a new router
	router := gin.New()

	// Add middleware
	router.Use(
		gin.Recovery(),
		corsMiddleware(),
		loggerMiddleware(logger),
		errorMiddleware(),
	)

	// Setup health check endpoint
	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status":    "ok",
			"timestamp": time.Now().Format(time.RFC3339),
		})
	})

	// Setup API routes
	// API group will be used by handlers to register their routes
	_ = router.Group("/api/v1")

	// Add more route registrations here when handlers are implemented

	return router
}

// corsMiddleware sets up CORS headers
func corsMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")
		c.Writer.Header().Set("Access-Control-Max-Age", "86400")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(http.StatusNoContent)
			return
		}

		c.Next()
	}
}

// loggerMiddleware sets up request logging
func loggerMiddleware(logger zerolog.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		raw := c.Request.URL.RawQuery

		// Process request
		c.Next()

		// Log information after request is processed
		end := time.Now()
		latency := end.Sub(start)

		if raw != "" {
			path = path + "?" + raw
		}

		status := c.Writer.Status()
		method := c.Request.Method
		ip := c.ClientIP()
		userAgent := c.Request.UserAgent()

		logEvent := logger.Info()
		if status >= 400 {
			logEvent = logger.Error()
		}

		logEvent.
			Str("method", method).
			Str("path", path).
			Int("status", status).
			Dur("latency", latency).
			Str("ip", ip).
			Str("user_agent", userAgent).
			Msg("HTTP Request")
	}
}

// errorMiddleware handles and standardizes error responses
func errorMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Next()

		// Check if there are any errors
		if len(c.Errors) > 0 {
			err := c.Errors.Last().Err

			// Check if it's an AppError
			var appErr *apperror.AppError
			if apperror.As(err, &appErr) {
				c.JSON(appErr.StatusCode, appErr.ToResponse())
				return
			}

			// If not an AppError, return a generic 500 error
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": gin.H{
					"code":    "INTERNAL_ERROR",
					"message": "An internal server error occurred",
				},
			})
		}
	}
}
</file>

<file path="internal/adapter/gateway/ai/gemini.go">
package ai

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/google/generative-ai-go/genai"
	"github.com/google/uuid"
	"github.com/neo/crypto-bot/internal/config"
	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/rs/zerolog"
	"google.golang.org/api/option"
)

// GeminiAIService implements the AIService interface using Google's Gemini API
type GeminiAIService struct {
	client      *genai.Client
	model       *genai.GenerativeModel
	chatModel   *genai.GenerativeModel
	config      *config.Config
	logger      zerolog.Logger
	functionReg map[string]FunctionHandler
}

// FunctionHandler is a function that handles a function call
type FunctionHandler func(ctx context.Context, params map[string]interface{}) (interface{}, error)

// NewGeminiAIService creates a new GeminiAIService
func NewGeminiAIService(cfg *config.Config, logger zerolog.Logger) (*GeminiAIService, error) {
	if cfg.AI.GeminiAPIKey == "" {
		return nil, errors.New("Gemini API key is required")
	}

	// Create a new Gemini client
	client, err := genai.NewClient(context.Background(), option.WithAPIKey(cfg.AI.GeminiAPIKey))
	if err != nil {
		return nil, fmt.Errorf("failed to create Gemini client: %w", err)
	}

	// Get the Gemini model
	model := client.GenerativeModel(cfg.AI.GeminiModel)

	// Configure safety settings
	model.SafetySettings = []*genai.SafetySetting{
		{
			Category:  genai.HarmCategoryHarassment,
			Threshold: genai.HarmBlockMediumAndAbove,
		},
		{
			Category:  genai.HarmCategoryHateSpeech,
			Threshold: genai.HarmBlockMediumAndAbove,
		},
		{
			Category:  genai.HarmCategorySexuallyExplicit,
			Threshold: genai.HarmBlockMediumAndAbove,
		},
		{
			Category:  genai.HarmCategoryDangerous,
			Threshold: genai.HarmBlockMediumAndAbove,
		},
	}

	// Configure generation settings
	temperature := float32(0.7)
	topP := float32(0.95)
	topK := int32(40)
	maxTokens := int32(1024)

	// Use config values if available
	if cfg.AI.Temperature > 0 {
		temperature = cfg.AI.Temperature
	}
	if cfg.AI.TopP > 0 {
		topP = cfg.AI.TopP
	}
	if cfg.AI.TopK > 0 {
		topK = cfg.AI.TopK
	}
	if cfg.AI.MaxTokens > 0 {
		maxTokens = cfg.AI.MaxTokens
	}

	// Set generation config
	model.SetTemperature(temperature)
	model.SetTopP(topP)
	model.SetTopK(topK)
	model.SetMaxOutputTokens(maxTokens)

	// Create a copy of the model for chat
	chatModel := client.GenerativeModel(cfg.AI.GeminiModel)
	chatModel.SafetySettings = model.SafetySettings
	chatModel.GenerationConfig = model.GenerationConfig

	service := &GeminiAIService{
		client:      client,
		model:       model,
		chatModel:   chatModel,
		config:      cfg,
		logger:      logger.With().Str("component", "gemini_ai_service").Logger(),
		functionReg: make(map[string]FunctionHandler),
	}

	// Register default functions
	service.registerDefaultFunctions()

	return service, nil
}

// Chat sends a message to the AI and returns a response
func (s *GeminiAIService) Chat(ctx context.Context, message string, conversationID string) (*model.AIMessage, error) {
	// Create a new chat session
	chat := s.chatModel.StartChat()

	// Add system prompt
	chat.History = []*genai.Content{
		{
			Role:  "user",
			Parts: []genai.Part{genai.Text(s.config.AI.SystemPrompt)},
		},
		{
			Role:  "model",
			Parts: []genai.Part{genai.Text("I understand my role as a crypto trading assistant. I'll help you with market analysis, portfolio insights, and trading recommendations. How can I assist you today?")},
		},
	}

	// Send the message
	resp, err := chat.SendMessage(ctx, genai.Text(message))
	if err != nil {
		s.logger.Error().Err(err).Str("message", message).Msg("Failed to send message to Gemini")
		return nil, fmt.Errorf("failed to send message to Gemini: %w", err)
	}

	// Create the response message
	responseText := ""
	for _, part := range resp.Candidates[0].Content.Parts {
		if text, ok := part.(genai.Text); ok {
			responseText += string(text)
		}
	}

	aiMessage := &model.AIMessage{
		ID:             uuid.New().String(),
		ConversationID: conversationID,
		Role:           "assistant",
		Content:        responseText,
		Timestamp:      time.Now(),
		Metadata: map[string]interface{}{
			"model": s.config.AI.GeminiModel,
		},
	}

	return aiMessage, nil
}

// ChatWithHistory sends a message with conversation history to the AI
func (s *GeminiAIService) ChatWithHistory(ctx context.Context, messages []model.AIMessage) (*model.AIMessage, error) {
	// Create a new chat session
	chat := s.chatModel.StartChat()

	// Add system prompt
	chat.History = []*genai.Content{
		{
			Role:  "user",
			Parts: []genai.Part{genai.Text(s.config.AI.SystemPrompt)},
		},
		{
			Role:  "model",
			Parts: []genai.Part{genai.Text("I understand my role as a crypto trading assistant. I'll help you with market analysis, portfolio insights, and trading recommendations. How can I assist you today?")},
		},
	}

	// Add conversation history
	for _, msg := range messages {
		role := "user"
		if msg.Role == "assistant" {
			role = "model"
		}

		chat.History = append(chat.History, &genai.Content{
			Role:  role,
			Parts: []genai.Part{genai.Text(msg.Content)},
		})
	}

	// Get the last user message
	var lastUserMessage string
	for i := len(messages) - 1; i >= 0; i-- {
		if messages[i].Role == "user" {
			lastUserMessage = messages[i].Content
			break
		}
	}

	// Send the message
	resp, err := chat.SendMessage(ctx, genai.Text(lastUserMessage))
	if err != nil {
		s.logger.Error().Err(err).Str("message", lastUserMessage).Msg("Failed to send message to Gemini")
		return nil, fmt.Errorf("failed to send message to Gemini: %w", err)
	}

	// Create the response message
	responseText := ""
	for _, part := range resp.Candidates[0].Content.Parts {
		if text, ok := part.(genai.Text); ok {
			responseText += string(text)
		}
	}

	conversationID := ""
	if len(messages) > 0 {
		conversationID = messages[0].ConversationID
	}

	aiMessage := &model.AIMessage{
		ID:             uuid.New().String(),
		ConversationID: conversationID,
		Role:           "assistant",
		Content:        responseText,
		Timestamp:      time.Now(),
		Metadata: map[string]interface{}{
			"model": s.config.AI.GeminiModel,
		},
	}

	return aiMessage, nil
}

// GenerateInsight generates an insight based on provided data
func (s *GeminiAIService) GenerateInsight(ctx context.Context, insightType string, data map[string]interface{}) (*model.AIInsight, error) {
	// Convert data to JSON string
	dataJSON, err := json.Marshal(data)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal data: %w", err)
	}

	// Create prompt based on insight type
	prompt := fmt.Sprintf("Generate a %s insight based on the following data:\n%s\n\nProvide a concise title and detailed description. Focus on actionable insights.", insightType, string(dataJSON))

	// Send prompt to model
	resp, err := s.model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		s.logger.Error().Err(err).Str("insightType", insightType).Msg("Failed to generate insight")
		return nil, fmt.Errorf("failed to generate insight: %w", err)
	}

	// Parse response
	responseText := ""
	for _, part := range resp.Candidates[0].Content.Parts {
		if text, ok := part.(genai.Text); ok {
			responseText += string(text)
		}
	}

	// Extract title and description
	lines := splitLines(responseText)
	title := ""
	description := ""

	if len(lines) > 0 {
		title = lines[0]
		if len(lines) > 1 {
			description = joinLines(lines[1:])
		}
	}

	// Create insight
	insight := &model.AIInsight{
		ID:          uuid.New().String(),
		UserID:      data["user_id"].(string),
		Type:        insightType,
		Title:       title,
		Description: description,
		CreatedAt:   time.Now(),
		Confidence:  0.85, // Default confidence
		Metadata: map[string]interface{}{
			"model": s.config.AI.GeminiModel,
			"data":  data,
		},
	}

	return insight, nil
}

// GenerateTradeRecommendation generates a trade recommendation
func (s *GeminiAIService) GenerateTradeRecommendation(ctx context.Context, data map[string]interface{}) (*model.AITradeRecommendation, error) {
	// Convert data to JSON string
	dataJSON, err := json.Marshal(data)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal data: %w", err)
	}

	// Create prompt
	prompt := fmt.Sprintf("Based on the following market and portfolio data, generate a trade recommendation:\n%s\n\nProvide the symbol, action (buy/sell), quantity, and detailed reasoning.", string(dataJSON))

	// Send prompt to model
	resp, err := s.model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		s.logger.Error().Err(err).Msg("Failed to generate trade recommendation")
		return nil, fmt.Errorf("failed to generate trade recommendation: %w", err)
	}

	// Parse response
	responseText := ""
	for _, part := range resp.Candidates[0].Content.Parts {
		if text, ok := part.(genai.Text); ok {
			responseText += string(text)
		}
	}

	// Parse the recommendation (simplified parsing)
	lines := splitLines(responseText)
	symbol := ""
	action := ""
	quantity := 0.0
	reasoning := ""

	for _, line := range lines {
		if len(line) == 0 {
			continue
		}

		if symbol == "" && (containsAny(line, "Symbol:", "Ticker:", "Asset:")) {
			symbol = extractValue(line)
		} else if action == "" && (containsAny(line, "Action:", "Recommendation:", "Trade:")) {
			action = extractValue(line)
			// Normalize action
			if containsAny(action, "buy", "long", "purchase") {
				action = "buy"
			} else if containsAny(action, "sell", "short", "exit") {
				action = "sell"
			}
		} else if quantity == 0.0 && (containsAny(line, "Quantity:", "Amount:", "Size:")) {
			quantity = parseFloat(extractValue(line))
		} else if reasoning == "" && (containsAny(line, "Reasoning:", "Rationale:", "Reason:")) {
			reasoning = extractValue(line)
		} else if reasoning != "" {
			reasoning += "\n" + line
		}
	}

	// If we couldn't parse the recommendation, use default values
	if symbol == "" || action == "" || quantity == 0.0 {
		s.logger.Warn().Str("response", responseText).Msg("Failed to parse trade recommendation")

		// Set default values
		if symbol == "" {
			symbol = "BTC/USDT"
		}
		if action == "" {
			action = "buy"
		}
		if quantity == 0.0 {
			quantity = 0.01
		}
		if reasoning == "" {
			reasoning = responseText
		}
	}

	// Create recommendation
	recommendation := &model.AITradeRecommendation{
		ID:         uuid.New().String(),
		UserID:     data["user_id"].(string),
		Symbol:     symbol,
		Action:     action,
		Quantity:   quantity,
		Reasoning:  reasoning,
		CreatedAt:  time.Now(),
		ExpiresAt:  time.Now().Add(24 * time.Hour),
		Confidence: 0.75, // Default confidence
		Status:     "pending",
	}

	return recommendation, nil
}

// ExecuteFunction executes a function call from the AI
func (s *GeminiAIService) ExecuteFunction(ctx context.Context, functionCall model.AIFunctionCall) (*model.AIFunctionResponse, error) {
	// Check if function exists
	handler, exists := s.functionReg[functionCall.Name]
	if !exists {
		return nil, fmt.Errorf("function %s not found", functionCall.Name)
	}

	// Execute function
	result, err := handler(ctx, functionCall.Parameters)
	if err != nil {
		s.logger.Error().Err(err).Str("function", functionCall.Name).Msg("Failed to execute function")
		return nil, fmt.Errorf("failed to execute function %s: %w", functionCall.Name, err)
	}

	// Create response
	response := &model.AIFunctionResponse{
		Name:   functionCall.Name,
		Result: result,
	}

	return response, nil
}

// GenerateEmbedding generates a vector embedding for a text
func (s *GeminiAIService) GenerateEmbedding(ctx context.Context, text string) (*model.AIEmbedding, error) {
	// Note: As of now, Gemini doesn't have a dedicated embedding API
	// This is a placeholder implementation
	// In a real implementation, you might use a different model or service for embeddings

	// For now, return a mock embedding
	embedding := &model.AIEmbedding{
		ID:         uuid.New().String(),
		SourceID:   uuid.New().String(),
		SourceType: "message",
		Vector:     make([]float64, 128), // Mock 128-dimensional vector
		CreatedAt:  time.Now(),
	}

	s.logger.Warn().Msg("Using mock embedding implementation")

	return embedding, nil
}

// RegisterFunction registers a function handler
func (s *GeminiAIService) RegisterFunction(name string, handler FunctionHandler) {
	s.functionReg[name] = handler
}

// registerDefaultFunctions registers default function handlers
func (s *GeminiAIService) registerDefaultFunctions() {
	// Register get_market_data function
	s.RegisterFunction("get_market_data", func(ctx context.Context, params map[string]interface{}) (interface{}, error) {
		symbol, ok := params["symbol"].(string)
		if !ok {
			return nil, errors.New("symbol parameter is required")
		}

		// Mock implementation
		return map[string]interface{}{
			"symbol":     symbol,
			"price":      42000.0,
			"change_24h": 2.5,
			"volume_24h": 1000000.0,
		}, nil
	})

	// Register get_portfolio function
	s.RegisterFunction("get_portfolio", func(ctx context.Context, params map[string]interface{}) (interface{}, error) {
		// Mock implementation
		return map[string]interface{}{
			"total_value": 12345.67,
			"assets": []map[string]interface{}{
				{
					"symbol":   "BTC",
					"quantity": 0.5,
					"value":    21000.0,
				},
				{
					"symbol":   "ETH",
					"quantity": 5.0,
					"value":    10000.0,
				},
			},
		}, nil
	})
}

// Helper functions

// splitLines splits a string into lines
func splitLines(s string) []string {
	var lines []string
	var line string
	for _, r := range s {
		if r == '\n' {
			lines = append(lines, line)
			line = ""
		} else {
			line += string(r)
		}
	}
	if line != "" {
		lines = append(lines, line)
	}
	return lines
}

// joinLines joins lines into a string
func joinLines(lines []string) string {
	result := ""
	for i, line := range lines {
		if i > 0 {
			result += "\n"
		}
		result += line
	}
	return result
}

// containsAny checks if a string contains any of the given substrings
func containsAny(s string, substrings ...string) bool {
	for _, substring := range substrings {
		if contains(s, substring) {
			return true
		}
	}
	return false
}

// contains checks if a string contains a substring (case-insensitive)
func contains(s, substring string) bool {
	s = strings.ToLower(s)
	substring = strings.ToLower(substring)
	return strings.Contains(s, substring)
}

// extractValue extracts a value from a line like "Key: Value"
func extractValue(line string) string {
	parts := strings.SplitN(line, ":", 2)
	if len(parts) < 2 {
		return line
	}
	return strings.TrimSpace(parts[1])
}

// parseFloat parses a float from a string
func parseFloat(s string) float64 {
	// Remove any non-numeric characters except for decimal point
	s = regexp.MustCompile(`[^\d.]`).ReplaceAllString(s, "")

	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return 0.0
	}
	return f
}
</file>

<file path="internal/adapter/http/handler/ai_handler.go">
package handler

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/neo/crypto-bot/internal/usecase"
	"github.com/rs/zerolog"
)

// AIHandler handles AI-related HTTP requests
type AIHandler struct {
	aiUsecase *usecase.AIUsecase
	logger    zerolog.Logger
}

// NewAIHandler creates a new AIHandler
func NewAIHandler(aiUsecase *usecase.AIUsecase, logger zerolog.Logger) *AIHandler {
	return &AIHandler{
		aiUsecase: aiUsecase,
		logger:    logger.With().Str("component", "ai_handler").Logger(),
	}
}

// ChatRequest represents a request to the chat endpoint
type ChatRequest struct {
	Message        string `json:"message"`
	ConversationID string `json:"conversation_id,omitempty"`
}

// ChatResponse represents a response from the chat endpoint
type ChatResponse struct {
	Message        model.AIMessage `json:"message"`
	ConversationID string          `json:"conversation_id"`
}

// HandleChat handles chat requests
func (h *AIHandler) HandleChat(c *gin.Context) {
	// Parse request
	var req ChatRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
		return
	}

	// Validate request
	if req.Message == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Message is required"})
		return
	}

	// Get user ID from context (set by auth middleware)
	userID := getUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Send message to AI
	response, err := h.aiUsecase.Chat(c.Request.Context(), userID, req.Message, req.ConversationID)
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to get AI response")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get AI response"})
		return
	}

	// Return response
	c.JSON(http.StatusOK, ChatResponse{
		Message:        *response,
		ConversationID: response.ConversationID,
	})
}

// ListConversationsResponse represents a response from the list conversations endpoint
type ListConversationsResponse struct {
	Conversations []*model.AIConversation `json:"conversations"`
	Total         int                     `json:"total"`
}

// HandleListConversations handles list conversations requests
func (h *AIHandler) HandleListConversations(c *gin.Context) {
	// Get user ID from context (set by auth middleware)
	userID := getUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Parse pagination parameters
	limit, offset := getPaginationParams(c)

	// Get conversations
	conversations, err := h.aiUsecase.ListConversations(c.Request.Context(), userID, limit, offset)
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to list conversations")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list conversations"})
		return
	}

	// Return response
	c.JSON(http.StatusOK, ListConversationsResponse{
		Conversations: conversations,
		Total:         len(conversations), // This is not accurate for pagination, but we don't have a count method
	})
}

// HandleGetConversation handles get conversation requests
func (h *AIHandler) HandleGetConversation(c *gin.Context) {
	// Get user ID from context (set by auth middleware)
	userID := getUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Get conversation ID from path
	conversationID := c.Param("id")
	if conversationID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Conversation ID is required"})
		return
	}

	// Get conversation
	conversation, err := h.aiUsecase.GetConversation(c.Request.Context(), userID, conversationID)
	if err != nil {
		h.logger.Error().Err(err).Str("conversation_id", conversationID).Msg("Failed to get conversation")
		c.JSON(http.StatusNotFound, gin.H{"error": "Conversation not found"})
		return
	}

	// Return response
	c.JSON(http.StatusOK, conversation)
}

// HandleDeleteConversation handles delete conversation requests
func (h *AIHandler) HandleDeleteConversation(c *gin.Context) {
	// Get user ID from context (set by auth middleware)
	userID := getUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Get conversation ID from path
	conversationID := c.Param("id")
	if conversationID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Conversation ID is required"})
		return
	}

	// Delete conversation
	err := h.aiUsecase.DeleteConversation(c.Request.Context(), userID, conversationID)
	if err != nil {
		h.logger.Error().Err(err).Str("conversation_id", conversationID).Msg("Failed to delete conversation")
		c.JSON(http.StatusNotFound, gin.H{"error": "Conversation not found"})
		return
	}

	// Return response
	c.JSON(http.StatusOK, gin.H{"message": "Conversation deleted"})
}

// InsightRequest represents a request to the insight endpoint
type InsightRequest struct {
	InsightType string                 `json:"insight_type"`
	Data        map[string]interface{} `json:"data"`
}

// HandleGenerateInsight handles generate insight requests
func (h *AIHandler) HandleGenerateInsight(c *gin.Context) {
	// Parse request
	var req InsightRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
		return
	}

	// Validate request
	if req.InsightType == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Insight type is required"})
		return
	}

	// Get user ID from context (set by auth middleware)
	userID := getUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Generate insight
	insight, err := h.aiUsecase.GenerateInsight(c.Request.Context(), userID, req.InsightType, req.Data)
	if err != nil {
		h.logger.Error().Err(err).Str("insight_type", req.InsightType).Msg("Failed to generate insight")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate insight"})
		return
	}

	// Return response
	c.JSON(http.StatusOK, insight)
}

// TradeRecommendationRequest represents a request to the trade recommendation endpoint
type TradeRecommendationRequest struct {
	Data map[string]interface{} `json:"data"`
}

// HandleGenerateTradeRecommendation handles generate trade recommendation requests
func (h *AIHandler) HandleGenerateTradeRecommendation(c *gin.Context) {
	// Parse request
	var req TradeRecommendationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
		return
	}

	// Get user ID from context (set by auth middleware)
	userID := getUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Generate trade recommendation
	recommendation, err := h.aiUsecase.GenerateTradeRecommendation(c.Request.Context(), userID, req.Data)
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to generate trade recommendation")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate trade recommendation"})
		return
	}

	// Return response
	c.JSON(http.StatusOK, recommendation)
}

// FunctionCallRequest represents a request to the function call endpoint
type FunctionCallRequest struct {
	Name       string                 `json:"name"`
	Parameters map[string]interface{} `json:"parameters"`
}

// HandleExecuteFunction handles execute function requests
func (h *AIHandler) HandleExecuteFunction(c *gin.Context) {
	// Parse request
	var req FunctionCallRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
		return
	}

	// Validate request
	if req.Name == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Function name is required"})
		return
	}

	// Create function call
	functionCall := model.AIFunctionCall{
		Name:       req.Name,
		Parameters: req.Parameters,
	}

	// Execute function
	response, err := h.aiUsecase.ExecuteFunction(c.Request.Context(), functionCall)
	if err != nil {
		h.logger.Error().Err(err).Str("function", req.Name).Msg("Failed to execute function")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to execute function"})
		return
	}

	// Return response
	c.JSON(http.StatusOK, response)
}

// RegisterRoutes registers the AI handler routes
func (h *AIHandler) RegisterRoutes(router *gin.Engine, authMiddleware gin.HandlerFunc) {
	aiGroup := router.Group("/api/v1/ai")
	aiGroup.Use(authMiddleware)
	{
		aiGroup.POST("/chat", h.HandleChat)
		aiGroup.GET("/conversations", h.HandleListConversations)
		aiGroup.GET("/conversations/:id", h.HandleGetConversation)
		aiGroup.DELETE("/conversations/:id", h.HandleDeleteConversation)
		aiGroup.POST("/insights", h.HandleGenerateInsight)
		aiGroup.POST("/recommendations", h.HandleGenerateTradeRecommendation)
		aiGroup.POST("/functions", h.HandleExecuteFunction)
	}
}

// Helper functions

// getUserID gets the user ID from the context
func getUserID(c *gin.Context) string {
	// In a real implementation, this would get the user ID from the JWT token
	// For now, we'll use a dummy user ID
	return "user123"
}

// getPaginationParams gets pagination parameters from the request
func getPaginationParams(c *gin.Context) (int, int) {
	limitStr := c.DefaultQuery("limit", "10")
	offsetStr := c.DefaultQuery("offset", "0")

	limit, err := strconv.Atoi(limitStr)
	if err != nil || limit < 1 {
		limit = 10
	}

	offset, err := strconv.Atoi(offsetStr)
	if err != nil || offset < 0 {
		offset = 0
	}

	return limit, offset
}
</file>

<file path="internal/adapter/http/handler/market_data.go">
package handler

import (
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/neo/crypto-bot/internal/domain/model/market"
	"github.com/neo/crypto-bot/internal/usecase"
	"github.com/rs/zerolog"
)

// MarketDataHandler handles HTTP requests for market data
type MarketDataHandler struct {
	useCase *usecase.MarketDataUseCase
	logger  *zerolog.Logger
}

// NewMarketDataHandler creates a new MarketDataHandler
func NewMarketDataHandler(uc *usecase.MarketDataUseCase, logger *zerolog.Logger) *MarketDataHandler {
	return &MarketDataHandler{
		useCase: uc,
		logger:  logger,
	}
}

// RegisterRoutes registers market data routes with the Gin engine
func (h *MarketDataHandler) RegisterRoutes(router *gin.RouterGroup) {
	marketGroup := router.Group("/market")
	{
		marketGroup.GET("/tickers", h.GetLatestTickers)
		marketGroup.GET("/tickers/:exchange/:symbol", h.GetTicker)
		marketGroup.GET("/candles", h.GetCandles)
		marketGroup.GET("/symbols", h.GetAllSymbols)
		marketGroup.GET("/symbols/:symbol", h.GetSymbolInfo)
	}
}

// GetLatestTickers godoc
// @Summary Get latest tickers
// @Description Get the latest tickers for all available symbols
// @Tags market
// @Accept json
// @Produce json
// @Success 200 {array} market.Ticker
// @Failure 500 {object} ErrorResponse
// @Router /market/tickers [get]
func (h *MarketDataHandler) GetLatestTickers(c *gin.Context) {
	tickers, err := h.useCase.GetLatestTickers(c.Request.Context())
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to get latest tickers")
		c.JSON(http.StatusInternalServerError, ErrorResponse{Message: "Failed to retrieve latest tickers"})
		return
	}
	c.JSON(http.StatusOK, tickers)
}

// GetTicker godoc
// @Summary Get specific ticker
// @Description Get the latest ticker for a specific exchange and symbol
// @Tags market
// @Accept json
// @Produce json
// @Param exchange path string true "Exchange name (e.g., binance)"
// @Param symbol path string true "Trading symbol (e.g., BTCUSDT)"
// @Success 200 {object} market.Ticker
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /market/tickers/{exchange}/{symbol} [get]
func (h *MarketDataHandler) GetTicker(c *gin.Context) {
	exchange := c.Param("exchange")
	symbol := c.Param("symbol")

	if exchange == "" || symbol == "" {
		c.JSON(http.StatusBadRequest, ErrorResponse{Message: "Exchange and symbol parameters are required"})
		return
	}

	ticker, err := h.useCase.GetTicker(c.Request.Context(), exchange, symbol)
	if err != nil {
		h.logger.Error().Err(err).Str("exchange", exchange).Str("symbol", symbol).Msg("Failed to get ticker")
		// TODO: Differentiate between Not Found and other errors
		c.JSON(http.StatusInternalServerError, ErrorResponse{Message: "Failed to retrieve ticker"})
		return
	}

	if ticker == nil {
		c.JSON(http.StatusNotFound, ErrorResponse{Message: "Ticker not found"})
		return
	}

	c.JSON(http.StatusOK, ticker)
}

// GetCandles godoc
// @Summary Get candles (k-lines)
// @Description Get historical candles for a specific exchange, symbol, and interval
// @Tags market
// @Accept json
// @Produce json
// @Param exchange query string true "Exchange name (e.g., binance)"
// @Param symbol query string true "Trading symbol (e.g., BTCUSDT)"
// @Param interval query string true "Candle interval (e.g., 1m, 5m, 1h, 1d)"
// @Param start query integer false "Start timestamp (Unix milliseconds)"
// @Param end query integer false "End timestamp (Unix milliseconds)"
// @Param limit query integer false "Limit number of candles (default: 500, max: 1000)"
// @Success 200 {array} market.Candle
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /market/candles [get]
func (h *MarketDataHandler) GetCandles(c *gin.Context) {
	exchange := c.Query("exchange")
	symbol := c.Query("symbol")
	intervalStr := c.Query("interval")

	if exchange == "" || symbol == "" || intervalStr == "" {
		c.JSON(http.StatusBadRequest, ErrorResponse{Message: "exchange, symbol, and interval parameters are required"})
		return
	}

	interval := market.Interval(intervalStr)
	// TODO: Validate interval string

	// Default time range: last 24 hours
	endTime := time.Now()
	startTime := endTime.Add(-24 * time.Hour)

	if startStr := c.Query("start"); startStr != "" {
		startMillis, err := strconv.ParseInt(startStr, 10, 64)
		if err != nil {
			c.JSON(http.StatusBadRequest, ErrorResponse{Message: "Invalid start timestamp"})
			return
		}
		startTime = time.UnixMilli(startMillis)
	}

	if endStr := c.Query("end"); endStr != "" {
		endMillis, err := strconv.ParseInt(endStr, 10, 64)
		if err != nil {
			c.JSON(http.StatusBadRequest, ErrorResponse{Message: "Invalid end timestamp"})
			return
		}
		endTime = time.UnixMilli(endMillis)
	}

	limit := 500 // Default limit
	if limitStr := c.Query("limit"); limitStr != "" {
		parsedLimit, err := strconv.Atoi(limitStr)
		if err != nil || parsedLimit <= 0 {
			c.JSON(http.StatusBadRequest, ErrorResponse{Message: "Invalid limit parameter"})
			return
		}
		if parsedLimit > 1000 { // Max limit
			parsedLimit = 1000
		}
		limit = parsedLimit
	}

	candles, err := h.useCase.GetCandles(c.Request.Context(), exchange, symbol, interval, startTime, endTime, limit)
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to get candles")
		c.JSON(http.StatusInternalServerError, ErrorResponse{Message: "Failed to retrieve candles"})
		return
	}

	c.JSON(http.StatusOK, candles)
}

// GetAllSymbols godoc
// @Summary Get all symbols
// @Description Get a list of all available trading symbols
// @Tags market
// @Accept json
// @Produce json
// @Success 200 {array} market.Symbol
// @Failure 500 {object} ErrorResponse
// @Router /market/symbols [get]
func (h *MarketDataHandler) GetAllSymbols(c *gin.Context) {
	symbols, err := h.useCase.GetAllSymbols(c.Request.Context())
	if err != nil {
		h.logger.Error().Err(err).Msg("Failed to get all symbols")
		c.JSON(http.StatusInternalServerError, ErrorResponse{Message: "Failed to retrieve symbols"})
		return
	}
	c.JSON(http.StatusOK, symbols)
}

// GetSymbolInfo godoc
// @Summary Get symbol info
// @Description Get detailed information for a specific trading symbol
// @Tags market
// @Accept json
// @Produce json
// @Param symbol path string true "Trading symbol (e.g., BTCUSDT)"
// @Success 200 {object} market.Symbol
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /market/symbols/{symbol} [get]
func (h *MarketDataHandler) GetSymbolInfo(c *gin.Context) {
	symbol := c.Param("symbol")
	if symbol == "" {
		c.JSON(http.StatusBadRequest, ErrorResponse{Message: "Symbol parameter is required"})
		return
	}

	symbolInfo, err := h.useCase.GetSymbolInfo(c.Request.Context(), symbol)
	if err != nil {
		// TODO: Differentiate between Not Found and other errors
		h.logger.Error().Err(err).Str("symbol", symbol).Msg("Failed to get symbol info")
		c.JSON(http.StatusInternalServerError, ErrorResponse{Message: "Failed to retrieve symbol information"})
		return
	}

	if symbolInfo == nil { // Should be handled by use case/repo, but double check
		c.JSON(http.StatusNotFound, ErrorResponse{Message: "Symbol not found"})
		return
	}

	c.JSON(http.StatusOK, symbolInfo)
}

// ErrorResponse is a generic error response structure
type ErrorResponse struct {
	Message string `json:"message"`
}
</file>

<file path="internal/adapter/http/router.go">
package http

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/rs/zerolog"
)

// SetupRouter configures and returns the main HTTP router
func SetupRouter(logger zerolog.Logger) *gin.Engine {
	// Set Gin mode based on environment
	if gin.Mode() == gin.DebugMode {
		gin.SetMode(gin.DebugMode)
	} else {
		gin.SetMode(gin.ReleaseMode)
	}

	// Create a new router
	router := gin.New()

	// Add middleware
	router.Use(
		gin.Recovery(),
		corsMiddleware(),
		loggerMiddleware(logger),
	)

	// Setup health check endpoint
	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status":    "ok",
			"timestamp": time.Now().Format(time.RFC3339),
		})
	})

	// Setup API routes
	// API group will be used by handlers to register their routes
	_ = router.Group("/api/v1")

	return router
}

// corsMiddleware sets up CORS headers
func corsMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")
		c.Writer.Header().Set("Access-Control-Max-Age", "86400")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(http.StatusNoContent)
			return
		}

		c.Next()
	}
}

// loggerMiddleware sets up request logging
func loggerMiddleware(logger zerolog.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		raw := c.Request.URL.RawQuery

		// Process request
		c.Next()

		// Log information after request is processed
		end := time.Now()
		latency := end.Sub(start)

		if raw != "" {
			path = path + "?" + raw
		}

		status := c.Writer.Status()
		method := c.Request.Method
		ip := c.ClientIP()
		userAgent := c.Request.UserAgent()

		logEvent := logger.Info()
		if status >= 400 {
			logEvent = logger.Error()
		}

		logEvent.
			Str("method", method).
			Str("path", path).
			Int("status", status).
			Dur("latency", latency).
			Str("ip", ip).
			Str("user_agent", userAgent).
			Msg("HTTP Request")
	}
}
</file>

<file path="internal/adapter/persistence/gorm/db.go">
package gorm

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	"github.com/neo/crypto-bot/internal/config"
	"github.com/rs/zerolog"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	gormlogger "gorm.io/gorm/logger"
)

// NewDBConnection creates a new GORM database connection
func NewDBConnection(cfg *config.Config, logger zerolog.Logger) (*gorm.DB, error) {
	// Ensure the database directory exists
	dbDir := filepath.Dir(cfg.Database.Path)
	if err := os.MkdirAll(dbDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create database directory: %w", err)
	}

	// Configure GORM logger based on environment
	var logLevel gormlogger.LogLevel
	if cfg.ENV == "development" {
		logLevel = gormlogger.Info
	} else {
		logLevel = gormlogger.Error
	}

	// Create a log writer that uses our zerolog instance
	logWriter := log.New(zerolog.ConsoleWriter{Out: os.Stdout, NoColor: false}, "[GORM] ", log.LstdFlags)

	gormLogger := gormlogger.New(
		logWriter,
		gormlogger.Config{
			SlowThreshold:             2 * time.Second, // Threshold for slow SQL queries
			LogLevel:                  logLevel,
			IgnoreRecordNotFoundError: true,
			Colorful:                  true,
		},
	)

	// Connect to the database based on driver type
	var db *gorm.DB
	var err error

	switch cfg.Database.Driver {
	case "sqlite":
		// Connect to SQLite database
		db, err = gorm.Open(sqlite.Open(cfg.Database.Path), &gorm.Config{
			Logger: gormLogger,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to connect to SQLite database: %w", err)
		}
		logger.Info().Str("path", cfg.Database.Path).Msg("Connected to SQLite database")

	default:
		return nil, fmt.Errorf("unsupported database driver: %s", cfg.Database.Driver)
	}

	// Configure connection pool
	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to configure connection pool: %w", err)
	}

	// Set connection pool parameters - use sensible defaults for SQLite
	// SQLite only supports one writer at a time
	sqlDB.SetMaxIdleConns(1)
	sqlDB.SetMaxOpenConns(10) // Lower for SQLite
	sqlDB.SetConnMaxLifetime(time.Minute * 30)

	logger.Info().Msg("Database connection established successfully")
	return db, nil
}

// AutoMigrateModels performs automatic migration for the specified models
func AutoMigrateModels(db *gorm.DB, logger *zerolog.Logger) error {
	logger.Info().Msg("Starting database migrations...")

	// Define the list of entities to migrate
	entities := []interface{}{
		&WalletEntity{},
		&BalanceEntity{},
		&BalanceHistoryEntity{},
		&OrderEntity{},
		&PositionEntity{},
		&TickerEntity{},
		&CandleEntity{},
		&OrderBookEntity{},
		&OrderBookEntryEntity{},
		&SymbolEntity{},
	}

	// Run migrations
	for _, entity := range entities {
		if err := db.AutoMigrate(entity); err != nil {
			logger.Error().Err(err).Msgf("Failed to migrate: %T", entity)
			return err
		}
		logger.Debug().Msgf("Successfully migrated: %T", entity)
	}

	logger.Info().Msg("Database migrations completed successfully")
	return nil
}
</file>

<file path="internal/adapter/persistence/gorm/market_repository.go">
package gorm

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/neo/crypto-bot/internal/apperror"
	"github.com/neo/crypto-bot/internal/domain/model/market"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog"
	"gorm.io/gorm"
)

// Ensure MarketRepository implements the proper interfaces
var _ port.MarketRepository = (*MarketRepository)(nil)
var _ port.SymbolRepository = (*MarketRepository)(nil)

// TickerEntity is the GORM model for market ticker data
type TickerEntity struct {
	ID            string `gorm:"primaryKey"`
	Symbol        string `gorm:"index:idx_ticker_symbol"`
	Price         float64
	Volume        float64
	High24h       float64
	Low24h        float64
	PriceChange   float64
	PercentChange float64
	LastUpdated   time.Time `gorm:"index:idx_ticker_updated"`
	Exchange      string    `gorm:"index:idx_ticker_exchange"`
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

// TableName sets the table name for TickerEntity
func (TickerEntity) TableName() string {
	return "tickers"
}

// CandleEntity is the GORM model for candlestick data
type CandleEntity struct {
	ID          uint      `gorm:"primaryKey;autoIncrement"`
	Symbol      string    `gorm:"index:idx_candle_symbol"`
	Exchange    string    `gorm:"index:idx_candle_exchange"`
	Interval    string    `gorm:"index:idx_candle_interval"`
	OpenTime    time.Time `gorm:"index:idx_candle_opentime"`
	CloseTime   time.Time
	Open        float64
	High        float64
	Low         float64
	Close       float64
	Volume      float64
	QuoteVolume float64
	TradeCount  int64
	Complete    bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

// TableName sets the table name for CandleEntity
func (CandleEntity) TableName() string {
	return "candles"
}

// OrderBookEntryEntity is the GORM model for order book entries
type OrderBookEntryEntity struct {
	ID          uint   `gorm:"primaryKey;autoIncrement"`
	OrderBookID uint   `gorm:"index:idx_orderbook_entry"`
	Type        string `gorm:"index:idx_entry_type"` // "bid" or "ask"
	Price       float64
	Quantity    float64
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

// TableName sets the table name for OrderBookEntryEntity
func (OrderBookEntryEntity) TableName() string {
	return "orderbook_entries"
}

// OrderBookEntity is the GORM model for order book data
type OrderBookEntity struct {
	ID           uint      `gorm:"primaryKey;autoIncrement"`
	Symbol       string    `gorm:"index:idx_orderbook_symbol"`
	Exchange     string    `gorm:"index:idx_orderbook_exchange"`
	LastUpdated  time.Time `gorm:"index:idx_orderbook_updated"`
	SequenceNum  int64
	LastUpdateID int64
	Entries      []OrderBookEntryEntity `gorm:"foreignKey:OrderBookID"`
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

// TableName sets the table name for OrderBookEntity
func (OrderBookEntity) TableName() string {
	return "orderbooks"
}

// SymbolEntity is the GORM model for trading pair information
type SymbolEntity struct {
	Symbol            string `gorm:"primaryKey"`
	BaseAsset         string
	QuoteAsset        string
	Exchange          string `gorm:"index:idx_symbol_exchange"`
	Status            string
	MinPrice          float64
	MaxPrice          float64
	PricePrecision    int
	MinQty            float64
	MaxQty            float64
	QtyPrecision      int
	AllowedOrderTypes string
	CreatedAt         time.Time
	UpdatedAt         time.Time
}

// TableName sets the table name for SymbolEntity
func (SymbolEntity) TableName() string {
	return "symbols"
}

// MarketRepository implements the port.MarketRepository interface using GORM
type MarketRepository struct {
	db     *gorm.DB
	logger *zerolog.Logger
}

// NewMarketRepository creates a new MarketRepository
func NewMarketRepository(db *gorm.DB, logger *zerolog.Logger) *MarketRepository {
	return &MarketRepository{
		db:     db,
		logger: logger,
	}
}

// SaveTicker stores a ticker in the database
func (r *MarketRepository) SaveTicker(ctx context.Context, ticker *market.Ticker) error {
	entity := r.tickerToEntity(ticker)

	result := r.db.WithContext(ctx).Save(&entity)
	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("symbol", ticker.Symbol).Msg("Failed to save ticker")
		return fmt.Errorf("failed to save ticker: %w", result.Error)
	}

	r.logger.Info().Str("symbol", ticker.Symbol).Str("exchange", ticker.Exchange).Msg("Ticker saved successfully")
	return nil
}

// GetTicker retrieves the latest ticker for a symbol from a specific exchange
func (r *MarketRepository) GetTicker(ctx context.Context, symbol, exchange string) (*market.Ticker, error) {
	var entity TickerEntity

	result := r.db.WithContext(ctx).
		Where("symbol = ? AND exchange = ?", symbol, exchange).
		Order("last_updated DESC").
		First(&entity)

	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			r.logger.Info().Str("symbol", symbol).Str("exchange", exchange).Msg("Ticker not found")
			return nil, apperror.ErrNotFound
		}
		r.logger.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to get ticker")
		return nil, fmt.Errorf("failed to get ticker: %w", result.Error)
	}

	return r.tickerToDomain(&entity), nil
}

// GetAllTickers retrieves all latest tickers from a specific exchange
func (r *MarketRepository) GetAllTickers(ctx context.Context, exchange string) ([]*market.Ticker, error) {
	var entities []TickerEntity

	// Using a subquery to get the latest ticker for each symbol
	subQuery := r.db.Model(&TickerEntity{}).
		Select("symbol, MAX(last_updated) as max_updated").
		Where("exchange = ?", exchange).
		Group("symbol").
		Table("sub")

	result := r.db.WithContext(ctx).
		Joins("JOIN (?) as sub ON tickers.symbol = sub.symbol AND tickers.last_updated = sub.max_updated", subQuery).
		Where("tickers.exchange = ?", exchange).
		Find(&entities)

	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("exchange", exchange).Msg("Failed to get all tickers")
		return nil, fmt.Errorf("failed to get all tickers: %w", result.Error)
	}

	tickers := make([]*market.Ticker, len(entities))
	for i, entity := range entities {
		tickers[i] = r.tickerToDomain(&entity)
	}

	return tickers, nil
}

// GetTickerHistory retrieves ticker history for a symbol within a time range
func (r *MarketRepository) GetTickerHistory(ctx context.Context, symbol, exchange string, start, end time.Time) ([]*market.Ticker, error) {
	var entities []TickerEntity

	result := r.db.WithContext(ctx).
		Where("symbol = ? AND exchange = ? AND last_updated BETWEEN ? AND ?",
			symbol, exchange, start, end).
		Order("last_updated ASC").
		Find(&entities)

	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to get ticker history")
		return nil, fmt.Errorf("failed to get ticker history: %w", result.Error)
	}

	tickers := make([]*market.Ticker, len(entities))
	for i, entity := range entities {
		tickers[i] = r.tickerToDomain(&entity)
	}

	return tickers, nil
}

// SaveCandle stores a candle in the database
func (r *MarketRepository) SaveCandle(ctx context.Context, candle *market.Candle) error {
	entity := r.candleToEntity(candle)

	// Try to find an existing candle with the same symbol, exchange, interval, and open time
	var existing CandleEntity
	result := r.db.WithContext(ctx).
		Where("symbol = ? AND exchange = ? AND interval = ? AND open_time = ?",
			candle.Symbol, candle.Exchange, candle.Interval, candle.OpenTime).
		First(&existing)

	// If the candle exists, update it; otherwise, create a new one
	if result.Error == nil {
		entity.ID = existing.ID
	}

	result = r.db.WithContext(ctx).Save(&entity)
	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("symbol", candle.Symbol).Msg("Failed to save candle")
		return fmt.Errorf("failed to save candle: %w", result.Error)
	}

	r.logger.Info().Str("symbol", candle.Symbol).Str("interval", string(candle.Interval)).Msg("Candle saved successfully")
	return nil
}

// SaveCandles stores multiple candles in the database
func (r *MarketRepository) SaveCandles(ctx context.Context, candles []*market.Candle) error {
	if len(candles) == 0 {
		return nil
	}

	entities := make([]CandleEntity, len(candles))
	for i, candle := range candles {
		entities[i] = r.candleToEntity(candle)
	}

	// Use a transaction to save all candles
	tx := r.db.WithContext(ctx).Begin()
	if tx.Error != nil {
		r.logger.Error().Err(tx.Error).Msg("Failed to begin transaction")
		return fmt.Errorf("failed to begin transaction: %w", tx.Error)
	}

	// Create or update each candle
	for i, entity := range entities {
		var existing CandleEntity
		result := tx.Where("symbol = ? AND exchange = ? AND interval = ? AND open_time = ?",
			entity.Symbol, entity.Exchange, entity.Interval, entity.OpenTime).
			First(&existing)

		if result.Error == nil {
			entity.ID = existing.ID
		}

		result = tx.Save(&entity)
		if result.Error != nil {
			tx.Rollback()
			r.logger.Error().Err(result.Error).Str("symbol", candles[i].Symbol).Msg("Failed to save candle in batch")
			return fmt.Errorf("failed to save candle in batch: %w", result.Error)
		}
	}

	if err := tx.Commit().Error; err != nil {
		r.logger.Error().Err(err).Msg("Failed to commit transaction")
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	r.logger.Info().Int("count", len(candles)).Msg("Successfully saved batch of candles")
	return nil
}

// GetCandle retrieves a specific candle for a symbol, interval, and time
func (r *MarketRepository) GetCandle(ctx context.Context, symbol, exchange string, interval market.Interval, openTime time.Time) (*market.Candle, error) {
	var entity CandleEntity

	result := r.db.WithContext(ctx).
		Where("symbol = ? AND exchange = ? AND interval = ? AND open_time = ?",
			symbol, exchange, string(interval), openTime).
		First(&entity)

	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			r.logger.Info().Str("symbol", symbol).Str("interval", string(interval)).Str("openTime", openTime.Format(time.RFC3339)).Msg("Candle not found")
			return nil, apperror.ErrNotFound
		}
		r.logger.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to get candle")
		return nil, fmt.Errorf("failed to get candle: %w", result.Error)
	}

	return r.candleToDomain(&entity), nil
}

// GetCandles retrieves candles for a symbol within a time range
func (r *MarketRepository) GetCandles(ctx context.Context, symbol, exchange string, interval market.Interval, start, end time.Time, limit int) ([]*market.Candle, error) {
	var entities []CandleEntity

	query := r.db.WithContext(ctx).
		Where("symbol = ? AND exchange = ? AND interval = ? AND open_time BETWEEN ? AND ?",
			symbol, exchange, string(interval), start, end).
		Order("open_time ASC")

	if limit > 0 {
		query = query.Limit(limit)
	}

	result := query.Find(&entities)

	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to get candles")
		return nil, fmt.Errorf("failed to get candles: %w", result.Error)
	}

	candles := make([]*market.Candle, len(entities))
	for i, entity := range entities {
		candles[i] = r.candleToDomain(&entity)
	}

	return candles, nil
}

// GetLatestCandle retrieves the most recent candle for a symbol and interval
func (r *MarketRepository) GetLatestCandle(ctx context.Context, symbol, exchange string, interval market.Interval) (*market.Candle, error) {
	var entity CandleEntity

	result := r.db.WithContext(ctx).
		Where("symbol = ? AND exchange = ? AND interval = ?",
			symbol, exchange, string(interval)).
		Order("open_time DESC").
		First(&entity)

	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			r.logger.Info().Str("symbol", symbol).Str("interval", string(interval)).Msg("Latest candle not found")
			return nil, apperror.ErrNotFound
		}
		r.logger.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to get latest candle")
		return nil, fmt.Errorf("failed to get latest candle: %w", result.Error)
	}

	return r.candleToDomain(&entity), nil
}

// PurgeOldData removes market data older than the specified retention period
func (r *MarketRepository) PurgeOldData(ctx context.Context, olderThan time.Time) error {
	// Delete old ticker data
	if err := r.db.WithContext(ctx).Where("last_updated < ?", olderThan).Delete(&TickerEntity{}).Error; err != nil {
		r.logger.Error().Err(err).Msg("Failed to purge old ticker data")
		return fmt.Errorf("failed to purge old ticker data: %w", err)
	}

	// Delete old candle data
	if err := r.db.WithContext(ctx).Where("open_time < ?", olderThan).Delete(&CandleEntity{}).Error; err != nil {
		r.logger.Error().Err(err).Msg("Failed to purge old candle data")
		return fmt.Errorf("failed to purge old candle data: %w", err)
	}

	// Delete old orderbook data
	if err := r.db.WithContext(ctx).Where("last_updated < ?", olderThan).Delete(&OrderBookEntity{}).Error; err != nil {
		r.logger.Error().Err(err).Msg("Failed to purge old orderbook data")
		return fmt.Errorf("failed to purge old orderbook data: %w", err)
	}

	r.logger.Info().Time("older_than", olderThan).Msg("Successfully purged old market data")
	return nil
}

// GetLatestTickers retrieves the latest tickers for all symbols
func (r *MarketRepository) GetLatestTickers(ctx context.Context, limit int) ([]*market.Ticker, error) {
	var entities []TickerEntity

	// Using a common table expression (CTE) to get the latest ticker for each symbol
	query := r.db.WithContext(ctx).
		Raw(`WITH latest_tickers AS (
			SELECT symbol, exchange, MAX(last_updated) as max_updated
			FROM tickers
			GROUP BY symbol, exchange
		)
		SELECT t.*
		FROM tickers t
		JOIN latest_tickers lt ON t.symbol = lt.symbol AND t.exchange = lt.exchange AND t.last_updated = lt.max_updated
		ORDER BY t.symbol`)

	if limit > 0 {
		query = query.Limit(limit)
	}

	result := query.Find(&entities)

	if result.Error != nil {
		r.logger.Error().Err(result.Error).Msg("Failed to get latest tickers")
		return nil, fmt.Errorf("failed to get latest tickers: %w", result.Error)
	}

	tickers := make([]*market.Ticker, len(entities))
	for i, entity := range entities {
		tickers[i] = r.tickerToDomain(&entity)
	}

	return tickers, nil
}

// GetTickersBySymbol retrieves tickers for a specific symbol with optional time range
func (r *MarketRepository) GetTickersBySymbol(ctx context.Context, symbol string, limit int) ([]*market.Ticker, error) {
	var entities []TickerEntity

	query := r.db.WithContext(ctx).
		Where("symbol = ?", symbol).
		Order("last_updated DESC")

	if limit > 0 {
		query = query.Limit(limit)
	}

	result := query.Find(&entities)

	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to get tickers by symbol")
		return nil, fmt.Errorf("failed to get tickers by symbol: %w", result.Error)
	}

	tickers := make([]*market.Ticker, len(entities))
	for i, entity := range entities {
		tickers[i] = r.tickerToDomain(&entity)
	}

	return tickers, nil
}

// Symbol Repository implementation

// Create stores a new Symbol
func (r *MarketRepository) Create(ctx context.Context, symbol *market.Symbol) error {
	entity := r.symbolToEntity(symbol)

	result := r.db.WithContext(ctx).Create(&entity)
	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("symbol", symbol.Symbol).Msg("Failed to create symbol")
		return fmt.Errorf("failed to create symbol: %w", result.Error)
	}

	r.logger.Info().Str("symbol", symbol.Symbol).Str("exchange", symbol.Exchange).Msg("Symbol created successfully")
	return nil
}

// GetBySymbol returns a Symbol by its symbol string (e.g., "BTCUSDT")
func (r *MarketRepository) GetBySymbol(ctx context.Context, symbol string) (*market.Symbol, error) {
	var entity SymbolEntity

	result := r.db.WithContext(ctx).Where("symbol = ?", symbol).First(&entity)
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			r.logger.Info().Str("symbol", symbol).Msg("Symbol not found")
			return nil, apperror.ErrNotFound
		}
		r.logger.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to get symbol")
		return nil, fmt.Errorf("failed to get symbol: %w", result.Error)
	}

	return r.symbolToDomain(&entity), nil
}

// GetByExchange returns all Symbols from a specific exchange
func (r *MarketRepository) GetByExchange(ctx context.Context, exchange string) ([]*market.Symbol, error) {
	var entities []SymbolEntity

	result := r.db.WithContext(ctx).Where("exchange = ?", exchange).Find(&entities)
	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("exchange", exchange).Msg("Failed to get symbols by exchange")
		return nil, fmt.Errorf("failed to get symbols by exchange: %w", result.Error)
	}

	symbols := make([]*market.Symbol, len(entities))
	for i, entity := range entities {
		symbols[i] = r.symbolToDomain(&entity)
	}

	r.logger.Info().Str("exchange", exchange).Int("count", len(symbols)).Msg("Retrieved symbols by exchange")
	return symbols, nil
}

// GetAll returns all available Symbols
func (r *MarketRepository) GetAll(ctx context.Context) ([]*market.Symbol, error) {
	var entities []SymbolEntity

	result := r.db.WithContext(ctx).Find(&entities)
	if result.Error != nil {
		r.logger.Error().Err(result.Error).Msg("Failed to get all symbols")
		return nil, fmt.Errorf("failed to get all symbols: %w", result.Error)
	}

	symbols := make([]*market.Symbol, len(entities))
	for i, entity := range entities {
		symbols[i] = r.symbolToDomain(&entity)
	}

	r.logger.Info().Int("count", len(symbols)).Msg("Retrieved all symbols")
	return symbols, nil
}

// Update updates an existing Symbol
func (r *MarketRepository) Update(ctx context.Context, symbol *market.Symbol) error {
	entity := r.symbolToEntity(symbol)

	result := r.db.WithContext(ctx).Where("symbol = ?", symbol.Symbol).Updates(&entity)
	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("symbol", symbol.Symbol).Msg("Failed to update symbol")
		return fmt.Errorf("failed to update symbol: %w", result.Error)
	}

	if result.RowsAffected == 0 {
		r.logger.Warn().Str("symbol", symbol.Symbol).Msg("No symbol found to update")
		return apperror.ErrNotFound
	}

	r.logger.Info().Str("symbol", symbol.Symbol).Msg("Symbol updated successfully")
	return nil
}

// Delete removes a Symbol
func (r *MarketRepository) Delete(ctx context.Context, symbol string) error {
	result := r.db.WithContext(ctx).Where("symbol = ?", symbol).Delete(&SymbolEntity{})
	if result.Error != nil {
		r.logger.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to delete symbol")
		return fmt.Errorf("failed to delete symbol: %w", result.Error)
	}

	if result.RowsAffected == 0 {
		r.logger.Warn().Str("symbol", symbol).Msg("No symbol found to delete")
		return apperror.ErrNotFound
	}

	r.logger.Info().Str("symbol", symbol).Msg("Symbol deleted successfully")
	return nil
}

// Helper methods to convert between domain model and database entity

func (r *MarketRepository) tickerToEntity(ticker *market.Ticker) TickerEntity {
	return TickerEntity{
		ID:            ticker.ID,
		Symbol:        ticker.Symbol,
		Price:         ticker.Price,
		Volume:        ticker.Volume,
		High24h:       ticker.High24h,
		Low24h:        ticker.Low24h,
		PriceChange:   ticker.PriceChange,
		PercentChange: ticker.PercentChange,
		LastUpdated:   ticker.LastUpdated,
		Exchange:      ticker.Exchange,
	}
}

func (r *MarketRepository) tickerToDomain(entity *TickerEntity) *market.Ticker {
	return &market.Ticker{
		ID:            entity.ID,
		Symbol:        entity.Symbol,
		Price:         entity.Price,
		Volume:        entity.Volume,
		High24h:       entity.High24h,
		Low24h:        entity.Low24h,
		PriceChange:   entity.PriceChange,
		PercentChange: entity.PercentChange,
		LastUpdated:   entity.LastUpdated,
		Exchange:      entity.Exchange,
	}
}

func (r *MarketRepository) candleToEntity(candle *market.Candle) CandleEntity {
	return CandleEntity{
		Symbol:      candle.Symbol,
		Exchange:    candle.Exchange,
		Interval:    string(candle.Interval),
		OpenTime:    candle.OpenTime,
		CloseTime:   candle.CloseTime,
		Open:        candle.Open,
		High:        candle.High,
		Low:         candle.Low,
		Close:       candle.Close,
		Volume:      candle.Volume,
		QuoteVolume: candle.QuoteVolume,
		TradeCount:  candle.TradeCount,
		Complete:    candle.Complete,
	}
}

func (r *MarketRepository) candleToDomain(entity *CandleEntity) *market.Candle {
	return &market.Candle{
		Symbol:      entity.Symbol,
		Exchange:    entity.Exchange,
		Interval:    market.Interval(entity.Interval),
		OpenTime:    entity.OpenTime,
		CloseTime:   entity.CloseTime,
		Open:        entity.Open,
		High:        entity.High,
		Low:         entity.Low,
		Close:       entity.Close,
		Volume:      entity.Volume,
		QuoteVolume: entity.QuoteVolume,
		TradeCount:  entity.TradeCount,
		Complete:    entity.Complete,
	}
}

func (r *MarketRepository) orderBookToEntity(orderbook *market.OrderBook) (OrderBookEntity, []OrderBookEntryEntity) {
	entity := OrderBookEntity{
		Symbol:       orderbook.Symbol,
		Exchange:     orderbook.Exchange,
		LastUpdated:  orderbook.LastUpdated,
		SequenceNum:  orderbook.SequenceNum,
		LastUpdateID: orderbook.LastUpdateID,
	}

	entries := make([]OrderBookEntryEntity, 0, len(orderbook.Bids)+len(orderbook.Asks))

	// Add bid entries
	for _, bid := range orderbook.Bids {
		entries = append(entries, OrderBookEntryEntity{
			Type:     "bid",
			Price:    bid.Price,
			Quantity: bid.Quantity,
		})
	}

	// Add ask entries
	for _, ask := range orderbook.Asks {
		entries = append(entries, OrderBookEntryEntity{
			Type:     "ask",
			Price:    ask.Price,
			Quantity: ask.Quantity,
		})
	}

	return entity, entries
}

func (r *MarketRepository) orderBookToDomain(entity *OrderBookEntity, entries []OrderBookEntryEntity) *market.OrderBook {
	orderbook := &market.OrderBook{
		Symbol:       entity.Symbol,
		Exchange:     entity.Exchange,
		LastUpdated:  entity.LastUpdated,
		SequenceNum:  entity.SequenceNum,
		LastUpdateID: entity.LastUpdateID,
		Bids:         make([]market.OrderBookEntry, 0),
		Asks:         make([]market.OrderBookEntry, 0),
	}

	for _, entry := range entries {
		bookEntry := market.OrderBookEntry{
			Price:    entry.Price,
			Quantity: entry.Quantity,
		}

		if entry.Type == "bid" {
			orderbook.Bids = append(orderbook.Bids, bookEntry)
		} else if entry.Type == "ask" {
			orderbook.Asks = append(orderbook.Asks, bookEntry)
		}
	}

	return orderbook
}

func (r *MarketRepository) symbolToEntity(symbol *market.Symbol) SymbolEntity {
	return SymbolEntity{
		Symbol:            symbol.Symbol,
		BaseAsset:         symbol.BaseAsset,
		QuoteAsset:        symbol.QuoteAsset,
		Exchange:          symbol.Exchange,
		Status:            symbol.Status,
		MinPrice:          symbol.MinPrice,
		MaxPrice:          symbol.MaxPrice,
		PricePrecision:    symbol.PricePrecision,
		MinQty:            symbol.MinQty,
		MaxQty:            symbol.MaxQty,
		QtyPrecision:      symbol.QtyPrecision,
		AllowedOrderTypes: strings.Join(symbol.AllowedOrderTypes, ","),
	}
}

func (r *MarketRepository) symbolToDomain(entity *SymbolEntity) *market.Symbol {
	var allowedOrderTypes []string
	if entity.AllowedOrderTypes != "" {
		allowedOrderTypes = strings.Split(entity.AllowedOrderTypes, ",")
	}

	return &market.Symbol{
		Symbol:            entity.Symbol,
		BaseAsset:         entity.BaseAsset,
		QuoteAsset:        entity.QuoteAsset,
		Exchange:          entity.Exchange,
		Status:            entity.Status,
		MinPrice:          entity.MinPrice,
		MaxPrice:          entity.MaxPrice,
		PricePrecision:    entity.PricePrecision,
		MinQty:            entity.MinQty,
		MaxQty:            entity.MaxQty,
		QtyPrecision:      entity.QtyPrecision,
		AllowedOrderTypes: allowedOrderTypes,
		CreatedAt:         entity.CreatedAt,
		UpdatedAt:         entity.UpdatedAt,
	}
}
</file>

<file path="internal/adapter/persistence/gorm/order_repository.go">
package gorm

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog"
	"gorm.io/gorm"
)

// Ensure OrderRepository implements the port.OrderRepository interface
var _ port.OrderRepository = (*OrderRepository)(nil)

// OrderEntity represents the database model for order
type OrderEntity struct {
	ID            string    `gorm:"primaryKey;size:36"`     // Internal ID
	OrderID       string    `gorm:"size:36;index;not null"` // Exchange order ID
	ClientOrderID string    `gorm:"size:36;uniqueIndex;not null"`
	Symbol        string    `gorm:"size:20;index;not null"`
	Side          string    `gorm:"size:10;not null"`
	Type          string    `gorm:"size:20;not null"`
	Status        string    `gorm:"size:20;index;not null"`
	TimeInForce   string    `gorm:"size:10"`
	Price         float64   `gorm:"type:decimal(18,8)"`
	Quantity      float64   `gorm:"type:decimal(18,8);not null"`
	ExecutedQty   float64   `gorm:"type:decimal(18,8);default:0"`
	CreatedAt     time.Time `gorm:"not null"`
	UpdatedAt     time.Time `gorm:"not null"`
}

// OrderRepository implements the port.OrderRepository interface
type OrderRepository struct {
	db     *gorm.DB
	logger *zerolog.Logger
}

// NewOrderRepository creates a new OrderRepository
func NewOrderRepository(db *gorm.DB, logger *zerolog.Logger) *OrderRepository {
	return &OrderRepository{
		db:     db,
		logger: logger,
	}
}

// Create persists a new order to the database
func (r *OrderRepository) Create(ctx context.Context, order *model.Order) error {
	r.logger.Debug().
		Str("orderID", order.OrderID).
		Str("clientOrderID", order.ClientOrderID).
		Str("symbol", order.Symbol).
		Str("side", string(order.Side)).
		Str("type", string(order.Type)).
		Msg("Creating order")

	entity := r.toEntity(order)
	return r.db.WithContext(ctx).Create(entity).Error
}

// GetByID retrieves an order by its ID
func (r *OrderRepository) GetByID(ctx context.Context, id string) (*model.Order, error) {
	r.logger.Debug().
		Str("orderID", id).
		Msg("Getting order by ID")

	var entity OrderEntity
	result := r.db.WithContext(ctx).Where("id = ?", id).First(&entity)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("order not found: %w", result.Error)
		}
		return nil, result.Error
	}

	return r.toDomain(&entity), nil
}

// GetByClientOrderID retrieves an order by its client order ID
func (r *OrderRepository) GetByClientOrderID(ctx context.Context, clientOrderID string) (*model.Order, error) {
	r.logger.Debug().
		Str("clientOrderID", clientOrderID).
		Msg("Getting order by client order ID")

	var entity OrderEntity
	result := r.db.WithContext(ctx).Where("client_order_id = ?", clientOrderID).First(&entity)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("order not found: %w", result.Error)
		}
		return nil, result.Error
	}

	return r.toDomain(&entity), nil
}

// Update updates an existing order in the database
func (r *OrderRepository) Update(ctx context.Context, order *model.Order) error {
	r.logger.Debug().
		Str("orderID", order.OrderID).
		Str("status", string(order.Status)).
		Float64("executedQty", order.ExecutedQty).
		Msg("Updating order")

	// Only use the entity for logging purposes
	result := r.db.WithContext(ctx).Model(&OrderEntity{}).
		Where("id = ?", order.ID).
		Updates(map[string]interface{}{
			"status":       string(order.Status),
			"executed_qty": order.ExecutedQty,
			"updated_at":   time.Now(),
		})

	if result.Error != nil {
		return result.Error
	}

	if result.RowsAffected == 0 {
		return fmt.Errorf("order not found: %s", order.ID)
	}

	return nil
}

// GetBySymbol retrieves orders for a specific symbol with pagination
func (r *OrderRepository) GetBySymbol(ctx context.Context, symbol string, limit, offset int) ([]*model.Order, error) {
	r.logger.Debug().
		Str("symbol", symbol).
		Int("limit", limit).
		Int("offset", offset).
		Msg("Getting orders by symbol")

	var entities []OrderEntity
	result := r.db.WithContext(ctx).
		Where("symbol = ?", symbol).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&entities)

	if result.Error != nil {
		return nil, result.Error
	}

	orders := make([]*model.Order, len(entities))
	for i, entity := range entities {
		orders[i] = r.toDomain(&entity)
	}

	return orders, nil
}

// GetByUserID retrieves orders for a specific user with pagination
func (r *OrderRepository) GetByUserID(ctx context.Context, userID string, limit, offset int) ([]*model.Order, error) {
	r.logger.Debug().
		Str("userID", userID).
		Int("limit", limit).
		Int("offset", offset).
		Msg("Getting orders by user ID")

	// Since the Order model doesn't have a UserID field, we can implement this
	// when the application evolves to include user association with orders
	// For now, return an empty slice as a placeholder
	return []*model.Order{}, nil
}

// GetByStatus retrieves orders with a specific status with pagination
func (r *OrderRepository) GetByStatus(ctx context.Context, status model.OrderStatus, limit, offset int) ([]*model.Order, error) {
	r.logger.Debug().
		Str("status", string(status)).
		Int("limit", limit).
		Int("offset", offset).
		Msg("Getting orders by status")

	var entities []OrderEntity
	result := r.db.WithContext(ctx).
		Where("status = ?", string(status)).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&entities)

	if result.Error != nil {
		return nil, result.Error
	}

	orders := make([]*model.Order, len(entities))
	for i, entity := range entities {
		orders[i] = r.toDomain(&entity)
	}

	return orders, nil
}

// Count counts orders based on provided filters
func (r *OrderRepository) Count(ctx context.Context, filters map[string]interface{}) (int64, error) {
	r.logger.Debug().
		Interface("filters", filters).
		Msg("Counting orders")

	var count int64
	query := r.db.WithContext(ctx).Model(&OrderEntity{})

	// Apply filters
	for key, value := range filters {
		query = query.Where(key+" = ?", value)
	}

	result := query.Count(&count)
	return count, result.Error
}

// Delete removes an order from the database
func (r *OrderRepository) Delete(ctx context.Context, id string) error {
	r.logger.Debug().
		Str("orderID", id).
		Msg("Deleting order")

	result := r.db.WithContext(ctx).Where("id = ?", id).Delete(&OrderEntity{})
	if result.Error != nil {
		return result.Error
	}

	if result.RowsAffected == 0 {
		return fmt.Errorf("order not found: %s", id)
	}

	return nil
}

// Helper methods for entity conversion

// toEntity converts a domain model to a database entity
func (r *OrderRepository) toEntity(order *model.Order) *OrderEntity {
	return &OrderEntity{
		ID:            order.ID,
		OrderID:       order.OrderID,
		ClientOrderID: order.ClientOrderID,
		Symbol:        order.Symbol,
		Side:          string(order.Side),
		Type:          string(order.Type),
		Status:        string(order.Status),
		TimeInForce:   string(order.TimeInForce),
		Price:         order.Price,
		Quantity:      order.Quantity,
		ExecutedQty:   order.ExecutedQty,
		CreatedAt:     order.CreatedAt,
		UpdatedAt:     order.UpdatedAt,
	}
}

// toDomain converts a database entity to a domain model
func (r *OrderRepository) toDomain(entity *OrderEntity) *model.Order {
	return &model.Order{
		ID:            entity.ID,
		OrderID:       entity.OrderID,
		ClientOrderID: entity.ClientOrderID,
		Symbol:        entity.Symbol,
		Side:          model.OrderSide(entity.Side),
		Type:          model.OrderType(entity.Type),
		Status:        model.OrderStatus(entity.Status),
		TimeInForce:   model.TimeInForce(entity.TimeInForce),
		Price:         entity.Price,
		Quantity:      entity.Quantity,
		ExecutedQty:   entity.ExecutedQty,
		CreatedAt:     entity.CreatedAt,
		UpdatedAt:     entity.UpdatedAt,
	}
}
</file>

<file path="internal/adapter/persistence/gorm/position_repository.go">
package gorm

import (
	"context"
	"encoding/json"
	"errors"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog/log"
	"gorm.io/gorm"
)

// Error definitions
var (
	// ErrPositionNotFound is returned when a position cannot be found
	ErrPositionNotFound = errors.New("position not found")
)

// Ensure PositionRepository implements port.PositionRepository
var _ port.PositionRepository = (*PositionRepository)(nil)

// PositionEntity represents the database model for a position
type PositionEntity struct {
	ID              string `gorm:"primaryKey"`
	Symbol          string `gorm:"index"`
	Side            string `gorm:"index"`
	Status          string `gorm:"index"`
	Type            string `gorm:"index"`
	EntryPrice      float64
	Quantity        float64
	CurrentPrice    float64
	PnL             float64
	PnLPercent      float64
	StopLoss        *float64
	TakeProfit      *float64
	StrategyID      *string
	EntryOrderIDs   string // Stored as JSON array
	ExitOrderIDs    string // Stored as JSON array
	OpenOrderIDs    string // Stored as JSON array
	Notes           string
	OpenedAt        time.Time
	ClosedAt        *time.Time
	LastUpdatedAt   time.Time
	MaxDrawdown     float64
	MaxProfit       float64
	RiskRewardRatio float64
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

// PositionRepository implements the port.PositionRepository interface using GORM
type PositionRepository struct {
	db *gorm.DB
}

// NewPositionRepository creates a new instance of PositionRepository
func NewPositionRepository(db *gorm.DB) *PositionRepository {
	return &PositionRepository{
		db: db,
	}
}

// Create creates a new position in the database
func (r *PositionRepository) Create(ctx context.Context, position *model.Position) error {
	entity := r.toEntity(position)
	result := r.db.WithContext(ctx).Create(&entity)
	if result.Error != nil {
		log.Error().Err(result.Error).Str("positionID", position.ID).Msg("Failed to create position")
		return result.Error
	}

	log.Debug().Str("positionID", position.ID).Msg("Position created successfully")
	return nil
}

// GetByID retrieves a position by its ID
func (r *PositionRepository) GetByID(ctx context.Context, id string) (*model.Position, error) {
	var entity PositionEntity
	result := r.db.WithContext(ctx).Where("id = ?", id).First(&entity)
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			log.Debug().Str("positionID", id).Msg("Position not found")
			return nil, ErrPositionNotFound
		}
		log.Error().Err(result.Error).Str("positionID", id).Msg("Failed to get position")
		return nil, result.Error
	}

	return r.toDomain(&entity), nil
}

// Update updates an existing position
func (r *PositionRepository) Update(ctx context.Context, position *model.Position) error {
	entity := r.toEntity(position)
	result := r.db.WithContext(ctx).Where("id = ?", position.ID).Updates(&entity)
	if result.Error != nil {
		log.Error().Err(result.Error).Str("positionID", position.ID).Msg("Failed to update position")
		return result.Error
	}
	if result.RowsAffected == 0 {
		log.Debug().Str("positionID", position.ID).Msg("Position not found for update")
		return ErrPositionNotFound
	}

	log.Debug().Str("positionID", position.ID).Msg("Position updated successfully")
	return nil
}

// GetOpenPositions retrieves all open positions
func (r *PositionRepository) GetOpenPositions(ctx context.Context) ([]*model.Position, error) {
	var entities []PositionEntity
	result := r.db.WithContext(ctx).Where("status = ?", string(model.PositionStatusOpen)).Find(&entities)
	if result.Error != nil {
		log.Error().Err(result.Error).Msg("Failed to get open positions")
		return nil, result.Error
	}

	positions := make([]*model.Position, len(entities))
	for i, entity := range entities {
		positions[i] = r.toDomain(&entity)
	}

	log.Debug().Int("count", len(positions)).Msg("Retrieved open positions")
	return positions, nil
}

// GetOpenPositionsBySymbol retrieves all open positions for a specific symbol
func (r *PositionRepository) GetOpenPositionsBySymbol(ctx context.Context, symbol string) ([]*model.Position, error) {
	var entities []PositionEntity
	result := r.db.WithContext(ctx).Where("status = ? AND symbol = ?",
		string(model.PositionStatusOpen), symbol).Find(&entities)
	if result.Error != nil {
		log.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to get open positions by symbol")
		return nil, result.Error
	}

	positions := make([]*model.Position, len(entities))
	for i, entity := range entities {
		positions[i] = r.toDomain(&entity)
	}

	log.Debug().Str("symbol", symbol).Int("count", len(positions)).Msg("Retrieved open positions by symbol")
	return positions, nil
}

// GetOpenPositionsByType retrieves all open positions for a specific type
func (r *PositionRepository) GetOpenPositionsByType(ctx context.Context, positionType model.PositionType) ([]*model.Position, error) {
	var entities []PositionEntity
	result := r.db.WithContext(ctx).Where("status = ? AND type = ?",
		string(model.PositionStatusOpen), string(positionType)).Find(&entities)
	if result.Error != nil {
		log.Error().Err(result.Error).Str("type", string(positionType)).Msg("Failed to get open positions by type")
		return nil, result.Error
	}

	positions := make([]*model.Position, len(entities))
	for i, entity := range entities {
		positions[i] = r.toDomain(&entity)
	}

	log.Debug().Str("type", string(positionType)).Int("count", len(positions)).Msg("Retrieved open positions by type")
	return positions, nil
}

// GetBySymbol retrieves positions for a specific symbol with pagination
func (r *PositionRepository) GetBySymbol(ctx context.Context, symbol string, limit, offset int) ([]*model.Position, error) {
	var entities []PositionEntity
	result := r.db.WithContext(ctx).Where("symbol = ?", symbol).
		Limit(limit).Offset(offset).
		Order("opened_at DESC").
		Find(&entities)

	if result.Error != nil {
		log.Error().Err(result.Error).Str("symbol", symbol).Msg("Failed to get positions by symbol")
		return nil, result.Error
	}

	positions := make([]*model.Position, len(entities))
	for i, entity := range entities {
		positions[i] = r.toDomain(&entity)
	}

	log.Debug().Str("symbol", symbol).Int("count", len(positions)).Msg("Retrieved positions by symbol")
	return positions, nil
}

// GetByUserID retrieves positions for a specific user with pagination
func (r *PositionRepository) GetByUserID(ctx context.Context, userID string, limit, offset int) ([]*model.Position, error) {
	// Note: The Position model doesn't have a UserID field, so this is a placeholder implementation
	// that might need to be updated according to actual requirements
	log.Warn().Msg("GetByUserID called, but Position model doesn't have UserID field")
	return []*model.Position{}, nil
}

// GetClosedPositions retrieves closed positions within a time range with pagination
func (r *PositionRepository) GetClosedPositions(ctx context.Context, from, to time.Time, limit, offset int) ([]*model.Position, error) {
	var entities []PositionEntity
	result := r.db.WithContext(ctx).
		Where("status = ? AND closed_at BETWEEN ? AND ?", string(model.PositionStatusClosed), from, to).
		Limit(limit).Offset(offset).
		Order("closed_at DESC").
		Find(&entities)

	if result.Error != nil {
		log.Error().Err(result.Error).Msg("Failed to get closed positions")
		return nil, result.Error
	}

	positions := make([]*model.Position, len(entities))
	for i, entity := range entities {
		positions[i] = r.toDomain(&entity)
	}

	log.Debug().Int("count", len(positions)).Msg("Retrieved closed positions")
	return positions, nil
}

// Count counts positions based on provided filters
func (r *PositionRepository) Count(ctx context.Context, filters map[string]interface{}) (int64, error) {
	var count int64
	query := r.db.WithContext(ctx).Model(&PositionEntity{})

	// Apply filters
	for key, value := range filters {
		query = query.Where(key+" = ?", value)
	}

	result := query.Count(&count)
	if result.Error != nil {
		log.Error().Err(result.Error).Msg("Failed to count positions")
		return 0, result.Error
	}

	log.Debug().Int64("count", count).Msg("Counted positions")
	return count, nil
}

// Delete deletes a position by its ID
func (r *PositionRepository) Delete(ctx context.Context, id string) error {
	result := r.db.WithContext(ctx).Where("id = ?", id).Delete(&PositionEntity{})
	if result.Error != nil {
		log.Error().Err(result.Error).Str("positionID", id).Msg("Failed to delete position")
		return result.Error
	}
	if result.RowsAffected == 0 {
		log.Debug().Str("positionID", id).Msg("Position not found for deletion")
		return ErrPositionNotFound
	}

	log.Debug().Str("positionID", id).Msg("Position deleted successfully")
	return nil
}

// Helper methods for entity conversion
func (r *PositionRepository) toEntity(position *model.Position) *PositionEntity {
	// Convert slice fields to JSON strings
	entryOrderIDsJSON, err := json.Marshal(position.EntryOrderIDs)
	if err != nil {
		log.Error().Err(err).Str("positionID", position.ID).Msg("Failed to marshal EntryOrderIDs")
		entryOrderIDsJSON = []byte("[]")
	}

	exitOrderIDsJSON, err := json.Marshal(position.ExitOrderIDs)
	if err != nil {
		log.Error().Err(err).Str("positionID", position.ID).Msg("Failed to marshal ExitOrderIDs")
		exitOrderIDsJSON = []byte("[]")
	}

	openOrderIDsJSON, err := json.Marshal(position.OpenOrderIDs)
	if err != nil {
		log.Error().Err(err).Str("positionID", position.ID).Msg("Failed to marshal OpenOrderIDs")
		openOrderIDsJSON = []byte("[]")
	}

	return &PositionEntity{
		ID:              position.ID,
		Symbol:          position.Symbol,
		Side:            string(position.Side),
		Status:          string(position.Status),
		Type:            string(position.Type),
		EntryPrice:      position.EntryPrice,
		Quantity:        position.Quantity,
		CurrentPrice:    position.CurrentPrice,
		PnL:             position.PnL,
		PnLPercent:      position.PnLPercent,
		StopLoss:        position.StopLoss,
		TakeProfit:      position.TakeProfit,
		StrategyID:      position.StrategyID,
		EntryOrderIDs:   string(entryOrderIDsJSON),
		ExitOrderIDs:    string(exitOrderIDsJSON),
		OpenOrderIDs:    string(openOrderIDsJSON),
		Notes:           position.Notes,
		OpenedAt:        position.OpenedAt,
		ClosedAt:        position.ClosedAt,
		LastUpdatedAt:   position.LastUpdatedAt,
		MaxDrawdown:     position.MaxDrawdown,
		MaxProfit:       position.MaxProfit,
		RiskRewardRatio: position.RiskRewardRatio,
		CreatedAt:       time.Now(),
		UpdatedAt:       time.Now(),
	}
}

func (r *PositionRepository) toDomain(entity *PositionEntity) *model.Position {
	// Parse JSON strings back to slices
	var entryOrderIDs, exitOrderIDs, openOrderIDs []string

	// Handle possible empty strings or invalid JSON
	if entity.EntryOrderIDs != "" {
		if err := json.Unmarshal([]byte(entity.EntryOrderIDs), &entryOrderIDs); err != nil {
			log.Error().Err(err).Str("positionID", entity.ID).Msg("Failed to unmarshal EntryOrderIDs")
			entryOrderIDs = []string{}
		}
	}

	if entity.ExitOrderIDs != "" {
		if err := json.Unmarshal([]byte(entity.ExitOrderIDs), &exitOrderIDs); err != nil {
			log.Error().Err(err).Str("positionID", entity.ID).Msg("Failed to unmarshal ExitOrderIDs")
			exitOrderIDs = []string{}
		}
	}

	if entity.OpenOrderIDs != "" {
		if err := json.Unmarshal([]byte(entity.OpenOrderIDs), &openOrderIDs); err != nil {
			log.Error().Err(err).Str("positionID", entity.ID).Msg("Failed to unmarshal OpenOrderIDs")
			openOrderIDs = []string{}
		}
	}

	return &model.Position{
		ID:              entity.ID,
		Symbol:          entity.Symbol,
		Side:            model.PositionSide(entity.Side),
		Status:          model.PositionStatus(entity.Status),
		Type:            model.PositionType(entity.Type),
		EntryPrice:      entity.EntryPrice,
		Quantity:        entity.Quantity,
		CurrentPrice:    entity.CurrentPrice,
		PnL:             entity.PnL,
		PnLPercent:      entity.PnLPercent,
		StopLoss:        entity.StopLoss,
		TakeProfit:      entity.TakeProfit,
		StrategyID:      entity.StrategyID,
		EntryOrderIDs:   entryOrderIDs,
		ExitOrderIDs:    exitOrderIDs,
		OpenOrderIDs:    openOrderIDs,
		Notes:           entity.Notes,
		OpenedAt:        entity.OpenedAt,
		ClosedAt:        entity.ClosedAt,
		LastUpdatedAt:   entity.LastUpdatedAt,
		MaxDrawdown:     entity.MaxDrawdown,
		MaxProfit:       entity.MaxProfit,
		RiskRewardRatio: entity.RiskRewardRatio,
	}
}
</file>

<file path="internal/adapter/persistence/gorm/wallet_repository.go">
package gorm

import (
	"context"
	"strconv"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog"
	"gorm.io/gorm"
)

// Ensure WalletRepository implements the port.WalletRepository interface
var _ port.WalletRepository = (*WalletRepository)(nil)

// WalletEntity represents the database model for wallet
type WalletEntity struct {
	ID            uint      `gorm:"primaryKey"`
	UserID        string    `gorm:"size:50;not null;index"`
	TotalUSDValue float64   `gorm:"type:decimal(18,8);not null"`
	LastUpdated   time.Time `gorm:"not null"`
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

// BalanceEntity represents the database model for a balance
type BalanceEntity struct {
	ID        uint    `gorm:"primaryKey"`
	WalletID  uint    `gorm:"not null;index"`
	Asset     string  `gorm:"size:20;not null"`
	Free      float64 `gorm:"type:decimal(18,8);not null"`
	Locked    float64 `gorm:"type:decimal(18,8);not null"`
	Total     float64 `gorm:"type:decimal(18,8);not null"`
	USDValue  float64 `gorm:"type:decimal(18,8);not null"`
	CreatedAt time.Time
	UpdatedAt time.Time
}

// BalanceHistoryEntity represents the database model for balance history
type BalanceHistoryEntity struct {
	ID        uint      `gorm:"primaryKey"`
	UserID    string    `gorm:"size:50;not null;index"`
	Asset     string    `gorm:"size:20;not null"`
	Free      float64   `gorm:"type:decimal(18,8);not null"`
	Locked    float64   `gorm:"type:decimal(18,8);not null"`
	Total     float64   `gorm:"type:decimal(18,8);not null"`
	USDValue  float64   `gorm:"type:decimal(18,8);not null"`
	Timestamp time.Time `gorm:"not null;index"`
	CreatedAt time.Time
}

// WalletRepository implements the port.WalletRepository interface with GORM
type WalletRepository struct {
	db     *gorm.DB
	logger *zerolog.Logger
}

// NewWalletRepository creates a new WalletRepository
func NewWalletRepository(db *gorm.DB, logger *zerolog.Logger) *WalletRepository {
	return &WalletRepository{
		db:     db,
		logger: logger,
	}
}

// Save persists a wallet to the database
func (r *WalletRepository) Save(ctx context.Context, wallet *model.Wallet) error {
	r.logger.Debug().
		Str("userID", wallet.UserID).
		Float64("totalUSDValue", wallet.TotalUSDValue).
		Msg("Saving wallet to database")

	// Begin transaction
	tx := r.db.WithContext(ctx).Begin()
	if tx.Error != nil {
		return tx.Error
	}
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Find or create wallet entity
	var walletEntity WalletEntity
	result := tx.Where("user_id = ?", wallet.UserID).First(&walletEntity)

	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			// Create new wallet entity
			walletEntity = WalletEntity{
				UserID:        wallet.UserID,
				TotalUSDValue: wallet.TotalUSDValue,
				LastUpdated:   wallet.LastUpdated,
			}
			if err := tx.Create(&walletEntity).Error; err != nil {
				tx.Rollback()
				return err
			}
		} else {
			tx.Rollback()
			return result.Error
		}
	} else {
		// Update existing wallet entity
		walletEntity.TotalUSDValue = wallet.TotalUSDValue
		walletEntity.LastUpdated = wallet.LastUpdated
		if err := tx.Save(&walletEntity).Error; err != nil {
			tx.Rollback()
			return err
		}
	}

	// Delete old balances
	if err := tx.Where("wallet_id = ?", walletEntity.ID).Delete(&BalanceEntity{}).Error; err != nil {
		tx.Rollback()
		return err
	}

	// Add new balances
	for asset, balance := range wallet.Balances {
		balanceEntity := BalanceEntity{
			WalletID: walletEntity.ID,
			Asset:    string(asset),
			Free:     balance.Free,
			Locked:   balance.Locked,
			Total:    balance.Total,
			USDValue: balance.USDValue,
		}
		if err := tx.Create(&balanceEntity).Error; err != nil {
			tx.Rollback()
			return err
		}
	}

	// Commit transaction
	return tx.Commit().Error
}

// GetByUserID retrieves a wallet by user ID
func (r *WalletRepository) GetByUserID(ctx context.Context, userID string) (*model.Wallet, error) {
	r.logger.Debug().
		Str("userID", userID).
		Msg("Getting wallet by user ID")

	// Find wallet entity
	var walletEntity WalletEntity
	result := r.db.WithContext(ctx).Where("user_id = ?", userID).First(&walletEntity)
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			// Return empty wallet if not found
			return model.NewWallet(userID), nil
		}
		return nil, result.Error
	}

	// Find balances for this wallet
	var balanceEntities []BalanceEntity
	if err := r.db.WithContext(ctx).Where("wallet_id = ?", walletEntity.ID).Find(&balanceEntities).Error; err != nil {
		return nil, err
	}

	// Create domain wallet
	wallet := &model.Wallet{
		UserID:        walletEntity.UserID,
		Balances:      make(map[model.Asset]*model.Balance),
		TotalUSDValue: walletEntity.TotalUSDValue,
		LastUpdated:   walletEntity.LastUpdated,
	}

	// Add balances
	for _, entity := range balanceEntities {
		asset := model.Asset(entity.Asset)
		wallet.Balances[asset] = &model.Balance{
			Asset:    asset,
			Free:     entity.Free,
			Locked:   entity.Locked,
			Total:    entity.Total,
			USDValue: entity.USDValue,
		}
	}

	return wallet, nil
}

// SaveBalanceHistory saves a balance history record
func (r *WalletRepository) SaveBalanceHistory(ctx context.Context, history *model.BalanceHistory) error {
	r.logger.Debug().
		Str("userID", history.UserID).
		Str("asset", string(history.Asset)).
		Time("timestamp", history.Timestamp).
		Msg("Saving balance history")

	entity := BalanceHistoryEntity{
		UserID:    history.UserID,
		Asset:     string(history.Asset),
		Free:      history.Free,
		Locked:    history.Locked,
		Total:     history.Total,
		USDValue:  history.USDValue,
		Timestamp: history.Timestamp,
	}

	return r.db.WithContext(ctx).Create(&entity).Error
}

// GetBalanceHistory retrieves balance history records
func (r *WalletRepository) GetBalanceHistory(ctx context.Context, userID string, asset model.Asset, from, to time.Time) ([]*model.BalanceHistory, error) {
	r.logger.Debug().
		Str("userID", userID).
		Str("asset", string(asset)).
		Time("from", from).
		Time("to", to).
		Msg("Getting balance history")

	var entities []BalanceHistoryEntity
	result := r.db.WithContext(ctx).
		Where("user_id = ? AND asset = ? AND timestamp BETWEEN ? AND ?", userID, string(asset), from, to).
		Order("timestamp ASC").
		Find(&entities)
	if result.Error != nil {
		return nil, result.Error
	}

	history := make([]*model.BalanceHistory, len(entities))
	for i, entity := range entities {
		history[i] = &model.BalanceHistory{
			ID:        strconv.FormatUint(uint64(entity.ID), 10),
			UserID:    entity.UserID,
			Asset:     model.Asset(entity.Asset),
			Free:      entity.Free,
			Locked:    entity.Locked,
			Total:     entity.Total,
			USDValue:  entity.USDValue,
			Timestamp: entity.Timestamp,
		}
	}

	return history, nil
}
</file>

<file path="internal/adapter/persistence/memory/conversation_repository.go">
package memory

import (
	"context"
	"errors"
	"sort"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog"
)

// ConversationMemoryRepository implements the ConversationMemoryRepository interface using in-memory storage
type ConversationMemoryRepository struct {
	conversations map[string]*model.AIConversation
	messages      map[string][]*model.AIMessage
	mu            sync.RWMutex
	logger        zerolog.Logger
}

// NewConversationMemoryRepository creates a new ConversationMemoryRepository
func NewConversationMemoryRepository(logger zerolog.Logger) port.ConversationMemoryRepository {
	return &ConversationMemoryRepository{
		conversations: make(map[string]*model.AIConversation),
		messages:      make(map[string][]*model.AIMessage),
		logger:        logger.With().Str("component", "conversation_memory_repository").Logger(),
	}
}

// SaveConversation saves a conversation
func (r *ConversationMemoryRepository) SaveConversation(ctx context.Context, conversation *model.AIConversation) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	// If the conversation doesn't have an ID, generate one
	if conversation.ID == "" {
		conversation.ID = uuid.New().String()
	}

	// Update timestamps
	if conversation.CreatedAt.IsZero() {
		conversation.CreatedAt = time.Now()
	}
	conversation.UpdatedAt = time.Now()

	// Save the conversation
	r.conversations[conversation.ID] = conversation

	// Initialize messages array if it doesn't exist
	if _, exists := r.messages[conversation.ID]; !exists {
		r.messages[conversation.ID] = make([]*model.AIMessage, 0)
	}

	// Save any messages in the conversation
	for i := range conversation.Messages {
		msg := conversation.Messages[i]
		if msg.ID == "" {
			msg.ID = uuid.New().String()
		}
		msg.ConversationID = conversation.ID
		if msg.Timestamp.IsZero() {
			msg.Timestamp = time.Now()
		}

		// Check if message already exists
		exists := false
		for _, existingMsg := range r.messages[conversation.ID] {
			if existingMsg.ID == msg.ID {
				exists = true
				break
			}
		}

		// Add message if it doesn't exist
		if !exists {
			r.messages[conversation.ID] = append(r.messages[conversation.ID], &msg)
		}
	}

	r.logger.Debug().Str("conversation_id", conversation.ID).Msg("Saved conversation")
	return nil
}

// GetConversation retrieves a conversation by ID
func (r *ConversationMemoryRepository) GetConversation(ctx context.Context, id string) (*model.AIConversation, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	conversation, exists := r.conversations[id]
	if !exists {
		return nil, errors.New("conversation not found")
	}

	// Create a copy of the conversation
	conversationCopy := *conversation

	// Get messages for the conversation
	messages, exists := r.messages[id]
	if exists {
		// Create copies of messages
		conversationCopy.Messages = make([]model.AIMessage, len(messages))
		for i, msg := range messages {
			conversationCopy.Messages[i] = *msg
		}

		// Sort messages by timestamp
		sort.Slice(conversationCopy.Messages, func(i, j int) bool {
			return conversationCopy.Messages[i].Timestamp.Before(conversationCopy.Messages[j].Timestamp)
		})
	} else {
		conversationCopy.Messages = make([]model.AIMessage, 0)
	}

	return &conversationCopy, nil
}

// ListConversations lists conversations for a user
func (r *ConversationMemoryRepository) ListConversations(ctx context.Context, userID string, limit, offset int) ([]*model.AIConversation, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	// Find conversations for the user
	var conversations []*model.AIConversation
	for _, conversation := range r.conversations {
		if conversation.UserID == userID {
			// Create a copy of the conversation
			conversationCopy := *conversation
			conversationCopy.Messages = make([]model.AIMessage, 0) // Don't include messages in the list
			conversations = append(conversations, &conversationCopy)
		}
	}

	// Sort conversations by updated_at (newest first)
	sort.Slice(conversations, func(i, j int) bool {
		return conversations[i].UpdatedAt.After(conversations[j].UpdatedAt)
	})

	// Apply pagination
	if offset >= len(conversations) {
		return []*model.AIConversation{}, nil
	}

	end := offset + limit
	if end > len(conversations) {
		end = len(conversations)
	}

	return conversations[offset:end], nil
}

// SaveMessage saves a message to a conversation
func (r *ConversationMemoryRepository) SaveMessage(ctx context.Context, message *model.AIMessage) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Check if the conversation exists
	if _, exists := r.conversations[message.ConversationID]; !exists {
		return errors.New("conversation not found")
	}

	// If the message doesn't have an ID, generate one
	if message.ID == "" {
		message.ID = uuid.New().String()
	}

	// Set timestamp if not set
	if message.Timestamp.IsZero() {
		message.Timestamp = time.Now()
	}

	// Initialize messages array if it doesn't exist
	if _, exists := r.messages[message.ConversationID]; !exists {
		r.messages[message.ConversationID] = make([]*model.AIMessage, 0)
	}

	// Check if message already exists
	for i, existingMsg := range r.messages[message.ConversationID] {
		if existingMsg.ID == message.ID {
			// Update existing message
			r.messages[message.ConversationID][i] = message
			r.logger.Debug().Str("message_id", message.ID).Msg("Updated message")
			return nil
		}
	}

	// Add new message
	r.messages[message.ConversationID] = append(r.messages[message.ConversationID], message)

	// Update conversation's updated_at timestamp
	if conversation, exists := r.conversations[message.ConversationID]; exists {
		conversation.UpdatedAt = time.Now()
	}

	r.logger.Debug().Str("message_id", message.ID).Str("conversation_id", message.ConversationID).Msg("Saved message")
	return nil
}

// GetMessages retrieves messages for a conversation
func (r *ConversationMemoryRepository) GetMessages(ctx context.Context, conversationID string, limit, offset int) ([]*model.AIMessage, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	// Check if the conversation exists
	if _, exists := r.conversations[conversationID]; !exists {
		return nil, errors.New("conversation not found")
	}

	// Get messages for the conversation
	messages, exists := r.messages[conversationID]
	if !exists {
		return []*model.AIMessage{}, nil
	}

	// Create copies of messages
	messagesCopy := make([]*model.AIMessage, len(messages))
	for i, msg := range messages {
		msgCopy := *msg
		messagesCopy[i] = &msgCopy
	}

	// Sort messages by timestamp
	sort.Slice(messagesCopy, func(i, j int) bool {
		return messagesCopy[i].Timestamp.Before(messagesCopy[j].Timestamp)
	})

	// Apply pagination
	if offset >= len(messagesCopy) {
		return []*model.AIMessage{}, nil
	}

	end := offset + limit
	if end > len(messagesCopy) {
		end = len(messagesCopy)
	}

	return messagesCopy[offset:end], nil
}

// DeleteConversation deletes a conversation
func (r *ConversationMemoryRepository) DeleteConversation(ctx context.Context, id string) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Check if the conversation exists
	if _, exists := r.conversations[id]; !exists {
		return errors.New("conversation not found")
	}

	// Delete the conversation
	delete(r.conversations, id)

	// Delete messages for the conversation
	delete(r.messages, id)

	r.logger.Debug().Str("conversation_id", id).Msg("Deleted conversation")
	return nil
}
</file>

<file path="internal/apperror/errors.go">
package apperror

import (
	"errors"
	"fmt"
	"net/http"
)

// AppError represents an application-specific error
type AppError struct {
	StatusCode int         `json:"-"`
	Code       string      `json:"code"`
	Message    string      `json:"message"`
	Details    interface{} `json:"details,omitempty"`
	Err        error       `json:"-"`
}

// Error returns the error message
func (e *AppError) Error() string {
	if e.Err != nil {
		return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.Err)
	}
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// Unwrap returns the wrapped error
func (e *AppError) Unwrap() error {
	return e.Err
}

// ToResponse returns a map suitable for JSON response
func (e *AppError) ToResponse() map[string]interface{} {
	resp := map[string]interface{}{
		"error": map[string]interface{}{
			"code":    e.Code,
			"message": e.Message,
		},
	}

	if e.Details != nil {
		resp["error"].(map[string]interface{})["details"] = e.Details
	}

	return resp
}

// Is checks if the target error is an AppError with the same code
func (e *AppError) Is(target error) bool {
	var appErr *AppError
	if !errors.As(target, &appErr) {
		return false
	}
	return appErr.Code == e.Code
}

// Common error types
var (
	ErrInvalidInput    = &AppError{StatusCode: http.StatusBadRequest, Code: "INVALID_INPUT", Message: "Invalid input provided"}
	ErrNotFound        = &AppError{StatusCode: http.StatusNotFound, Code: "NOT_FOUND", Message: "Resource not found"}
	ErrInternal        = &AppError{StatusCode: http.StatusInternalServerError, Code: "INTERNAL_ERROR", Message: "Internal server error"}
	ErrUnauthorized    = &AppError{StatusCode: http.StatusUnauthorized, Code: "UNAUTHORIZED", Message: "Unauthorized"}
	ErrForbidden       = &AppError{StatusCode: http.StatusForbidden, Code: "FORBIDDEN", Message: "Forbidden"}
	ErrConflict        = &AppError{StatusCode: http.StatusConflict, Code: "CONFLICT", Message: "Resource conflict"}
	ErrRateLimit       = &AppError{StatusCode: http.StatusTooManyRequests, Code: "RATE_LIMIT", Message: "Rate limit exceeded"}
	ErrExternalService = &AppError{StatusCode: http.StatusServiceUnavailable, Code: "EXTERNAL_SERVICE_ERROR", Message: "External service error"}
	ErrValidation      = &AppError{StatusCode: http.StatusBadRequest, Code: "VALIDATION_ERROR", Message: "Validation error"}
)

// Common error creators

// NewInvalid creates a new invalid input error
func NewInvalid(msg string, details interface{}, err error) *AppError {
	return &AppError{
		StatusCode: http.StatusBadRequest,
		Code:       "INVALID_INPUT",
		Message:    msg,
		Details:    details,
		Err:        err,
	}
}

// NewNotFound creates a new not found error
func NewNotFound(resource string, identifier interface{}, err error) *AppError {
	var msg string
	if identifier != nil {
		msg = fmt.Sprintf("%s with identifier %v not found", resource, identifier)
	} else {
		msg = fmt.Sprintf("%s not found", resource)
	}

	return &AppError{
		StatusCode: http.StatusNotFound,
		Code:       "NOT_FOUND",
		Message:    msg,
		Err:        err,
	}
}

// NewInternal creates a new internal server error
func NewInternal(err error) *AppError {
	return &AppError{
		StatusCode: http.StatusInternalServerError,
		Code:       "INTERNAL_ERROR",
		Message:    "Internal server error",
		Err:        err,
	}
}

// NewUnauthorized creates a new unauthorized error
func NewUnauthorized(msg string, err error) *AppError {
	if msg == "" {
		msg = "Unauthorized"
	}

	return &AppError{
		StatusCode: http.StatusUnauthorized,
		Code:       "UNAUTHORIZED",
		Message:    msg,
		Err:        err,
	}
}

// NewForbidden creates a new forbidden error
func NewForbidden(msg string, err error) *AppError {
	if msg == "" {
		msg = "Forbidden"
	}

	return &AppError{
		StatusCode: http.StatusForbidden,
		Code:       "FORBIDDEN",
		Message:    msg,
		Err:        err,
	}
}

// NewValidation creates a new validation error
func NewValidation(msg string, details interface{}, err error) *AppError {
	if msg == "" {
		msg = "Validation error"
	}

	return &AppError{
		StatusCode: http.StatusBadRequest,
		Code:       "VALIDATION_ERROR",
		Message:    msg,
		Details:    details,
		Err:        err,
	}
}

// NewExternalService creates a new external service error
func NewExternalService(service string, msg string, err error) *AppError {
	if msg == "" {
		msg = fmt.Sprintf("Error communicating with %s", service)
	}

	return &AppError{
		StatusCode: http.StatusServiceUnavailable,
		Code:       "EXTERNAL_SERVICE_ERROR",
		Message:    msg,
		Err:        err,
	}
}

// As is a wrapper for errors.As
func As(err error, target interface{}) bool {
	return errors.As(err, target)
}

// Is is a wrapper for errors.Is
func Is(err, target error) bool {
	return errors.Is(err, target)
}
</file>

<file path="internal/config/config.go">
package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/joho/godotenv"
	"github.com/spf13/viper"
)

// Config holds all configuration settings
type Config struct {
	LogLevel string `mapstructure:"log_level"`
	ENV      string `mapstructure:"env"`
	Server   struct {
		Port         int           `mapstructure:"port"`
		Host         string        `mapstructure:"host"`
		ReadTimeout  time.Duration `mapstructure:"read_timeout"`
		WriteTimeout time.Duration `mapstructure:"write_timeout"`
		IdleTimeout  time.Duration `mapstructure:"idle_timeout"`
	} `mapstructure:"server"`
	Database struct {
		Driver   string `mapstructure:"driver"`
		Path     string `mapstructure:"path"`
		Host     string `mapstructure:"host"`
		Port     int    `mapstructure:"port"`
		User     string `mapstructure:"user"`
		Password string `mapstructure:"password"`
		Name     string `mapstructure:"name"`
		SSLMode  string `mapstructure:"ssl_mode"`
		Turso    struct {
			Enabled   bool   `mapstructure:"enabled"`
			URL       string `mapstructure:"url"`
			AuthToken string `mapstructure:"auth_token"`
		} `mapstructure:"turso"`
	} `mapstructure:"database"`
	MEXC struct {
		APIKey     string `mapstructure:"api_key"`
		APISecret  string `mapstructure:"api_secret"`
		BaseURL    string `mapstructure:"base_url"`
		WSBaseURL  string `mapstructure:"ws_base_url"`
		UseTestnet bool   `mapstructure:"use_testnet"`
		RateLimit  struct {
			RequestsPerMinute int `mapstructure:"requests_per_minute"`
			BurstSize         int `mapstructure:"burst_size"`
		} `mapstructure:"rate_limit"`
	} `mapstructure:"mexc"`
	AI struct {
		Provider     string  `mapstructure:"provider"`
		APIKey       string  `mapstructure:"api_key"`
		Model        string  `mapstructure:"model"`
		GeminiAPIKey string  `mapstructure:"gemini_api_key"`
		GeminiModel  string  `mapstructure:"gemini_model"`
		SystemPrompt string  `mapstructure:"system_prompt"`
		Temperature  float32 `mapstructure:"temperature"`
		TopP         float32 `mapstructure:"top_p"`
		TopK         int32   `mapstructure:"top_k"`
		MaxTokens    int32   `mapstructure:"max_tokens"`
	} `mapstructure:"ai"`
}

// Load loads configuration from file and environment variables
func Load() (*Config, error) {
	// First load .env file if it exists
	_ = godotenv.Load() // ignore error if .env file doesn't exist

	// Create a new viper instance
	v := viper.New()

	// Set default values
	setDefaults(v)

	// Load config from file
	configFile := getConfigFilePath()
	if configFile != "" {
		v.SetConfigFile(configFile)
		if err := v.ReadInConfig(); err != nil {
			if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
				return nil, fmt.Errorf("error reading config file: %w", err)
			}
			// Config file not found, will use defaults and environment variables
		}
	}

	// Override with environment variables
	v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
	v.AutomaticEnv()

	// Unmarshal config
	var config Config
	if err := v.Unmarshal(&config); err != nil {
		return nil, fmt.Errorf("unable to decode config: %w", err)
	}

	// Validate config
	if err := validateConfig(&config); err != nil {
		return nil, err
	}

	return &config, nil
}

// setDefaults sets the default values for configuration
func setDefaults(v *viper.Viper) {
	// Server defaults
	v.SetDefault("server.port", 8080)
	v.SetDefault("server.host", "0.0.0.0")
	v.SetDefault("server.read_timeout", 30*time.Second)
	v.SetDefault("server.write_timeout", 30*time.Second)
	v.SetDefault("server.idle_timeout", 60*time.Second)

	// Environment defaults
	v.SetDefault("env", "development")
	v.SetDefault("log_level", "info")

	// Database defaults
	v.SetDefault("database.driver", "sqlite")
	v.SetDefault("database.path", "./data/crypto_bot.db")
	v.SetDefault("database.host", "localhost")
	v.SetDefault("database.port", 5432)
	v.SetDefault("database.name", "crypto_bot")
	v.SetDefault("database.ssl_mode", "disable")
	v.SetDefault("database.turso.enabled", false)

	// MEXC defaults
	v.SetDefault("mexc.base_url", "https://api.mexc.com")
	v.SetDefault("mexc.ws_base_url", "wss://wbs.mexc.com/ws")
	v.SetDefault("mexc.use_testnet", false)
	v.SetDefault("mexc.rate_limit.requests_per_minute", 1200)
	v.SetDefault("mexc.rate_limit.burst_size", 10)

	// AI defaults
	v.SetDefault("ai.provider", "gemini")
	v.SetDefault("ai.model", "gemini-pro")
	v.SetDefault("ai.gemini_model", "gemini-1.5-flash")
	v.SetDefault("ai.system_prompt", "You are a crypto trading assistant. You help users understand their portfolio, market trends, and provide trading advice. Keep responses concise and focused on crypto trading.")
	v.SetDefault("ai.temperature", 0.7)
	v.SetDefault("ai.top_p", 0.95)
	v.SetDefault("ai.top_k", 40)
	v.SetDefault("ai.max_tokens", 1024)
}

// validateConfig validates the configuration
func validateConfig(cfg *Config) error {
	// Validate server port
	if cfg.Server.Port < 1 || cfg.Server.Port > 65535 {
		return fmt.Errorf("invalid server port: %d", cfg.Server.Port)
	}

	// Validate required API keys in production
	if cfg.ENV == "production" {
		if cfg.MEXC.APIKey == "" || cfg.MEXC.APISecret == "" {
			return fmt.Errorf("MEXC API credentials are required in production")
		}
	}

	return nil
}

// getConfigFilePath determines the config file path
func getConfigFilePath() string {
	// Check if CONFIG_FILE environment variable is set
	if configFile := os.Getenv("CONFIG_FILE"); configFile != "" {
		return configFile
	}

	// Check for config files in standard locations
	configName := "config"
	if env := os.Getenv("ENV"); env != "" {
		configName = fmt.Sprintf("config.%s", strings.ToLower(env))
	}

	// Check current directory
	if fileExists(configName + ".yaml") {
		return configName + ".yaml"
	}
	if fileExists(configName + ".yml") {
		return configName + ".yml"
	}

	// Check ./configs directory
	configsDir := "./configs"
	if fileExists(filepath.Join(configsDir, configName+".yaml")) {
		return filepath.Join(configsDir, configName+".yaml")
	}
	if fileExists(filepath.Join(configsDir, configName+".yml")) {
		return filepath.Join(configsDir, configName+".yml")
	}

	return ""
}

// fileExists checks if a file exists
func fileExists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}
</file>

<file path="internal/domain/model/market/candle.go">
package market

import "time"

// Interval represents the timeframe of a candle
type Interval string

// Available candle intervals
const (
	Interval1m  Interval = "1m"
	Interval3m  Interval = "3m"
	Interval5m  Interval = "5m"
	Interval15m Interval = "15m"
	Interval30m Interval = "30m"
	Interval1h  Interval = "1h"
	Interval2h  Interval = "2h"
	Interval4h  Interval = "4h"
	Interval6h  Interval = "6h"
	Interval8h  Interval = "8h"
	Interval12h Interval = "12h"
	Interval1d  Interval = "1d"
	Interval3d  Interval = "3d"
	Interval1w  Interval = "1w"
	Interval1M  Interval = "1M"
)

// Candle represents OHLCV (Open, High, Low, Close, Volume) data for a trading pair
type Candle struct {
	// Symbol is the trading pair identifier (e.g., "BTCUSDT")
	Symbol string `json:"symbol"`

	// Exchange indicates which exchange this candle is from
	Exchange string `json:"exchange"`

	// Interval represents the timeframe of this candle
	Interval Interval `json:"interval"`

	// OpenTime is the opening time of this candle
	OpenTime time.Time `json:"openTime"`

	// CloseTime is the closing time of this candle
	CloseTime time.Time `json:"closeTime"`

	// Open is the opening price of this candle
	Open float64 `json:"open"`

	// High is the highest price during this candle period
	High float64 `json:"high"`

	// Low is the lowest price during this candle period
	Low float64 `json:"low"`

	// Close is the closing price of this candle
	Close float64 `json:"close"`

	// Volume is the trading volume in base asset during this candle period
	Volume float64 `json:"volume"`

	// QuoteVolume is the trading volume in quote asset during this candle period
	QuoteVolume float64 `json:"quoteVolume"`

	// TradeCount is the number of trades during this candle period
	TradeCount int64 `json:"tradeCount"`

	// Complete indicates if this candle is completed (true) or still in progress (false)
	Complete bool `json:"complete"`
}
</file>

<file path="internal/domain/model/market/orderbook.go">
package market

import "time"

// OrderBookEntry represents a single price level in the order book
type OrderBookEntry struct {
	Price    float64 `json:"price"`
	Quantity float64 `json:"quantity"`
}

// OrderBook represents the market depth for a trading pair
type OrderBook struct {
	Symbol       string           `json:"symbol"`
	LastUpdated  time.Time        `json:"last_updated"`
	Bids         []OrderBookEntry `json:"bids"`
	Asks         []OrderBookEntry `json:"asks"`
	Exchange     string           `json:"exchange"`
	SequenceNum  int64            `json:"sequence_num,omitempty"` // For consistency checking
	LastUpdateID int64            `json:"last_update_id,omitempty"`
}
</file>

<file path="internal/domain/model/market/symbol.go">
package market

import "time"

// PrecisionConfig defines the precision settings for a trading pair
type PrecisionConfig struct {
	PricePrecision    int `json:"price_precision"`    // Number of decimal places for price
	QuantityPrecision int `json:"quantity_precision"` // Number of decimal places for quantity
	QuotePrecision    int `json:"quote_precision"`    // Number of decimal places for quote asset
}

// FilterConfig defines trading limits for a symbol
type FilterConfig struct {
	MinPrice    float64 `json:"min_price"`
	MaxPrice    float64 `json:"max_price"`
	MinQuantity float64 `json:"min_quantity"`
	MaxQuantity float64 `json:"max_quantity"`
	StepSize    float64 `json:"step_size"` // Minimum quantity increment
	TickSize    float64 `json:"tick_size"` // Minimum price increment
}

// Symbol represents a trading pair on an exchange
type Symbol struct {
	// Symbol is the trading pair identifier (e.g., "BTCUSDT")
	Symbol string `json:"symbol"`

	// BaseAsset is the first part of the pair (e.g., "BTC")
	BaseAsset string `json:"baseAsset"`

	// QuoteAsset is the second part of the pair (e.g., "USDT")
	QuoteAsset string `json:"quoteAsset"`

	// Exchange indicates which exchange this symbol is from
	Exchange string `json:"exchange"`

	// Status indicates if trading is enabled for this symbol
	Status string `json:"status"`

	// MinPrice is the minimum valid price for orders
	MinPrice float64 `json:"minPrice"`

	// MaxPrice is the maximum valid price for orders
	MaxPrice float64 `json:"maxPrice"`

	// PricePrecision is the number of decimal places allowed for price
	PricePrecision int `json:"pricePrecision"`

	// MinQty is the minimum quantity for orders
	MinQty float64 `json:"minQty"`

	// MaxQty is the maximum quantity for orders
	MaxQty float64 `json:"maxQty"`

	// QtyPrecision is the number of decimal places allowed for quantity
	QtyPrecision int `json:"qtyPrecision"`

	// AllowedOrderTypes contains the order types supported for this symbol
	AllowedOrderTypes []string `json:"allowedOrderTypes"`

	// CreatedAt is when this symbol was added to our system
	CreatedAt time.Time `json:"createdAt"`

	// UpdatedAt is when this symbol was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}
</file>

<file path="internal/domain/model/market/ticker.go">
package market

import (
	"time"
)

// Ticker represents market data for a symbol
type Ticker struct {
	ID            string    `json:"id"`
	Symbol        string    `json:"symbol"`
	Price         float64   `json:"price"`
	Volume        float64   `json:"volume"`
	High24h       float64   `json:"high24h"`
	Low24h        float64   `json:"low24h"`
	PriceChange   float64   `json:"priceChange"`
	PercentChange float64   `json:"percentChange"`
	LastUpdated   time.Time `json:"lastUpdated"`
	Exchange      string    `json:"exchange"`
}

// NewTicker creates a new ticker with the current time as LastUpdated
func NewTicker(symbol string, price float64) *Ticker {
	return &Ticker{
		Symbol:      symbol,
		Price:       price,
		LastUpdated: time.Now(),
	}
}
</file>

<file path="internal/domain/model/account.go">
package model

import (
	"time"
)

// Account represents a user's exchange account information
type Account struct {
	UserID      string    `json:"userId"`
	Exchange    string    `json:"exchange"`
	Wallet      *Wallet   `json:"wallet"`
	Permissions []string  `json:"permissions"`
	LastUpdated time.Time `json:"lastUpdated"`
}

// MarketData represents aggregated market data for a trading pair
type MarketData struct {
	Symbol      string      `json:"symbol"`
	Ticker      *Ticker     `json:"ticker"`
	OrderBook   OrderBook   `json:"orderBook"`
	LastTrade   MarketTrade `json:"lastTrade"`
	LastUpdated time.Time   `json:"lastUpdated"`
}

// NewAccount creates a new exchange account for a user
func NewAccount(userID string, exchange string) *Account {
	return &Account{
		UserID:      userID,
		Exchange:    exchange,
		Wallet:      NewWallet(userID),
		Permissions: make([]string, 0),
		LastUpdated: time.Now(),
	}
}

// NewMarketData creates a new market data instance for a symbol
func NewMarketData(symbol string) *MarketData {
	return &MarketData{
		Symbol:      symbol,
		LastUpdated: time.Now(),
	}
}

// UpdateMarketData updates all market data components
func (m *MarketData) UpdateMarketData(ticker *Ticker, orderBook OrderBook, lastTrade MarketTrade) {
	m.Ticker = ticker
	m.OrderBook = orderBook
	m.LastTrade = lastTrade
	m.LastUpdated = time.Now()
}
</file>

<file path="internal/domain/model/ai_types.go">
package model

import (
	"time"
)

// AIMessage represents a single message in a conversation
type AIMessage struct {
	ID            string    `json:"id"`
	ConversationID string   `json:"conversation_id"`
	Role          string    `json:"role"` // "user" or "assistant"
	Content       string    `json:"content"`
	Timestamp     time.Time `json:"timestamp"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// AIConversation represents a conversation with the AI assistant
type AIConversation struct {
	ID          string      `json:"id"`
	UserID      string      `json:"user_id"`
	Title       string      `json:"title"`
	Messages    []AIMessage `json:"messages"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Tags        []string    `json:"tags,omitempty"`
}

// AIFunctionCall represents a function call from the AI
type AIFunctionCall struct {
	Name       string                 `json:"name"`
	Parameters map[string]interface{} `json:"parameters"`
}

// AIFunctionResponse represents a response to a function call
type AIFunctionResponse struct {
	Name   string      `json:"name"`
	Result interface{} `json:"result"`
}

// AIInsight represents an insight generated by the AI
type AIInsight struct {
	ID          string    `json:"id"`
	UserID      string    `json:"user_id"`
	Type        string    `json:"type"` // "portfolio", "market", "opportunity", etc.
	Title       string    `json:"title"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
	Confidence  float64   `json:"confidence"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// AITradeRecommendation represents a trade recommendation from the AI
type AITradeRecommendation struct {
	ID          string    `json:"id"`
	UserID      string    `json:"user_id"`
	Symbol      string    `json:"symbol"`
	Action      string    `json:"action"` // "buy" or "sell"
	Quantity    float64   `json:"quantity"`
	Price       float64   `json:"price,omitempty"`
	Reasoning   string    `json:"reasoning"`
	CreatedAt   time.Time `json:"created_at"`
	ExpiresAt   time.Time `json:"expires_at"`
	Confidence  float64   `json:"confidence"`
	Status      string    `json:"status"` // "pending", "accepted", "rejected", "executed"
}

// AIEmbedding represents a vector embedding for similarity search
type AIEmbedding struct {
	ID        string    `json:"id"`
	SourceID  string    `json:"source_id"` // ID of the message or document
	SourceType string   `json:"source_type"` // "message", "document", etc.
	Vector    []float64 `json:"vector"`
	CreatedAt time.Time `json:"created_at"`
}
</file>

<file path="internal/domain/model/exchange.go">
package model

import (
	"time"
)

// Exchange represents a cryptocurrency exchange
type Exchange struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	URL       string    `json:"url"`
	Active    bool      `json:"active"`
	APIKey    string    `json:"api_key,omitempty"`
	APISecret string    `json:"api_secret,omitempty"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Additional order types extending the basic ones in order.go
const (
	// OrderTypeStopLoss represents a stop loss order
	OrderTypeStopLoss OrderType = "STOP_LOSS"
	// OrderTypeStopLossLimit represents a stop loss limit order
	OrderTypeStopLossLimit OrderType = "STOP_LOSS_LIMIT"
	// OrderTypeTakeProfit represents a take profit order
	OrderTypeTakeProfit OrderType = "TAKE_PROFIT"
	// OrderTypeTakeProfitLimit represents a take profit limit order
	OrderTypeTakeProfitLimit OrderType = "TAKE_PROFIT_LIMIT"
)

// Additional order status extending the basic ones in order.go
const (
	// OrderStatusExpired represents an expired order
	OrderStatusExpired OrderStatus = "EXPIRED"
)

// MarketTicker represents a market ticker for a symbol
type MarketTicker struct {
	Symbol        string    `json:"symbol"`
	ExchangeID    string    `json:"exchange_id"`
	Price         float64   `json:"price"`
	Volume        float64   `json:"volume"`
	High          float64   `json:"high"`
	Low           float64   `json:"low"`
	Change        float64   `json:"change"`
	ChangePercent float64   `json:"change_percent"`
	Bid           float64   `json:"bid"`
	Ask           float64   `json:"ask"`
	LastUpdated   time.Time `json:"last_updated"`
}

// CandleInterval represents the interval of a candle
type CandleInterval string

const (
	// CandleInterval1m represents a 1-minute candle
	CandleInterval1m CandleInterval = "1m"
	// CandleInterval5m represents a 5-minute candle
	CandleInterval5m CandleInterval = "5m"
	// CandleInterval15m represents a 15-minute candle
	CandleInterval15m CandleInterval = "15m"
	// CandleInterval30m represents a 30-minute candle
	CandleInterval30m CandleInterval = "30m"
	// CandleInterval1h represents a 1-hour candle
	CandleInterval1h CandleInterval = "1h"
	// CandleInterval4h represents a 4-hour candle
	CandleInterval4h CandleInterval = "4h"
	// CandleInterval1d represents a 1-day candle
	CandleInterval1d CandleInterval = "1d"
	// CandleInterval1w represents a 1-week candle
	CandleInterval1w CandleInterval = "1w"
	// CandleInterval1M represents a 1-month candle
	CandleInterval1M CandleInterval = "1M"
)

// Candle represents a candlestick for a symbol
type Candle struct {
	Symbol     string         `json:"symbol"`
	ExchangeID string         `json:"exchange_id"`
	Interval   CandleInterval `json:"interval"`
	OpenTime   time.Time      `json:"open_time"`
	CloseTime  time.Time      `json:"close_time"`
	Open       float64        `json:"open"`
	High       float64        `json:"high"`
	Low        float64        `json:"low"`
	Close      float64        `json:"close"`
	Volume     float64        `json:"volume"`
}
</file>

<file path="internal/domain/model/order.go">
package model

import (
	"time"
)

// OrderSide represents the side of an order (buy or sell)
type OrderSide string

// OrderType represents the type of an order
type OrderType string

// OrderStatus represents the status of an order
type OrderStatus string

// TimeInForce represents how long an order will remain active
type TimeInForce string

// Order side constants
const (
	OrderSideBuy  OrderSide = "BUY"
	OrderSideSell OrderSide = "SELL"
)

// Order type constants
const (
	OrderTypeMarket OrderType = "MARKET"
	OrderTypeLimit  OrderType = "LIMIT"
)

// Order status constants
const (
	OrderStatusNew             OrderStatus = "NEW"
	OrderStatusPartiallyFilled OrderStatus = "PARTIALLY_FILLED"
	OrderStatusFilled          OrderStatus = "FILLED"
	OrderStatusCanceled        OrderStatus = "CANCELED"
	OrderStatusRejected        OrderStatus = "REJECTED"
)

// TimeInForce constants
const (
	TimeInForceGTC TimeInForce = "GTC" // Good Till Cancel
	TimeInForceIOC TimeInForce = "IOC" // Immediate Or Cancel
	TimeInForceFOK TimeInForce = "FOK" // Fill Or Kill
)

// Order represents a trading order
type Order struct {
	ID            string      `json:"id"`
	OrderID       string      `json:"order_id"` // Exchange-specific order ID
	ClientOrderID string      `json:"clientOrderId"`
	Symbol        string      `json:"symbol"`
	Side          OrderSide   `json:"side"`
	Type          OrderType   `json:"type"`
	Status        OrderStatus `json:"status"`
	TimeInForce   TimeInForce `json:"timeInForce,omitempty"`
	Price         float64     `json:"price"`
	Quantity      float64     `json:"quantity"`
	ExecutedQty   float64     `json:"executedQty"`
	CreatedAt     time.Time   `json:"createdAt"`
	UpdatedAt     time.Time   `json:"updatedAt"`
}

// OrderRequest represents the data required to create a new order
type OrderRequest struct {
	Symbol        string    `json:"symbol" binding:"required"`
	Side          OrderSide `json:"side" binding:"required,oneof=BUY SELL"`
	Type          OrderType `json:"type" binding:"required,oneof=MARKET LIMIT"`
	Quantity      float64   `json:"quantity" binding:"required,gt=0"`
	Price         float64   `json:"price"`
	ClientOrderID string    `json:"clientOrderId"`
}

// OrderResponse represents the data returned after creating/querying an order
type OrderResponse struct {
	Order
	AvgPrice float64 `json:"avgPrice"`
}

// IsComplete returns true if the order is in a terminal state
func (o *Order) IsComplete() bool {
	return o.Status == OrderStatusFilled ||
		o.Status == OrderStatusCanceled ||
		o.Status == OrderStatusRejected
}

// RemainingQuantity returns the quantity that has not been executed yet
func (o *Order) RemainingQuantity() float64 {
	return o.Quantity - o.ExecutedQty
}
</file>

<file path="internal/domain/model/position.go">
package model

import (
	"time"
)

// PositionSide represents the side of a position (long or short)
type PositionSide string

// PositionStatus represents the status of a position
type PositionStatus string

// PositionType represents the type of a position
type PositionType string

// Position side constants
const (
	PositionSideLong  PositionSide = "LONG"
	PositionSideShort PositionSide = "SHORT"
)

// Position status constants
const (
	PositionStatusOpen   PositionStatus = "OPEN"
	PositionStatusClosed PositionStatus = "CLOSED"
)

// Position type constants
const (
	PositionTypeManual    PositionType = "MANUAL"
	PositionTypeAutomatic PositionType = "AUTOMATIC"
	PositionTypeNewCoin   PositionType = "NEWCOIN"
)

// Position represents a trading position
type Position struct {
	ID              string         `json:"id"`
	Symbol          string         `json:"symbol"`
	Side            PositionSide   `json:"side"`
	Status          PositionStatus `json:"status"`
	Type            PositionType   `json:"type"`
	EntryPrice      float64        `json:"entryPrice"`
	Quantity        float64        `json:"quantity"`
	CurrentPrice    float64        `json:"currentPrice"`
	PnL             float64        `json:"pnl"`
	PnLPercent      float64        `json:"pnlPercent"`
	StopLoss        *float64       `json:"stopLoss,omitempty"`
	TakeProfit      *float64       `json:"takeProfit,omitempty"`
	StrategyID      *string        `json:"strategyId,omitempty"`
	OpenOrderIDs    []string       `json:"openOrderIds,omitempty"`
	EntryOrderIDs   []string       `json:"entryOrderIds"`
	ExitOrderIDs    []string       `json:"exitOrderIds,omitempty"`
	Notes           string         `json:"notes,omitempty"`
	OpenedAt        time.Time      `json:"openedAt"`
	ClosedAt        *time.Time     `json:"closedAt,omitempty"`
	LastUpdatedAt   time.Time      `json:"lastUpdatedAt"`
	MaxDrawdown     float64        `json:"maxDrawdown"`
	MaxProfit       float64        `json:"maxProfit"`
	RiskRewardRatio float64        `json:"riskRewardRatio,omitempty"`
}

// PositionCreateRequest represents data needed to create a position
type PositionCreateRequest struct {
	Symbol     string       `json:"symbol" binding:"required"`
	Side       PositionSide `json:"side" binding:"required,oneof=LONG SHORT"`
	Type       PositionType `json:"type" binding:"required"`
	EntryPrice float64      `json:"entryPrice" binding:"required,gt=0"`
	Quantity   float64      `json:"quantity" binding:"required,gt=0"`
	StopLoss   *float64     `json:"stopLoss"`
	TakeProfit *float64     `json:"takeProfit"`
	StrategyID *string      `json:"strategyId"`
	OrderIDs   []string     `json:"orderIds" binding:"required,min=1"`
	Notes      string       `json:"notes"`
}

// PositionUpdateRequest represents data for updating a position
type PositionUpdateRequest struct {
	CurrentPrice *float64  `json:"currentPrice"`
	StopLoss     *float64  `json:"stopLoss"`
	TakeProfit   *float64  `json:"takeProfit"`
	Notes        *string   `json:"notes"`
	Status       *string   `json:"status"`
	ClosedAt     *string   `json:"closedAt"`
	ExitOrderIDs *[]string `json:"exitOrderIds"`
}

// UpdateCurrentPrice updates the current price and recalculates PnL
func (p *Position) UpdateCurrentPrice(currentPrice float64) {
	p.CurrentPrice = currentPrice

	// Calculate PnL
	if p.Side == PositionSideLong {
		p.PnL = (currentPrice - p.EntryPrice) * p.Quantity
		p.PnLPercent = (currentPrice - p.EntryPrice) / p.EntryPrice * 100
	} else {
		p.PnL = (p.EntryPrice - currentPrice) * p.Quantity
		p.PnLPercent = (p.EntryPrice - currentPrice) / p.EntryPrice * 100
	}

	p.LastUpdatedAt = time.Now()

	// Update max profit/drawdown
	if p.PnL > p.MaxProfit {
		p.MaxProfit = p.PnL
	}

	if p.PnL < 0 && p.PnL < p.MaxDrawdown {
		p.MaxDrawdown = p.PnL
	}
}

// Close closes the position
func (p *Position) Close(exitPrice float64, exitOrderIDs []string) {
	p.Status = PositionStatusClosed
	p.UpdateCurrentPrice(exitPrice)
	now := time.Now()
	p.ClosedAt = &now
	p.ExitOrderIDs = exitOrderIDs
}

// CalculateRiskRewardRatio calculates the risk/reward ratio if stop-loss and take-profit are set
func (p *Position) CalculateRiskRewardRatio() {
	if p.StopLoss == nil || p.TakeProfit == nil {
		p.RiskRewardRatio = 0
		return
	}

	var reward, risk float64

	if p.Side == PositionSideLong {
		reward = (*p.TakeProfit - p.EntryPrice) * p.Quantity
		risk = (p.EntryPrice - *p.StopLoss) * p.Quantity
	} else {
		reward = (p.EntryPrice - *p.TakeProfit) * p.Quantity
		risk = (*p.StopLoss - p.EntryPrice) * p.Quantity
	}

	if risk <= 0 {
		p.RiskRewardRatio = 0
		return
	}

	p.RiskRewardRatio = reward / risk
}
</file>

<file path="internal/domain/model/ticker.go">
package model

import (
	"time"
)

// Ticker represents a market data ticker
type Ticker struct {
	Symbol             string    `json:"symbol"`
	LastPrice          float64   `json:"lastPrice"`
	PriceChange        float64   `json:"priceChange"`
	PriceChangePercent float64   `json:"priceChangePercent"`
	HighPrice          float64   `json:"highPrice"`
	LowPrice           float64   `json:"lowPrice"`
	Volume             float64   `json:"volume"`
	QuoteVolume        float64   `json:"quoteVolume"`
	OpenPrice          float64   `json:"openPrice"`
	PrevClosePrice     float64   `json:"prevClosePrice"`
	BidPrice           float64   `json:"bidPrice"`
	BidQty             float64   `json:"bidQty"`
	AskPrice           float64   `json:"askPrice"`
	AskQty             float64   `json:"askQty"`
	Count              int64     `json:"count"`
	Timestamp          time.Time `json:"timestamp"`
}

// KlineInterval represents a kline/candlestick interval
type KlineInterval string

// Common kline intervals
const (
	KlineInterval1m  KlineInterval = "1m"
	KlineInterval3m  KlineInterval = "3m"
	KlineInterval5m  KlineInterval = "5m"
	KlineInterval15m KlineInterval = "15m"
	KlineInterval30m KlineInterval = "30m"
	KlineInterval1h  KlineInterval = "1h"
	KlineInterval2h  KlineInterval = "2h"
	KlineInterval4h  KlineInterval = "4h"
	KlineInterval6h  KlineInterval = "6h"
	KlineInterval8h  KlineInterval = "8h"
	KlineInterval12h KlineInterval = "12h"
	KlineInterval1d  KlineInterval = "1d"
	KlineInterval3d  KlineInterval = "3d"
	KlineInterval1w  KlineInterval = "1w"
	KlineInterval1M  KlineInterval = "1M"
)

// Kline represents a candlestick/kline data point
type Kline struct {
	Symbol      string        `json:"symbol"`
	Interval    KlineInterval `json:"interval"`
	OpenTime    time.Time     `json:"openTime"`
	CloseTime   time.Time     `json:"closeTime"`
	Open        float64       `json:"open"`
	High        float64       `json:"high"`
	Low         float64       `json:"low"`
	Close       float64       `json:"close"`
	Volume      float64       `json:"volume"`
	QuoteVolume float64       `json:"quoteVolume"`
	TradeCount  int64         `json:"tradeCount"`
	IsClosed    bool          `json:"isClosed"`
}

// NewCoin represents a newly listed coin on the exchange
type NewCoin struct {
	Symbol      string    `json:"symbol"`
	BaseAsset   string    `json:"baseAsset"`
	QuoteAsset  string    `json:"quoteAsset"`
	Status      string    `json:"status"` // "0" = coming soon, "1" = tradable
	ListingTime time.Time `json:"listingTime"`
	DetectedAt  time.Time `json:"detectedAt"`
}

// OrderBook represents an order book snapshot
type OrderBook struct {
	Symbol       string           `json:"symbol"`
	LastUpdateID int64            `json:"lastUpdateId"`
	Bids         []OrderBookEntry `json:"bids"`
	Asks         []OrderBookEntry `json:"asks"`
	Timestamp    time.Time        `json:"timestamp"`
}

// OrderBookEntry represents a single order book entry (price level)
type OrderBookEntry struct {
	Price    float64 `json:"price"`
	Quantity float64 `json:"quantity"`
}

// MarketTrade represents a public trade reported by the exchange
type MarketTrade struct {
	ID            int64     `json:"id"`
	Symbol        string    `json:"symbol"`
	Price         float64   `json:"price"`
	Quantity      float64   `json:"quantity"`
	QuoteQuantity float64   `json:"quoteQuantity"`
	Time          time.Time `json:"time"`
	IsBuyerMaker  bool      `json:"isBuyerMaker"`
}

// TickerCache is used to store multiple tickers for quick access
type TickerCache struct {
	Tickers    map[string]*Ticker // Symbol -> Ticker
	LastUpdate time.Time
}

// NewTickerCache creates a new ticker cache
func NewTickerCache() *TickerCache {
	return &TickerCache{
		Tickers:    make(map[string]*Ticker),
		LastUpdate: time.Now(),
	}
}

// UpdateTicker updates or adds a ticker to the cache
func (c *TickerCache) UpdateTicker(ticker *Ticker) {
	c.Tickers[ticker.Symbol] = ticker
	c.LastUpdate = time.Now()
}

// GetTicker gets a ticker for a symbol from the cache
func (c *TickerCache) GetTicker(symbol string) *Ticker {
	ticker, exists := c.Tickers[symbol]
	if !exists {
		return nil
	}
	return ticker
}
</file>

<file path="internal/domain/model/wallet.go">
package model

import (
	"time"
)

// BalanceType represents the type of balance (available, frozen, etc.)
type BalanceType string

// Asset represents a cryptocurrency/token asset
type Asset string

// Balance type constants
const (
	BalanceTypeAvailable BalanceType = "AVAILABLE"
	BalanceTypeFrozen    BalanceType = "FROZEN"
	BalanceTypeTotal     BalanceType = "TOTAL"
)

// Common assets
const (
	AssetUSDT Asset = "USDT"
	AssetBTC  Asset = "BTC"
	AssetETH  Asset = "ETH"
)

// Balance represents a balance of a specific asset
type Balance struct {
	Asset    Asset   `json:"asset"`
	Free     float64 `json:"free"`     // Available balance
	Locked   float64 `json:"locked"`   // Frozen/locked balance
	Total    float64 `json:"total"`    // Total balance (free + locked)
	USDValue float64 `json:"usdValue"` // USD value of the total balance
}

// Wallet represents a user's wallet with multiple asset balances
type Wallet struct {
	UserID        string             `json:"userId"`
	Balances      map[Asset]*Balance `json:"balances"`
	TotalUSDValue float64            `json:"totalUsdValue"`
	LastUpdated   time.Time          `json:"lastUpdated"`
}

// BalanceHistory represents a historical record of balance for an asset
type BalanceHistory struct {
	ID        string    `json:"id"`
	UserID    string    `json:"userId"`
	Asset     Asset     `json:"asset"`
	Free      float64   `json:"free"`
	Locked    float64   `json:"locked"`
	Total     float64   `json:"total"`
	USDValue  float64   `json:"usdValue"`
	Timestamp time.Time `json:"timestamp"`
}

// NewWallet creates a new wallet for a user
func NewWallet(userID string) *Wallet {
	return &Wallet{
		UserID:      userID,
		Balances:    make(map[Asset]*Balance),
		LastUpdated: time.Now(),
	}
}

// UpdateBalance updates or adds a balance for an asset
func (w *Wallet) UpdateBalance(asset Asset, free, locked float64, usdValue float64) {
	balance, exists := w.Balances[asset]

	if !exists {
		balance = &Balance{
			Asset: asset,
		}
		w.Balances[asset] = balance
	}

	balance.Free = free
	balance.Locked = locked
	balance.Total = free + locked
	balance.USDValue = usdValue

	w.recalculateTotalUSDValue()
	w.LastUpdated = time.Now()
}

// GetBalance returns the balance for a specific asset
func (w *Wallet) GetBalance(asset Asset) *Balance {
	balance, exists := w.Balances[asset]
	if !exists {
		return &Balance{
			Asset:    asset,
			Free:     0,
			Locked:   0,
			Total:    0,
			USDValue: 0,
		}
	}

	return balance
}

// HasSufficientBalance checks if there's sufficient free balance for an asset
func (w *Wallet) HasSufficientBalance(asset Asset, requiredAmount float64) bool {
	balance := w.GetBalance(asset)
	return balance.Free >= requiredAmount
}

// recalculateTotalUSDValue recalculates the total USD value of all assets
func (w *Wallet) recalculateTotalUSDValue() {
	total := 0.0

	for _, balance := range w.Balances {
		total += balance.USDValue
	}

	w.TotalUSDValue = total
}
</file>

<file path="internal/domain/port/ai_gateway.go">
package port

import (
	"context"

	"github.com/neo/crypto-bot/internal/domain/model"
)

// AIService defines the interface for interacting with AI services
type AIService interface {
	// Chat sends a message to the AI and returns a response
	Chat(ctx context.Context, message string, conversationID string) (*model.AIMessage, error)
	
	// ChatWithHistory sends a message with conversation history to the AI
	ChatWithHistory(ctx context.Context, messages []model.AIMessage) (*model.AIMessage, error)
	
	// GenerateInsight generates an insight based on provided data
	GenerateInsight(ctx context.Context, insightType string, data map[string]interface{}) (*model.AIInsight, error)
	
	// GenerateTradeRecommendation generates a trade recommendation
	GenerateTradeRecommendation(ctx context.Context, data map[string]interface{}) (*model.AITradeRecommendation, error)
	
	// ExecuteFunction executes a function call from the AI
	ExecuteFunction(ctx context.Context, functionCall model.AIFunctionCall) (*model.AIFunctionResponse, error)
	
	// GenerateEmbedding generates a vector embedding for a text
	GenerateEmbedding(ctx context.Context, text string) (*model.AIEmbedding, error)
}

// ConversationMemoryRepository defines the interface for storing and retrieving conversations
type ConversationMemoryRepository interface {
	// SaveConversation saves a conversation
	SaveConversation(ctx context.Context, conversation *model.AIConversation) error
	
	// GetConversation retrieves a conversation by ID
	GetConversation(ctx context.Context, id string) (*model.AIConversation, error)
	
	// ListConversations lists conversations for a user
	ListConversations(ctx context.Context, userID string, limit, offset int) ([]*model.AIConversation, error)
	
	// SaveMessage saves a message to a conversation
	SaveMessage(ctx context.Context, message *model.AIMessage) error
	
	// GetMessages retrieves messages for a conversation
	GetMessages(ctx context.Context, conversationID string, limit, offset int) ([]*model.AIMessage, error)
	
	// DeleteConversation deletes a conversation
	DeleteConversation(ctx context.Context, id string) error
}

// EmbeddingRepository defines the interface for storing and retrieving embeddings
type EmbeddingRepository interface {
	// SaveEmbedding saves an embedding
	SaveEmbedding(ctx context.Context, embedding *model.AIEmbedding) error
	
	// FindSimilar finds similar embeddings
	FindSimilar(ctx context.Context, vector []float64, limit int) ([]*model.AIEmbedding, error)
	
	// GetEmbedding retrieves an embedding by source ID and type
	GetEmbedding(ctx context.Context, sourceID, sourceType string) (*model.AIEmbedding, error)
	
	// DeleteEmbedding deletes an embedding
	DeleteEmbedding(ctx context.Context, id string) error
}
</file>

<file path="internal/domain/port/cache.go">
package port

import (
	"context"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model/market"
)

// MarketCache defines the interface for market data caching
type MarketCache interface {
	// Ticker operations
	CacheTicker(ticker *market.Ticker)
	GetTicker(ctx context.Context, exchange, symbol string) (*market.Ticker, bool)
	GetAllTickers(ctx context.Context, exchange string) ([]*market.Ticker, bool)
	GetLatestTickers(ctx context.Context) ([]*market.Ticker, bool)

	// Candle operations
	CacheCandle(candle *market.Candle)
	GetCandle(ctx context.Context, exchange, symbol string, interval market.Interval, openTime time.Time) (*market.Candle, bool)
	GetLatestCandle(ctx context.Context, exchange, symbol string, interval market.Interval) (*market.Candle, bool)

	// OrderBook operations
	CacheOrderBook(orderbook *market.OrderBook)
	GetOrderBook(ctx context.Context, exchange, symbol string) (*market.OrderBook, bool)

	// Cache management
	Clear()
	SetTickerExpiry(d time.Duration)
	SetCandleExpiry(d time.Duration)
	SetOrderbookExpiry(d time.Duration)
	StartCleanupTask(ctx context.Context, interval time.Duration)
}

// Cache provides a generic caching interface for any type
type Cache[T any] interface {
	// Get retrieves the cached value if it exists and is not expired
	Get() (*T, bool)

	// Set stores a value in the cache with the configured TTL
	Set(value *T)

	// GetOrSet retrieves the cached value if valid, or sets it using the provided function
	GetOrSet(fetchFn func() (*T, error)) (*T, error)

	// Invalidate clears the cached value
	Invalidate()

	// UpdateTTL changes the TTL for the cache
	UpdateTTL(ttl time.Duration)
}
</file>

<file path="internal/domain/port/gateway.go">
package port

import (
	"context"

	"github.com/neo/crypto-bot/internal/domain/model"
)

// MexcAPI defines the interface for interacting with the MEXC cryptocurrency exchange API
type MexcAPI interface {
	// GetAccount retrieves account information from MEXC
	GetAccount(ctx context.Context) (*model.Wallet, error)

	// GetMarketData retrieves market data for a symbol
	GetMarketData(ctx context.Context, symbol string) (*model.Ticker, error)

	// GetKlines retrieves kline (candlestick) data for a symbol
	GetKlines(ctx context.Context, symbol string, interval model.KlineInterval, limit int) ([]*model.Kline, error)

	// GetOrderBook retrieves the order book for a symbol
	GetOrderBook(ctx context.Context, symbol string, limit int) (*model.OrderBook, error)

	// PlaceOrder places a new order on the exchange
	PlaceOrder(ctx context.Context, symbol string, side model.OrderSide, orderType model.OrderType, quantity float64, price float64, timeInForce model.TimeInForce) (*model.Order, error)

	// CancelOrder cancels an existing order
	CancelOrder(ctx context.Context, symbol string, orderID string) error

	// GetOrderStatus checks the status of an order
	GetOrderStatus(ctx context.Context, symbol string, orderID string) (*model.Order, error)
}
</file>

<file path="internal/domain/port/market_repository.go">
package port

import (
	"context"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model/market"
)

// SymbolRepository handles storage and retrieval of trading pair information
type SymbolRepository interface {
	// Create stores a new Symbol
	Create(ctx context.Context, symbol *market.Symbol) error

	// GetBySymbol returns a Symbol by its symbol string (e.g., "BTCUSDT")
	GetBySymbol(ctx context.Context, symbol string) (*market.Symbol, error)

	// GetByExchange returns all Symbols from a specific exchange
	GetByExchange(ctx context.Context, exchange string) ([]*market.Symbol, error)

	// GetAll returns all available Symbols
	GetAll(ctx context.Context) ([]*market.Symbol, error)

	// Update updates an existing Symbol
	Update(ctx context.Context, symbol *market.Symbol) error

	// Delete removes a Symbol
	Delete(ctx context.Context, symbol string) error
}

// MarketRepository defines methods for storing and retrieving market data
type MarketRepository interface {
	// SaveTicker stores a ticker in the database
	SaveTicker(ctx context.Context, ticker *market.Ticker) error

	// GetTicker retrieves the latest ticker for a symbol from a specific exchange
	GetTicker(ctx context.Context, symbol, exchange string) (*market.Ticker, error)

	// GetAllTickers retrieves all latest tickers from a specific exchange
	GetAllTickers(ctx context.Context, exchange string) ([]*market.Ticker, error)

	// GetTickerHistory retrieves ticker history for a symbol within a time range
	GetTickerHistory(ctx context.Context, symbol, exchange string, start, end time.Time) ([]*market.Ticker, error)

	// SaveCandle stores a candle in the database
	SaveCandle(ctx context.Context, candle *market.Candle) error

	// SaveCandles stores multiple candles in the database
	SaveCandles(ctx context.Context, candles []*market.Candle) error

	// GetCandle retrieves a specific candle for a symbol, interval, and time
	GetCandle(ctx context.Context, symbol, exchange string, interval market.Interval, openTime time.Time) (*market.Candle, error)

	// GetCandles retrieves candles for a symbol within a time range
	GetCandles(ctx context.Context, symbol, exchange string, interval market.Interval, start, end time.Time, limit int) ([]*market.Candle, error)

	// GetLatestCandle retrieves the most recent candle for a symbol and interval
	GetLatestCandle(ctx context.Context, symbol, exchange string, interval market.Interval) (*market.Candle, error)

	// PurgeOldData removes market data older than the specified retention period
	PurgeOldData(ctx context.Context, olderThan time.Time) error

	// GetLatestTickers retrieves the latest tickers for all symbols
	GetLatestTickers(ctx context.Context, limit int) ([]*market.Ticker, error)

	// GetTickersBySymbol retrieves tickers for a specific symbol with optional time range
	GetTickersBySymbol(ctx context.Context, symbol string, limit int) ([]*market.Ticker, error)
}
</file>

<file path="internal/domain/port/repository.go">
package port

import (
	"context"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model"
)

// OrderRepository defines the interface for order persistence operations
type OrderRepository interface {
	Create(ctx context.Context, order *model.Order) error
	GetByID(ctx context.Context, id string) (*model.Order, error)
	GetByClientOrderID(ctx context.Context, clientOrderID string) (*model.Order, error)
	Update(ctx context.Context, order *model.Order) error
	GetBySymbol(ctx context.Context, symbol string, limit, offset int) ([]*model.Order, error)
	GetByUserID(ctx context.Context, userID string, limit, offset int) ([]*model.Order, error)
	GetByStatus(ctx context.Context, status model.OrderStatus, limit, offset int) ([]*model.Order, error)
	Count(ctx context.Context, filters map[string]interface{}) (int64, error)
	Delete(ctx context.Context, id string) error
}

// PositionRepository defines the interface for position persistence operations
type PositionRepository interface {
	Create(ctx context.Context, position *model.Position) error
	GetByID(ctx context.Context, id string) (*model.Position, error)
	Update(ctx context.Context, position *model.Position) error
	GetOpenPositions(ctx context.Context) ([]*model.Position, error)
	GetOpenPositionsBySymbol(ctx context.Context, symbol string) ([]*model.Position, error)
	GetOpenPositionsByType(ctx context.Context, positionType model.PositionType) ([]*model.Position, error)
	GetBySymbol(ctx context.Context, symbol string, limit, offset int) ([]*model.Position, error)
	GetByUserID(ctx context.Context, userID string, limit, offset int) ([]*model.Position, error)
	GetClosedPositions(ctx context.Context, from, to time.Time, limit, offset int) ([]*model.Position, error)
	Count(ctx context.Context, filters map[string]interface{}) (int64, error)
	Delete(ctx context.Context, id string) error
}

// WalletRepository defines the interface for wallet persistence operations
type WalletRepository interface {
	Save(ctx context.Context, wallet *model.Wallet) error
	GetByUserID(ctx context.Context, userID string) (*model.Wallet, error)
	SaveBalanceHistory(ctx context.Context, history *model.BalanceHistory) error
	GetBalanceHistory(ctx context.Context, userID string, asset model.Asset, from, to time.Time) ([]*model.BalanceHistory, error)
}

// NewCoinRepository defines the interface for new coin persistence operations
type NewCoinRepository interface {
	Save(ctx context.Context, newCoin *model.NewCoin) error
	GetBySymbol(ctx context.Context, symbol string) (*model.NewCoin, error)
	GetRecent(ctx context.Context, limit int) ([]*model.NewCoin, error)
	GetByStatus(ctx context.Context, status string) ([]*model.NewCoin, error)
	Update(ctx context.Context, newCoin *model.NewCoin) error
}

// TickerRepository defines the interface for ticker persistence operations
type TickerRepository interface {
	Save(ctx context.Context, ticker *model.Ticker) error
	GetBySymbol(ctx context.Context, symbol string) (*model.Ticker, error)
	GetAll(ctx context.Context) ([]*model.Ticker, error)
	GetRecent(ctx context.Context, limit int) ([]*model.Ticker, error)
	SaveKline(ctx context.Context, kline *model.Kline) error
	GetKlines(ctx context.Context, symbol string, interval model.KlineInterval, from, to time.Time, limit int) ([]*model.Kline, error)
}

// AIConversationRepository defines the interface for AI conversation persistence
type AIConversationRepository interface {
	SaveMessage(ctx context.Context, userID string, message map[string]interface{}) error
	GetConversation(ctx context.Context, userID string, limit int) ([]map[string]interface{}, error)
	ClearConversation(ctx context.Context, userID string) error
}

// StrategyRepository defines the interface for strategy persistence
type StrategyRepository interface {
	SaveConfig(ctx context.Context, strategyID string, config map[string]interface{}) error
	GetConfig(ctx context.Context, strategyID string) (map[string]interface{}, error)
	ListStrategies(ctx context.Context) ([]string, error)
	DeleteStrategy(ctx context.Context, strategyID string) error
}

// NotificationRepository defines the interface for notification persistence
type NotificationRepository interface {
	SavePreferences(ctx context.Context, userID string, preferences map[string]interface{}) error
	GetPreferences(ctx context.Context, userID string) (map[string]interface{}, error)
	SaveNotification(ctx context.Context, notification map[string]interface{}) error
	GetNotifications(ctx context.Context, userID string, limit, offset int) ([]map[string]interface{}, error)
}

// AnalyticsRepository defines the interface for analytics data persistence
type AnalyticsRepository interface {
	SaveMetrics(ctx context.Context, metrics map[string]interface{}) error
	GetMetrics(ctx context.Context, from, to time.Time) ([]map[string]interface{}, error)
	GetPerformanceByStrategy(ctx context.Context, strategyID string, from, to time.Time) (map[string]interface{}, error)
}
</file>

<file path="internal/factory/ai_factory.go">
package factory

import (
	"github.com/neo/crypto-bot/internal/adapter/gateway/ai"
	"github.com/neo/crypto-bot/internal/adapter/http/handler"
	"github.com/neo/crypto-bot/internal/adapter/persistence/memory"
	"github.com/neo/crypto-bot/internal/config"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/neo/crypto-bot/internal/usecase"
	"github.com/rs/zerolog"
)

// AIFactory creates AI-related components
type AIFactory struct {
	config *config.Config
	logger zerolog.Logger
}

// NewAIFactory creates a new AIFactory
func NewAIFactory(config *config.Config, logger zerolog.Logger) *AIFactory {
	return &AIFactory{
		config: config,
		logger: logger.With().Str("component", "ai_factory").Logger(),
	}
}

// CreateAIService creates an AIService based on the configuration
func (f *AIFactory) CreateAIService() (port.AIService, error) {
	// Create AI service based on provider
	switch f.config.AI.Provider {
	case "gemini":
		return ai.NewGeminiAIService(f.config, f.logger)
	default:
		f.logger.Warn().Str("provider", f.config.AI.Provider).Msg("Unknown AI provider, using Gemini")
		return ai.NewGeminiAIService(f.config, f.logger)
	}
}

// CreateConversationMemoryRepository creates a ConversationMemoryRepository
func (f *AIFactory) CreateConversationMemoryRepository() port.ConversationMemoryRepository {
	// For now, we'll use an in-memory repository
	// In a real implementation, this would use a database
	return memory.NewConversationMemoryRepository(f.logger)
}

// CreateEmbeddingRepository creates an EmbeddingRepository
func (f *AIFactory) CreateEmbeddingRepository() port.EmbeddingRepository {
	// For now, we'll return nil
	// In a real implementation, this would use a vector database
	return nil
}

// CreateAIUsecase creates an AIUsecase
func (f *AIFactory) CreateAIUsecase() (*usecase.AIUsecase, error) {
	// Create dependencies
	aiService, err := f.CreateAIService()
	if err != nil {
		return nil, err
	}
	
	conversationMemoryRepo := f.CreateConversationMemoryRepository()
	embeddingRepo := f.CreateEmbeddingRepository()
	
	// Create usecase
	return usecase.NewAIUsecase(aiService, conversationMemoryRepo, embeddingRepo, f.logger), nil
}

// CreateAIHandler creates an AIHandler
func (f *AIFactory) CreateAIHandler() (*handler.AIHandler, error) {
	// Create usecase
	aiUsecase, err := f.CreateAIUsecase()
	if err != nil {
		return nil, err
	}
	
	// Create handler
	return handler.NewAIHandler(aiUsecase, f.logger), nil
}
</file>

<file path="internal/factory/market_factory.go">
package factory

import (
	"time"

	cacheAdapter "github.com/neo/crypto-bot/internal/adapter/cache/memory"
	gormAdapter "github.com/neo/crypto-bot/internal/adapter/persistence/gorm"
	"github.com/neo/crypto-bot/internal/config"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/neo/crypto-bot/internal/usecase"
	"github.com/rs/zerolog"
	"gorm.io/gorm"
)

// MarketFactory creates market data related components
type MarketFactory struct {
	cfg    *config.Config
	logger *zerolog.Logger
	db     *gorm.DB
}

// NewMarketFactory creates a new MarketFactory
func NewMarketFactory(cfg *config.Config, logger *zerolog.Logger, db *gorm.DB) *MarketFactory {
	return &MarketFactory{
		cfg:    cfg,
		logger: logger,
		db:     db,
	}
}

// CreateMarketRepository creates a market data repository
func (f *MarketFactory) CreateMarketRepository() (port.MarketRepository, port.SymbolRepository) {
	repo := gormAdapter.NewMarketRepository(f.db, f.logger)
	// GORM MarketRepository implements both interfaces
	return repo, repo
}

// CreateMarketCache creates a market data cache
func (f *MarketFactory) CreateMarketCache() port.MarketCache {
	// Define default cache TTLs
	tickerTTL := 5 * time.Minute
	candleTTL := 15 * time.Minute
	orderbookTTL := 30 * time.Second

	// Use market config TTLs if configured
	if f.cfg.Cache.TickerTTL > 0 {
		tickerTTL = time.Duration(f.cfg.Cache.TickerTTL) * time.Second
	}
	if f.cfg.Cache.CandleTTL > 0 {
		candleTTL = time.Duration(f.cfg.Cache.CandleTTL) * time.Second
	}
	if f.cfg.Cache.OrderbookTTL > 0 {
		orderbookTTL = time.Duration(f.cfg.Cache.OrderbookTTL) * time.Second
	}

	return cacheAdapter.NewMarketCache(f.logger, tickerTTL, candleTTL, orderbookTTL)
}

// CreateMarketDataUseCase creates the market data use case
func (f *MarketFactory) CreateMarketDataUseCase() (*usecase.MarketDataUseCase, error) {
	marketRepo, symbolRepo := f.CreateMarketRepository()
	cache := f.CreateMarketCache()

	uc := usecase.NewMarketDataUseCase(marketRepo, symbolRepo, cache, f.logger)
	return uc, nil
}
</file>

<file path="internal/platform/logger/logger.go">
package logger

import (
	"io"
	"os"
	"time"

	"github.com/rs/zerolog"
)

// Configure global zerolog settings
func init() {
	zerolog.TimeFieldFormat = time.RFC3339
	zerolog.SetGlobalLevel(zerolog.InfoLevel)
}

// New creates a new zerolog Logger with pretty console output in development
func New(level string) zerolog.Logger {
	// Set the logging level
	setLogLevel(level)

	// Create console writer
	var output io.Writer = os.Stdout
	// If development environment, use pretty console output
	if os.Getenv("ENV") == "development" {
		output = zerolog.ConsoleWriter{
			Out:        os.Stdout,
			TimeFormat: time.RFC3339,
			NoColor:    false,
		}
	}

	// Create the logger
	return zerolog.New(output).With().Timestamp().Caller().Logger()
}

// setLogLevel sets the global log level from a string
func setLogLevel(level string) {
	switch level {
	case "debug":
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	case "info":
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	case "warn":
		zerolog.SetGlobalLevel(zerolog.WarnLevel)
	case "error":
		zerolog.SetGlobalLevel(zerolog.ErrorLevel)
	case "fatal":
		zerolog.SetGlobalLevel(zerolog.FatalLevel)
	case "panic":
		zerolog.SetGlobalLevel(zerolog.PanicLevel)
	default:
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	}
}
</file>

<file path="internal/platform/mexc/apikeystore/keystore_test.go">
package apikeystore

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMemoryKeyStore(t *testing.T) {
	store := NewMemoryKeyStore()

	// Test setting and getting a key
	creds := &APIKeyCredentials{
		APIKey:    "test-api-key",
		SecretKey: "test-secret-key",
	}
	err := store.SetAPIKey("test", creds)
	require.NoError(t, err)

	// Try to get the key
	got, err := store.GetAPIKey("test")
	require.NoError(t, err)
	assert.Equal(t, creds.APIKey, got.APIKey)
	assert.Equal(t, creds.SecretKey, got.SecretKey)

	// Test getting a non-existent key
	_, err = store.GetAPIKey("non-existent")
	assert.ErrorIs(t, err, ErrKeyNotFound)

	// Test deleting a key
	err = store.DeleteAPIKey("test")
	require.NoError(t, err)

	// Verify key was deleted
	_, err = store.GetAPIKey("test")
	assert.ErrorIs(t, err, ErrKeyNotFound)
}

func TestFileKeyStore(t *testing.T) {
	// Create a temporary directory for testing
	tmpDir, err := os.MkdirTemp("", "apikey-test")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	// Create a file store
	filePath := filepath.Join(tmpDir, "keys.dat")
	encryptionKey := make([]byte, 32) // All zeros for testing
	store, err := NewFileKeyStore(filePath, encryptionKey)
	require.NoError(t, err)

	// Test setting and getting a key
	creds := &APIKeyCredentials{
		APIKey:    "file-api-key",
		SecretKey: "file-secret-key",
	}
	err = store.SetAPIKey("file-test", creds)
	require.NoError(t, err)

	// Try to get the key
	got, err := store.GetAPIKey("file-test")
	require.NoError(t, err)
	assert.Equal(t, creds.APIKey, got.APIKey)
	assert.Equal(t, creds.SecretKey, got.SecretKey)

	// Create a new store instance that should load keys from file
	store2, err := NewFileKeyStore(filePath, encryptionKey)
	require.NoError(t, err)

	// Try to get the key from the new store
	got, err = store2.GetAPIKey("file-test")
	require.NoError(t, err)
	assert.Equal(t, creds.APIKey, got.APIKey)
	assert.Equal(t, creds.SecretKey, got.SecretKey)

	// Test deleting a key
	err = store2.DeleteAPIKey("file-test")
	require.NoError(t, err)

	// Verify key was deleted
	_, err = store2.GetAPIKey("file-test")
	assert.ErrorIs(t, err, ErrKeyNotFound)
}

func TestEnvironmentKeyStore(t *testing.T) {
	// Set environment variables for testing
	os.Setenv("TEST_API_KEY_env-test", "env-api-key")
	os.Setenv("TEST_SECRET_KEY_env-test", "env-secret-key")
	defer func() {
		os.Unsetenv("TEST_API_KEY_env-test")
		os.Unsetenv("TEST_SECRET_KEY_env-test")
	}()

	store := NewEnvironmentKeyStore("TEST_API_KEY_", "TEST_SECRET_KEY_")

	// Try to get the key
	got, err := store.GetAPIKey("env-test")
	require.NoError(t, err)
	assert.Equal(t, "env-api-key", got.APIKey)
	assert.Equal(t, "env-secret-key", got.SecretKey)

	// Test getting a non-existent key
	_, err = store.GetAPIKey("non-existent")
	assert.ErrorIs(t, err, ErrKeyNotFound)

	// Test setting a key (should fail)
	err = store.SetAPIKey("env-test", &APIKeyCredentials{})
	assert.Error(t, err)

	// Test deleting a key (should fail)
	err = store.DeleteAPIKey("env-test")
	assert.Error(t, err)
}

func TestCompositeKeyStore(t *testing.T) {
	// Create stores
	memoryStore := NewMemoryKeyStore()
	envStore := NewEnvironmentKeyStore("TEST_API_KEY_", "TEST_SECRET_KEY_")

	// Set environment variables for testing
	os.Setenv("TEST_API_KEY_env-comp-test", "env-comp-api-key")
	os.Setenv("TEST_SECRET_KEY_env-comp-test", "env-comp-secret-key")
	defer func() {
		os.Unsetenv("TEST_API_KEY_env-comp-test")
		os.Unsetenv("TEST_SECRET_KEY_env-comp-test")
	}()

	// Set a key in memory store
	memCreds := &APIKeyCredentials{
		APIKey:    "mem-comp-api-key",
		SecretKey: "mem-comp-secret-key",
	}
	err := memoryStore.SetAPIKey("mem-comp-test", memCreds)
	require.NoError(t, err)

	// Create composite store with memory first, then env
	compositeStore := NewCompositeKeyStore(memoryStore, envStore)

	// Try to get keys from both sources
	gotMem, err := compositeStore.GetAPIKey("mem-comp-test")
	require.NoError(t, err)
	assert.Equal(t, memCreds.APIKey, gotMem.APIKey)
	assert.Equal(t, memCreds.SecretKey, gotMem.SecretKey)

	gotEnv, err := compositeStore.GetAPIKey("env-comp-test")
	require.NoError(t, err)
	assert.Equal(t, "env-comp-api-key", gotEnv.APIKey)
	assert.Equal(t, "env-comp-secret-key", gotEnv.SecretKey)

	// Test setting a key in composite store (should go to memory store)
	newCreds := &APIKeyCredentials{
		APIKey:    "new-comp-api-key",
		SecretKey: "new-comp-secret-key",
	}
	err = compositeStore.SetAPIKey("new-comp-test", newCreds)
	require.NoError(t, err)

	// Check key exists in memory store
	gotNew, err := memoryStore.GetAPIKey("new-comp-test")
	require.NoError(t, err)
	assert.Equal(t, newCreds.APIKey, gotNew.APIKey)
	assert.Equal(t, newCreds.SecretKey, gotNew.SecretKey)
}

func TestBase64KeyStore(t *testing.T) {
	memoryStore := NewMemoryKeyStore()
	base64Store := NewBase64KeyStore(memoryStore)

	// Test setting and getting a key
	creds := &APIKeyCredentials{
		APIKey:    "base64-api-key",
		SecretKey: "base64-secret-key",
	}
	err := base64Store.SetAPIKey("base64-test", creds)
	require.NoError(t, err)

	// Try to get the key
	got, err := base64Store.GetAPIKey("base64-test")
	require.NoError(t, err)
	assert.Equal(t, creds.APIKey, got.APIKey)
	assert.Equal(t, creds.SecretKey, got.SecretKey)

	// Verify underlying store has encoded values
	raw, err := memoryStore.GetAPIKey("base64-test")
	require.NoError(t, err)
	fmt.Println("Encoded API key:", raw.APIKey)
	fmt.Println("Encoded Secret key:", raw.SecretKey)
	assert.NotEqual(t, creds.APIKey, raw.APIKey)
	assert.NotEqual(t, creds.SecretKey, raw.SecretKey)
}
</file>

<file path="internal/platform/mexc/apikeystore/keystore.go">
package apikeystore

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sync"
)

var (
	// ErrKeyNotFound is returned when an API key is not found
	ErrKeyNotFound = errors.New("API key not found")

	// ErrEncryptionKeyRequired is returned when an encryption key is required but not provided
	ErrEncryptionKeyRequired = errors.New("encryption key required")

	// ErrInvalidEncryptionKey is returned when an invalid encryption key is used
	ErrInvalidEncryptionKey = errors.New("invalid encryption key")
)

// APIKeyCredentials represents API key credentials
type APIKeyCredentials struct {
	APIKey    string
	SecretKey string
}

// KeyStore defines the interface for API key storage
type KeyStore interface {
	// GetAPIKey retrieves API key credentials for a given key ID
	GetAPIKey(keyID string) (*APIKeyCredentials, error)

	// SetAPIKey stores API key credentials for a given key ID
	SetAPIKey(keyID string, creds *APIKeyCredentials) error

	// DeleteAPIKey removes API key credentials for a given key ID
	DeleteAPIKey(keyID string) error
}

// MemoryKeyStore implements an in-memory key store
type MemoryKeyStore struct {
	keys  map[string]*APIKeyCredentials
	mutex sync.RWMutex
}

// NewMemoryKeyStore creates a new in-memory key store
func NewMemoryKeyStore() *MemoryKeyStore {
	return &MemoryKeyStore{
		keys: make(map[string]*APIKeyCredentials),
	}
}

// GetAPIKey retrieves API key credentials for a given key ID
func (s *MemoryKeyStore) GetAPIKey(keyID string) (*APIKeyCredentials, error) {
	s.mutex.RLock()
	defer s.mutex.RUnlock()

	creds, exists := s.keys[keyID]
	if !exists {
		return nil, ErrKeyNotFound
	}

	// Return a copy to prevent modification of stored credentials
	return &APIKeyCredentials{
		APIKey:    creds.APIKey,
		SecretKey: creds.SecretKey,
	}, nil
}

// SetAPIKey stores API key credentials for a given key ID
func (s *MemoryKeyStore) SetAPIKey(keyID string, creds *APIKeyCredentials) error {
	if creds == nil {
		return errors.New("credentials cannot be nil")
	}

	s.mutex.Lock()
	defer s.mutex.Unlock()

	// Store a copy to prevent modification of stored credentials
	s.keys[keyID] = &APIKeyCredentials{
		APIKey:    creds.APIKey,
		SecretKey: creds.SecretKey,
	}

	return nil
}

// DeleteAPIKey removes API key credentials for a given key ID
func (s *MemoryKeyStore) DeleteAPIKey(keyID string) error {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	delete(s.keys, keyID)
	return nil
}

// FileKeyStore implements a file-based key store with encryption
type FileKeyStore struct {
	filePath      string
	encryptionKey []byte
	mutex         sync.RWMutex
	keys          map[string]*APIKeyCredentials
}

// NewFileKeyStore creates a new file-based key store
func NewFileKeyStore(filePath string, encryptionKey []byte) (*FileKeyStore, error) {
	if len(encryptionKey) != 32 {
		return nil, errors.New("encryption key must be 32 bytes")
	}

	// Ensure directory exists
	dir := filepath.Dir(filePath)
	if err := os.MkdirAll(dir, 0750); err != nil {
		return nil, fmt.Errorf("failed to create directory: %w", err)
	}

	store := &FileKeyStore{
		filePath:      filePath,
		encryptionKey: encryptionKey,
		keys:          make(map[string]*APIKeyCredentials),
	}

	// Load existing keys if file exists
	if _, err := os.Stat(filePath); err == nil {
		if err := store.load(); err != nil {
			return nil, fmt.Errorf("failed to load API keys from file: %w", err)
		}
	}

	return store, nil
}

// GetAPIKey retrieves API key credentials for a given key ID
func (s *FileKeyStore) GetAPIKey(keyID string) (*APIKeyCredentials, error) {
	s.mutex.RLock()
	defer s.mutex.RUnlock()

	creds, exists := s.keys[keyID]
	if !exists {
		return nil, ErrKeyNotFound
	}

	// Return a copy to prevent modification of stored credentials
	return &APIKeyCredentials{
		APIKey:    creds.APIKey,
		SecretKey: creds.SecretKey,
	}, nil
}

// SetAPIKey stores API key credentials for a given key ID
func (s *FileKeyStore) SetAPIKey(keyID string, creds *APIKeyCredentials) error {
	if creds == nil {
		return errors.New("credentials cannot be nil")
	}

	s.mutex.Lock()
	defer s.mutex.Unlock()

	// Store a copy to prevent modification of stored credentials
	s.keys[keyID] = &APIKeyCredentials{
		APIKey:    creds.APIKey,
		SecretKey: creds.SecretKey,
	}

	// Save to file
	return s.save()
}

// DeleteAPIKey removes API key credentials for a given key ID
func (s *FileKeyStore) DeleteAPIKey(keyID string) error {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	delete(s.keys, keyID)
	return s.save()
}

// load loads API keys from file
func (s *FileKeyStore) load() error {
	data, err := os.ReadFile(s.filePath)
	if err != nil {
		return fmt.Errorf("failed to read file: %w", err)
	}

	// Decrypt data
	decryptedData, err := decrypt(data, s.encryptionKey)
	if err != nil {
		return fmt.Errorf("failed to decrypt data: %w", err)
	}

	// Unmarshal data
	var keys map[string]*APIKeyCredentials
	if err := json.Unmarshal(decryptedData, &keys); err != nil {
		return fmt.Errorf("failed to unmarshal data: %w", err)
	}

	s.keys = keys
	return nil
}

// save saves API keys to file
func (s *FileKeyStore) save() error {
	// Marshal data
	data, err := json.Marshal(s.keys)
	if err != nil {
		return fmt.Errorf("failed to marshal data: %w", err)
	}

	// Encrypt data
	encryptedData, err := encrypt(data, s.encryptionKey)
	if err != nil {
		return fmt.Errorf("failed to encrypt data: %w", err)
	}

	// Write to file (use temporary file and rename for atomicity)
	tempFile := s.filePath + ".tmp"
	if err := os.WriteFile(tempFile, encryptedData, 0600); err != nil {
		return fmt.Errorf("failed to write temporary file: %w", err)
	}

	if err := os.Rename(tempFile, s.filePath); err != nil {
		return fmt.Errorf("failed to rename temporary file: %w", err)
	}

	return nil
}

// encrypt encrypts data using AES-GCM
func encrypt(data, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	ciphertext := gcm.Seal(nonce, nonce, data, nil)
	return ciphertext, nil
}

// decrypt decrypts data using AES-GCM
func decrypt(data, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	if len(data) < gcm.NonceSize() {
		return nil, errors.New("ciphertext too short")
	}

	nonce, ciphertext := data[:gcm.NonceSize()], data[gcm.NonceSize():]
	return gcm.Open(nil, nonce, ciphertext, nil)
}

// EnvironmentKeyStore implements a key store that loads keys from environment variables
type EnvironmentKeyStore struct {
	apiKeyPrefix    string
	secretKeyPrefix string
}

// NewEnvironmentKeyStore creates a new environment variable key store
func NewEnvironmentKeyStore(apiKeyPrefix, secretKeyPrefix string) *EnvironmentKeyStore {
	return &EnvironmentKeyStore{
		apiKeyPrefix:    apiKeyPrefix,
		secretKeyPrefix: secretKeyPrefix,
	}
}

// GetAPIKey retrieves API key credentials for a given key ID
func (s *EnvironmentKeyStore) GetAPIKey(keyID string) (*APIKeyCredentials, error) {
	apiKeyEnv := s.apiKeyPrefix + keyID
	secretKeyEnv := s.secretKeyPrefix + keyID

	apiKey := os.Getenv(apiKeyEnv)
	secretKey := os.Getenv(secretKeyEnv)

	if apiKey == "" || secretKey == "" {
		return nil, ErrKeyNotFound
	}

	return &APIKeyCredentials{
		APIKey:    apiKey,
		SecretKey: secretKey,
	}, nil
}

// SetAPIKey is not supported for environment variables
func (s *EnvironmentKeyStore) SetAPIKey(keyID string, creds *APIKeyCredentials) error {
	return errors.New("setting API keys in environment variables is not supported")
}

// DeleteAPIKey is not supported for environment variables
func (s *EnvironmentKeyStore) DeleteAPIKey(keyID string) error {
	return errors.New("deleting API keys from environment variables is not supported")
}

// CompositeKeyStore implements a key store that tries multiple key stores in sequence
type CompositeKeyStore struct {
	stores []KeyStore
}

// NewCompositeKeyStore creates a new composite key store
func NewCompositeKeyStore(stores ...KeyStore) *CompositeKeyStore {
	return &CompositeKeyStore{
		stores: stores,
	}
}

// GetAPIKey retrieves API key credentials for a given key ID
func (s *CompositeKeyStore) GetAPIKey(keyID string) (*APIKeyCredentials, error) {
	for _, store := range s.stores {
		creds, err := store.GetAPIKey(keyID)
		if err == nil {
			return creds, nil
		}
		if !errors.Is(err, ErrKeyNotFound) {
			return nil, err
		}
	}
	return nil, ErrKeyNotFound
}

// SetAPIKey stores API key credentials for a given key ID
func (s *CompositeKeyStore) SetAPIKey(keyID string, creds *APIKeyCredentials) error {
	if len(s.stores) == 0 {
		return errors.New("no key stores available")
	}
	// Set in the first store (primary)
	return s.stores[0].SetAPIKey(keyID, creds)
}

// DeleteAPIKey removes API key credentials for a given key ID
func (s *CompositeKeyStore) DeleteAPIKey(keyID string) error {
	var lastErr error
	for _, store := range s.stores {
		if err := store.DeleteAPIKey(keyID); err != nil {
			lastErr = err
		}
	}
	return lastErr
}

// Base64KeyStore implements a key store that encodes/decodes keys in base64
type Base64KeyStore struct {
	store KeyStore
}

// NewBase64KeyStore creates a new base64 key store
func NewBase64KeyStore(store KeyStore) *Base64KeyStore {
	return &Base64KeyStore{
		store: store,
	}
}

// GetAPIKey retrieves API key credentials for a given key ID
func (s *Base64KeyStore) GetAPIKey(keyID string) (*APIKeyCredentials, error) {
	creds, err := s.store.GetAPIKey(keyID)
	if err != nil {
		return nil, err
	}

	apiKey, err := base64.StdEncoding.DecodeString(creds.APIKey)
	if err != nil {
		return nil, fmt.Errorf("failed to decode API key: %w", err)
	}

	secretKey, err := base64.StdEncoding.DecodeString(creds.SecretKey)
	if err != nil {
		return nil, fmt.Errorf("failed to decode secret key: %w", err)
	}

	return &APIKeyCredentials{
		APIKey:    string(apiKey),
		SecretKey: string(secretKey),
	}, nil
}

// SetAPIKey stores API key credentials for a given key ID
func (s *Base64KeyStore) SetAPIKey(keyID string, creds *APIKeyCredentials) error {
	encodedCreds := &APIKeyCredentials{
		APIKey:    base64.StdEncoding.EncodeToString([]byte(creds.APIKey)),
		SecretKey: base64.StdEncoding.EncodeToString([]byte(creds.SecretKey)),
	}
	return s.store.SetAPIKey(keyID, encodedCreds)
}

// DeleteAPIKey removes API key credentials for a given key ID
func (s *Base64KeyStore) DeleteAPIKey(keyID string) error {
	return s.store.DeleteAPIKey(keyID)
}
</file>

<file path="internal/platform/mexc/rest/api_test.go">
package rest

import (
	"context"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestClient provides a test client with a mock server
func setupTestClient(handler http.Handler) (*Client, *httptest.Server, func()) {
	// Create a test server
	server := httptest.NewServer(handler)

	// Create a client that uses the test server URL
	client := NewClient("testApiKey", "testSecretKey", WithBaseURL(server.URL))

	// Return a cleanup function
	cleanup := func() {
		server.Close()
	}

	return client, server, cleanup
}

// mockHandler returns a handler that serves a predefined response
func mockHandler(statusCode int, responseBody string) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Set content type
		w.Header().Set("Content-Type", "application/json")

		// For the test endpoints, we'll just accept the requests without checking auth
		// since we're testing the response parsing, not the authentication

		// Set the status code
		w.WriteHeader(statusCode)

		// Write the response body
		w.Write([]byte(responseBody))
	})
}

func TestGetAccount(t *testing.T) {
	// Sample response from MEXC API documentation
	responseBody := `{
		"makerCommission": 15,
		"takerCommission": 15,
		"buyerCommission": 0,
		"sellerCommission": 0,
		"canTrade": true,
		"canWithdraw": true,
		"canDeposit": true,
		"updateTime": 1641182585000,
		"accountType": "SPOT",
		"balances": [
			{
				"asset": "BTC",
				"free": "0.1",
				"locked": "0.05"
			},
			{
				"asset": "ETH",
				"free": "2.5",
				"locked": "0.0"
			},
			{
				"asset": "USDT",
				"free": "1000.0",
				"locked": "500.0"
			}
		]
	}`

	client, _, cleanup := setupTestClient(mockHandler(http.StatusOK, responseBody))
	defer cleanup()

	// Test GetAccount
	wallet, err := client.GetAccount()

	// Verify results
	require.NoError(t, err)
	require.NotNil(t, wallet)

	// Check if wallet has the correct balances
	assert.NotNil(t, wallet.Wallet)
	assert.Len(t, wallet.Wallet.Balances, 3)
	assert.Equal(t, 0.1, wallet.Wallet.Balances[model.Asset("BTC")].Free)
	assert.Equal(t, 0.05, wallet.Wallet.Balances[model.Asset("BTC")].Locked)
	assert.InDelta(t, 0.15, wallet.Wallet.Balances[model.Asset("BTC")].Total, 0.000001)

	assert.Equal(t, 2.5, wallet.Wallet.Balances[model.Asset("ETH")].Free)
	assert.Equal(t, 0.0, wallet.Wallet.Balances[model.Asset("ETH")].Locked)
	assert.Equal(t, 2.5, wallet.Wallet.Balances[model.Asset("ETH")].Total)

	assert.Equal(t, 1000.0, wallet.Wallet.Balances[model.Asset("USDT")].Free)
	assert.Equal(t, 500.0, wallet.Wallet.Balances[model.Asset("USDT")].Locked)
	assert.Equal(t, 1500.0, wallet.Wallet.Balances[model.Asset("USDT")].Total)
}

func TestGetMarketData(t *testing.T) {
	// Sample response based on MEXC API documentation
	responseBody := `{
		"symbol": "BTCUSDT",
		"priceChange": "100.0",
		"priceChangePercent": "2.5",
		"weightedAvgPrice": "42000.0",
		"prevClosePrice": "41900.0",
		"lastPrice": "42000.0",
		"lastQty": "0.01",
		"bidPrice": "41995.0",
		"bidQty": "1.5",
		"askPrice": "42005.0",
		"askQty": "2.0",
		"openPrice": "41800.0",
		"highPrice": "42200.0",
		"lowPrice": "41700.0",
		"volume": "100.0",
		"quoteVolume": "4200000.0",
		"openTime": 1641182500000,
		"closeTime": 1641182800000,
		"count": 5000
	}`

	client, _, cleanup := setupTestClient(mockHandler(http.StatusOK, responseBody))
	defer cleanup()

	// Test GetMarketData
	marketData, err := client.GetMarketData("BTCUSDT")

	// Verify results
	require.NoError(t, err)
	require.NotNil(t, marketData)

	// Check if market data has the correct values
	assert.Equal(t, "BTCUSDT", marketData.Symbol)

	// Check ticker data
	require.NotNil(t, marketData.Ticker)
	assert.Equal(t, 42000.0, marketData.Ticker.LastPrice)
	assert.Equal(t, 100.0, marketData.Ticker.PriceChange)
	assert.Equal(t, 2.5, marketData.Ticker.PriceChangePercent)
	assert.Equal(t, 42200.0, marketData.Ticker.HighPrice)
	assert.Equal(t, 41700.0, marketData.Ticker.LowPrice)
	assert.Equal(t, 100.0, marketData.Ticker.Volume)
	assert.Equal(t, 4200000.0, marketData.Ticker.QuoteVolume)
	assert.Equal(t, 41995.0, marketData.Ticker.BidPrice)
	assert.Equal(t, 1.5, marketData.Ticker.BidQty)
	assert.Equal(t, 42005.0, marketData.Ticker.AskPrice)
	assert.Equal(t, 2.0, marketData.Ticker.AskQty)
	assert.Equal(t, int64(5000), marketData.Ticker.Count)
}

func TestPlaceOrder(t *testing.T) {
	// Create test server
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Verify request
		assert.Equal(t, http.MethodPost, r.Method)
		assert.Equal(t, "/order", r.URL.Path)

		// Send response
		w.WriteHeader(http.StatusOK)
		fmt.Fprint(w, `{
			"symbol": "BTC_USDT",
			"orderId": 12345,
			"clientOrderId": "test123",
			"transactTime": 1499827319559,
			"price": "0.1",
			"origQty": "1.0",
			"executedQty": "0.0",
			"status": "NEW",
			"timeInForce": "GTC",
			"type": "LIMIT",
			"side": "BUY"
		}`)
	}))
	defer ts.Close()

	// Create client
	client := NewClient("test-api-key", "test-secret-key", WithBaseURL(ts.URL))

	// Test place order
	order, err := client.PlaceOrder(context.Background(),
		"BTC_USDT",
		model.OrderSideBuy,
		model.OrderTypeLimit,
		1.0,
		0.1,
		model.TimeInForceGTC)

	// Verify response
	require.NoError(t, err)
	assert.NotNil(t, order)
	assert.Equal(t, "12345", order.OrderID)
	assert.Equal(t, "test123", order.ClientOrderID)
	assert.Equal(t, model.OrderSideBuy, order.Side)
	assert.Equal(t, model.OrderTypeLimit, order.Type)
	assert.Equal(t, model.OrderStatusNew, order.Status)
}

func TestGetOrderStatus(t *testing.T) {
	// Create test server
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Verify request
		assert.Equal(t, http.MethodGet, r.Method)
		assert.Equal(t, "/order", r.URL.Path)

		// Send response
		w.WriteHeader(http.StatusOK)
		fmt.Fprint(w, `{
			"symbol": "BTC_USDT",
			"orderId": 123456789,
			"clientOrderId": "test123",
			"price": "0.1",
			"origQty": "1.0",
			"executedQty": "0.0",
			"status": "NEW",
			"timeInForce": "GTC",
			"type": "LIMIT",
			"side": "BUY",
			"time": 1499827319559,
			"updateTime": 1499827319559
		}`)
	}))
	defer ts.Close()

	// Create client
	client := NewClient("test-api-key", "test-secret-key", WithBaseURL(ts.URL))

	// Test get order status
	order, err := client.GetOrderStatus(context.Background(), "BTC_USDT", "123456789")

	// Verify response
	require.NoError(t, err)
	assert.NotNil(t, order)
	assert.Equal(t, "123456789", order.OrderID)
	assert.Equal(t, "test123", order.ClientOrderID)
	assert.Equal(t, model.OrderSideBuy, order.Side)
	assert.Equal(t, model.OrderTypeLimit, order.Type)
	assert.Equal(t, model.OrderStatusNew, order.Status)
}

func TestCancelOrder(t *testing.T) {
	// Create test server
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Verify request
		assert.Equal(t, http.MethodDelete, r.Method)
		assert.Equal(t, "/order", r.URL.Path)

		// Send response
		w.WriteHeader(http.StatusOK)
		fmt.Fprint(w, `{
			"symbol": "BTC_USDT",
			"orderId": 123456789,
			"clientOrderId": "test123",
			"price": "0.1",
			"origQty": "1.0",
			"executedQty": "0.0",
			"status": "CANCELED",
			"timeInForce": "GTC",
			"type": "LIMIT",
			"side": "BUY"
		}`)
	}))
	defer ts.Close()

	// Create client
	client := NewClient("test-api-key", "test-secret-key", WithBaseURL(ts.URL))

	// Test cancel order
	err := client.CancelOrder(context.Background(), "BTC_USDT", "123456789")

	// Verify response
	require.NoError(t, err)
	// CancelOrder only returns error, no order object
}

func TestGetOrderBook(t *testing.T) {
	// Sample response based on MEXC API documentation
	responseBody := `{
		"lastUpdateId": 1641183100,
		"bids": [
			["41995.0", "1.5"],
			["41990.0", "2.5"],
			["41985.0", "3.0"]
		],
		"asks": [
			["42005.0", "2.0"],
			["42010.0", "3.0"],
			["42015.0", "1.0"]
		]
	}`

	client, _, cleanup := setupTestClient(mockHandler(http.StatusOK, responseBody))
	defer cleanup()

	// Test GetOrderBook
	orderBook, err := client.GetOrderBook(context.Background(), "BTCUSDT", 10)

	// Verify results
	require.NoError(t, err)
	require.NotNil(t, orderBook)

	// Check if the order book has the correct values
	assert.Equal(t, "BTCUSDT", orderBook.Symbol)
	assert.Equal(t, int64(1641183100), orderBook.LastUpdateID)

	// Check bids
	require.Len(t, orderBook.Bids, 3)
	assert.Equal(t, 41995.0, orderBook.Bids[0].Price)
	assert.Equal(t, 1.5, orderBook.Bids[0].Quantity)
	assert.Equal(t, 41990.0, orderBook.Bids[1].Price)
	assert.Equal(t, 2.5, orderBook.Bids[1].Quantity)
	assert.Equal(t, 41985.0, orderBook.Bids[2].Price)
	assert.Equal(t, 3.0, orderBook.Bids[2].Quantity)

	// Check asks
	require.Len(t, orderBook.Asks, 3)
	assert.Equal(t, 42005.0, orderBook.Asks[0].Price)
	assert.Equal(t, 2.0, orderBook.Asks[0].Quantity)
	assert.Equal(t, 42010.0, orderBook.Asks[1].Price)
	assert.Equal(t, 3.0, orderBook.Asks[1].Quantity)
	assert.Equal(t, 42015.0, orderBook.Asks[2].Price)
	assert.Equal(t, 1.0, orderBook.Asks[2].Quantity)
}

func TestGetKlines(t *testing.T) {
	// Sample response based on MEXC API documentation
	responseBody := `[
		[1641182400000, "41800.0", "41900.0", "41750.0", "41850.0", "10.5", 1641186000000, "440000.0", 100, "5.5", "230000.0", "0"],
		[1641186000000, "41850.0", "42000.0", "41800.0", "42000.0", "15.0", 1641189600000, "630000.0", 150, "8.0", "336000.0", "0"]
	]`

	client, _, cleanup := setupTestClient(mockHandler(http.StatusOK, responseBody))
	defer cleanup()

	// Test GetKlines
	klines, err := client.GetKlines(context.Background(), "BTCUSDT", string(model.KlineInterval1h), 2)

	// Verify results
	require.NoError(t, err)
	require.NotNil(t, klines)
	require.Len(t, klines, 2)

	// Check first kline
	assert.Equal(t, "BTCUSDT", klines[0].Symbol)
	assert.Equal(t, model.KlineInterval1h, klines[0].Interval)
	assert.Equal(t, int64(1641182400000), klines[0].OpenTime.UnixNano()/int64(time.Millisecond))
	assert.Equal(t, 41800.0, klines[0].Open)
	assert.Equal(t, 41900.0, klines[0].High)
	assert.Equal(t, 41750.0, klines[0].Low)
	assert.Equal(t, 41850.0, klines[0].Close)
	assert.Equal(t, 10.5, klines[0].Volume)
	assert.Equal(t, 440000.0, klines[0].QuoteVolume)
	assert.Equal(t, int64(100), klines[0].TradeCount)
	assert.True(t, klines[0].IsClosed)

	// Check second kline
	assert.Equal(t, "BTCUSDT", klines[1].Symbol)
	assert.Equal(t, model.KlineInterval1h, klines[1].Interval)
	assert.Equal(t, int64(1641186000000), klines[1].OpenTime.UnixNano()/int64(time.Millisecond))
	assert.Equal(t, 41850.0, klines[1].Open)
	assert.Equal(t, 42000.0, klines[1].High)
	assert.Equal(t, 41800.0, klines[1].Low)
	assert.Equal(t, 42000.0, klines[1].Close)
	assert.Equal(t, 15.0, klines[1].Volume)
	assert.Equal(t, 630000.0, klines[1].QuoteVolume)
	assert.Equal(t, int64(150), klines[1].TradeCount)
	assert.True(t, klines[1].IsClosed)
}

func TestErrorHandling(t *testing.T) {
	// Test error response
	errorResponse := `{"code": 400, "msg": "Invalid parameter"}`
	client, _, cleanup := setupTestClient(mockHandler(http.StatusBadRequest, errorResponse))
	defer cleanup()

	// Test GetMarketData with error
	_, err := client.GetMarketData("INVALID")

	// Verify error
	require.Error(t, err)
	assert.Contains(t, err.Error(), "API error")
}
</file>

<file path="internal/platform/mexc/rest/api.go">
package rest

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model"
)

// Response types for MEXC API responses
type (
	// AccountResponse represents the response for account information
	AccountResponse struct {
		MakerCommission  int    `json:"makerCommission"`
		TakerCommission  int    `json:"takerCommission"`
		BuyerCommission  int    `json:"buyerCommission"`
		SellerCommission int    `json:"sellerCommission"`
		CanTrade         bool   `json:"canTrade"`
		CanWithdraw      bool   `json:"canWithdraw"`
		CanDeposit       bool   `json:"canDeposit"`
		UpdateTime       int64  `json:"updateTime"`
		AccountType      string `json:"accountType"`
		Balances         []struct {
			Asset  string `json:"asset"`
			Free   string `json:"free"`
			Locked string `json:"locked"`
		} `json:"balances"`
	}

	// TickerResponse represents the ticker information
	TickerResponse struct {
		Symbol             string `json:"symbol"`
		PriceChange        string `json:"priceChange"`
		PriceChangePercent string `json:"priceChangePercent"`
		WeightedAvgPrice   string `json:"weightedAvgPrice"`
		PrevClosePrice     string `json:"prevClosePrice"`
		LastPrice          string `json:"lastPrice"`
		LastQty            string `json:"lastQty"`
		BidPrice           string `json:"bidPrice"`
		BidQty             string `json:"bidQty"`
		AskPrice           string `json:"askPrice"`
		AskQty             string `json:"askQty"`
		OpenPrice          string `json:"openPrice"`
		HighPrice          string `json:"highPrice"`
		LowPrice           string `json:"lowPrice"`
		Volume             string `json:"volume"`
		QuoteVolume        string `json:"quoteVolume"`
		OpenTime           int64  `json:"openTime"`
		CloseTime          int64  `json:"closeTime"`
		Count              int    `json:"count"`
	}

	// KlineResponse represents a single kline/candlestick
	KlineResponse []interface{}

	// OrderBookResponse represents the order book
	OrderBookResponse struct {
		LastUpdateID int64      `json:"lastUpdateId"`
		Bids         [][]string `json:"bids"` // [price, quantity]
		Asks         [][]string `json:"asks"` // [price, quantity]
	}

	// OrderResponse represents the response for placing an order
	OrderResponse struct {
		Symbol              string      `json:"symbol"`
		OrderID             interface{} `json:"orderId"`     // Can be either string or int64
		OrderListID         interface{} `json:"orderListId"` // Can be either string or int64
		ClientOrderID       string      `json:"clientOrderId"`
		TransactTime        int64       `json:"transactTime"`
		Price               string      `json:"price"`
		OrigQty             string      `json:"origQty"`
		ExecutedQty         string      `json:"executedQty"`
		CummulativeQuoteQty string      `json:"cummulativeQuoteQty"`
		Status              string      `json:"status"`
		TimeInForce         string      `json:"timeInForce"`
		Type                string      `json:"type"`
		Side                string      `json:"side"`
		Fills               []struct {
			Price           string `json:"price"`
			Qty             string `json:"qty"`
			Commission      string `json:"commission"`
			CommissionAsset string `json:"commissionAsset"`
		} `json:"fills"`
	}
)

// GetAccount retrieves account information including balances
func (c *Client) GetAccount() (*model.Account, error) {
	endpoint := "/api/v3/account"

	var response struct {
		MakerCommission  int  `json:"makerCommission"`
		TakerCommission  int  `json:"takerCommission"`
		BuyerCommission  int  `json:"buyerCommission"`
		SellerCommission int  `json:"sellerCommission"`
		CanTrade         bool `json:"canTrade"`
		CanWithdraw      bool `json:"canWithdraw"`
		CanDeposit       bool `json:"canDeposit"`
		Balances         []struct {
			Asset  string `json:"asset"`
			Free   string `json:"free"`
			Locked string `json:"locked"`
		} `json:"balances"`
	}

	// Assuming callPrivateAPI is the correct method for signed requests
	data, err := c.callPrivateAPI(context.Background(), "GET", endpoint, nil, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get account info: %w", err)
	}

	if err := json.Unmarshal(data, &response); err != nil {
		return nil, fmt.Errorf("failed to unmarshal account response: %w", err)
	}

	account := model.NewAccount("", "MEXC") // UserID will be set by the application layer

	// Set permissions based on account capabilities
	permissions := make([]string, 0)
	if response.CanTrade {
		permissions = append(permissions, "trade")
	}
	if response.CanWithdraw {
		permissions = append(permissions, "withdraw")
	}
	if response.CanDeposit {
		permissions = append(permissions, "deposit")
	}
	account.Permissions = permissions

	// Update wallet balances
	for _, balance := range response.Balances {
		free, err := strconv.ParseFloat(balance.Free, 64)
		if err != nil {
			continue
		}
		locked, err := strconv.ParseFloat(balance.Locked, 64)
		if err != nil {
			continue
		}

		// Assuming Wallet has an UpdateBalance method with this signature
		account.Wallet.UpdateBalance(model.Asset(balance.Asset), free, locked, 0.0)
	}

	return account, nil
}

// GetMarketData retrieves market data for a symbol
func (c *Client) GetMarketData(symbol string) (*model.MarketData, error) {
	// Create new market data instance
	marketData := model.NewMarketData(symbol)

	// Assuming GetTicker exists and returns *model.Ticker
	ticker, err := c.GetTicker(symbol) // Needs implementation
	if err != nil {
		return nil, fmt.Errorf("failed to get ticker: %w", err)
	}
	marketData.Ticker = ticker

	// Assuming GetOrderBook exists and returns *model.OrderBook
	orderBook, err := c.GetOrderBook(context.Background(), symbol, 20) // Use context
	if err != nil {
		return nil, fmt.Errorf("failed to get order book: %w", err)
	}
	marketData.OrderBook = *orderBook

	// Assuming GetRecentTrades exists and returns []model.MarketTrade
	trades, err := c.GetRecentTrades(symbol, 1) // Needs implementation
	if err == nil && len(trades) > 0 {
		marketData.LastTrade = trades[0]
	}

	return marketData, nil
}

// GetKlines retrieves kline/candlestick data for a symbol
func (c *Client) GetKlines(ctx context.Context, symbol string, interval string, limit int) ([]model.Kline, error) {
	params := map[string]string{
		"symbol":   symbol,
		"interval": interval,
		"limit":    strconv.Itoa(limit),
	}

	data, err := c.callPublicAPI(ctx, "GET", "/api/v3/klines", params)
	if err != nil {
		return nil, fmt.Errorf("failed to get klines: %w", err)
	}

	var klineData [][]interface{}
	if err := json.Unmarshal(data, &klineData); err != nil {
		return nil, fmt.Errorf("failed to unmarshal klines response: %w", err)
	}

	klines := make([]model.Kline, len(klineData))
	for i, k := range klineData {
		openTime := time.UnixMilli(int64(k[0].(float64)))
		closeTime := time.UnixMilli(int64(k[6].(float64)))

		open, _ := strconv.ParseFloat(k[1].(string), 64)
		high, _ := strconv.ParseFloat(k[2].(string), 64)
		low, _ := strconv.ParseFloat(k[3].(string), 64)
		close, _ := strconv.ParseFloat(k[4].(string), 64)
		volume, _ := strconv.ParseFloat(k[5].(string), 64)

		klines[i] = model.Kline{
			Symbol:    symbol,
			Interval:  model.KlineInterval(interval),
			OpenTime:  openTime,
			Open:      open,
			High:      high,
			Low:       low,
			Close:     close,
			Volume:    volume,
			CloseTime: closeTime,
			IsClosed:  true, // MEXC returns only closed klines
		}
	}

	return klines, nil
}

// GetOrderBook retrieves order book data for a symbol
func (c *Client) GetOrderBook(ctx context.Context, symbol string, limit int) (*model.OrderBook, error) {
	params := map[string]string{
		"symbol": symbol,
		"limit":  strconv.Itoa(limit),
	}

	data, err := c.callPublicAPI(ctx, "GET", "/api/v3/depth", params)
	if err != nil {
		return nil, fmt.Errorf("failed to get order book: %w", err)
	}

	var orderBookData struct {
		LastUpdateID int64      `json:"lastUpdateId"`
		Bids         [][]string `json:"bids"`
		Asks         [][]string `json:"asks"`
	}
	if err := json.Unmarshal(data, &orderBookData); err != nil {
		return nil, fmt.Errorf("failed to unmarshal order book response: %w", err)
	}

	bids := make([]model.OrderBookEntry, len(orderBookData.Bids))
	for i, bid := range orderBookData.Bids {
		price, _ := strconv.ParseFloat(bid[0], 64)
		quantity, _ := strconv.ParseFloat(bid[1], 64)
		bids[i] = model.OrderBookEntry{
			Price:    price,
			Quantity: quantity,
		}
	}

	asks := make([]model.OrderBookEntry, len(orderBookData.Asks))
	for i, ask := range orderBookData.Asks {
		price, _ := strconv.ParseFloat(ask[0], 64)
		quantity, _ := strconv.ParseFloat(ask[1], 64)
		asks[i] = model.OrderBookEntry{
			Price:    price,
			Quantity: quantity,
		}
	}

	return &model.OrderBook{
		Symbol:       symbol,
		LastUpdateID: orderBookData.LastUpdateID,
		Bids:         bids,
		Asks:         asks,
	}, nil
}

// PlaceOrder places a new order on the exchange
func (c *Client) PlaceOrder(ctx context.Context, symbol string, side model.OrderSide, orderType model.OrderType, quantity float64, price float64, timeInForce model.TimeInForce) (*model.Order, error) {
	params := map[string]string{
		"symbol":   symbol,
		"side":     string(side),
		"type":     string(orderType),
		"quantity": strconv.FormatFloat(quantity, 'f', -1, 64),
	}

	if orderType == model.OrderTypeLimit {
		params["timeInForce"] = string(timeInForce)
		params["price"] = strconv.FormatFloat(price, 'f', -1, 64)
	}

	data, err := c.callPrivateAPI(ctx, "POST", "/api/v3/order", params, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to place order: %w", err)
	}

	var orderResp struct {
		OrderID       string `json:"orderId"`
		ClientOrderID string `json:"clientOrderId"`
		Symbol        string `json:"symbol"`
		Price         string `json:"price"`
		OrigQty       string `json:"origQty"`
		ExecutedQty   string `json:"executedQty"`
		Status        string `json:"status"`
		Type          string `json:"type"`
		Side          string `json:"side"`
		Time          int64  `json:"time"`
		UpdateTime    int64  `json:"updateTime"`
	}
	if err := json.Unmarshal(data, &orderResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal order response: %w", err)
	}

	price, _ = strconv.ParseFloat(orderResp.Price, 64)
	origQty, _ := strconv.ParseFloat(orderResp.OrigQty, 64)
	executedQty, _ := strconv.ParseFloat(orderResp.ExecutedQty, 64)

	return &model.Order{
		OrderID:       orderResp.OrderID,
		ClientOrderID: orderResp.ClientOrderID,
		Symbol:        orderResp.Symbol,
		Side:          model.OrderSide(strings.ToUpper(orderResp.Side)),
		Type:          model.OrderType(strings.ToUpper(orderResp.Type)),
		Status:        model.OrderStatus(strings.ToUpper(orderResp.Status)),
		Price:         price,
		Quantity:      origQty,
		ExecutedQty:   executedQty,
		CreatedAt:     time.UnixMilli(orderResp.Time),
		UpdatedAt:     time.UnixMilli(orderResp.UpdateTime),
	}, nil
}

// CancelOrder cancels an existing order
func (c *Client) CancelOrder(ctx context.Context, symbol string, orderID string) error {
	params := map[string]string{
		"symbol":  symbol,
		"orderId": orderID,
	}

	_, err := c.callPrivateAPI(ctx, "DELETE", "/api/v3/order", params, nil)
	if err != nil {
		return fmt.Errorf("failed to cancel order: %w", err)
	}

	return nil
}

// GetOrderStatus retrieves the status of an order from the exchange
func (c *Client) GetOrderStatus(ctx context.Context, symbol string, orderID string) (*model.Order, error) {
	params := map[string]string{
		"symbol":  symbol,
		"orderId": orderID,
	}

	data, err := c.callPrivateAPI(ctx, "GET", "/api/v3/order", params, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get order status: %w", err)
	}

	var orderResp struct {
		OrderID       string `json:"orderId"`
		ClientOrderID string `json:"clientOrderId"`
		Symbol        string `json:"symbol"`
		Price         string `json:"price"`
		OrigQty       string `json:"origQty"`
		ExecutedQty   string `json:"executedQty"`
		Status        string `json:"status"`
		Type          string `json:"type"`
		Side          string `json:"side"`
		Time          int64  `json:"time"`
		UpdateTime    int64  `json:"updateTime"`
	}
	if err := json.Unmarshal(data, &orderResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal order response: %w", err)
	}

	price, _ := strconv.ParseFloat(orderResp.Price, 64)
	quantity, _ := strconv.ParseFloat(orderResp.OrigQty, 64)
	executedQty, _ := strconv.ParseFloat(orderResp.ExecutedQty, 64)

	return &model.Order{
		OrderID:       orderResp.OrderID,
		ClientOrderID: orderResp.ClientOrderID,
		Symbol:        orderResp.Symbol,
		Side:          model.OrderSide(strings.ToUpper(orderResp.Side)),
		Type:          model.OrderType(strings.ToUpper(orderResp.Type)),
		Status:        model.OrderStatus(strings.ToUpper(orderResp.Status)),
		Price:         price,
		Quantity:      quantity,
		ExecutedQty:   executedQty,
		CreatedAt:     time.UnixMilli(orderResp.Time),
		UpdatedAt:     time.UnixMilli(orderResp.UpdateTime),
	}, nil
}

// Helper function to parse float64 from interface{}
func parseFloat64(v interface{}) float64 {
	switch v := v.(type) {
	case string:
		f, _ := strconv.ParseFloat(v, 64)
		return f
	case float64:
		return v
	default:
		return 0
	}
}

// Placeholder implementations for missing methods - These need to be fully implemented!
func (c *Client) GetTicker(symbol string) (*model.Ticker, error) {
	// TODO: Implement GetTicker API call
	return nil, errors.New("GetTicker not implemented")
}

func (c *Client) GetRecentTrades(symbol string, limit int) ([]model.MarketTrade, error) {
	// TODO: Implement GetRecentTrades API call
	return nil, errors.New("GetRecentTrades not implemented")
}
</file>

<file path="internal/platform/mexc/rest/client.go">
package rest

import (
	"bytes"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"

	"github.com/neo/crypto-bot/internal/platform/mexc/apikeystore"
	"github.com/neo/crypto-bot/pkg/ratelimiter"
	"github.com/neo/crypto-bot/pkg/retry"
)

const (
	// MEXC API endpoints
	BaseURL     = "https://api.mexc.com"
	SpotBaseURL = BaseURL + "/api/v3"

	// Rate limits (based on MEXC documentation)
	// Spot API rate limits
	SpotPublicRequestsPerMinute  = 1200 // 20 requests per second
	SpotPrivateRequestsPerMinute = 600  // 10 requests per second

	// Default values
	DefaultTimeout = 10 * time.Second
	DefaultKeyID   = "default"

	// Error types
	ErrInvalidResponse    = "invalid_response"
	ErrRateLimit          = "rate_limit"
	ErrAuth               = "authentication"
	ErrNetwork            = "network"
	ErrServer             = "server"
	ErrInvalidRequest     = "invalid_request"
	ErrInsufficientFunds  = "insufficient_funds"
	ErrOrderNotFound      = "order_not_found"
	ErrSymbolNotFound     = "symbol_not_found"
	ErrInvalidOrderStatus = "invalid_order_status"
	ErrUnknown            = "unknown"
)

// APIError represents an error from the MEXC API
type APIError struct {
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	ErrorType  string
	StatusCode int
}

func (e *APIError) Error() string {
	return fmt.Sprintf("MEXC API error: %d - %s (type: %s, HTTP status: %d)",
		e.Code, e.Message, e.ErrorType, e.StatusCode)
}

// IsRetryable determines if an API error is retryable
func (e *APIError) IsRetryable() bool {
	switch e.ErrorType {
	case ErrRateLimit, ErrNetwork, ErrServer:
		return true
	default:
		return false
	}
}

// Client implements the MEXC REST API client
type Client struct {
	httpClient         *http.Client
	baseURL            string
	keyID              string
	keyStore           apikeystore.KeyStore
	publicRateLimiter  *ratelimiter.TokenBucket
	privateRateLimiter *ratelimiter.TokenBucket
	retryOptions       *retry.RetryOptions
}

// ClientOption defines a functional option for configuring the Client
type ClientOption func(*Client)

// WithBaseURL sets a custom base URL for the client
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) {
		c.baseURL = baseURL
	}
}

// WithHTTPClient sets a custom HTTP client
func WithHTTPClient(httpClient *http.Client) ClientOption {
	return func(c *Client) {
		c.httpClient = httpClient
	}
}

// WithKeyID sets the key ID to use from the key store
func WithKeyID(keyID string) ClientOption {
	return func(c *Client) {
		c.keyID = keyID
	}
}

// WithRetryOptions sets custom retry options
func WithRetryOptions(opts *retry.RetryOptions) ClientOption {
	return func(c *Client) {
		c.retryOptions = opts
	}
}

// NewClient creates a new MEXC REST client with direct API key
func NewClient(apiKey, secretKey string, options ...ClientOption) *Client {
	// Create a memory key store with the provided credentials
	keyStore := apikeystore.NewMemoryKeyStore()
	keyStore.SetAPIKey(DefaultKeyID, &apikeystore.APIKeyCredentials{
		APIKey:    apiKey,
		SecretKey: secretKey,
	})

	return NewClientWithKeyStore(keyStore, DefaultKeyID, options...)
}

// NewClientWithKeyStore creates a new client with the provided key store
func NewClientWithKeyStore(keyStore apikeystore.KeyStore, keyID string, options ...ClientOption) *Client {
	client := &Client{
		httpClient: &http.Client{
			Timeout: DefaultTimeout,
		},
		baseURL:  SpotBaseURL,
		keyID:    keyID,
		keyStore: keyStore,
		// Initialize rate limiters (tokens per second)
		publicRateLimiter:  ratelimiter.NewTokenBucket(SpotPublicRequestsPerMinute/60.0, 50),
		privateRateLimiter: ratelimiter.NewTokenBucket(SpotPrivateRequestsPerMinute/60.0, 25),
		// Use default retry options
		retryOptions: retry.DefaultRetryOptions(),
	}

	// Override retry options to handle API errors
	client.retryOptions.RetryIf = func(err error) bool {
		var apiErr *APIError
		if errors.As(err, &apiErr) {
			return apiErr.IsRetryable()
		}
		return retry.IsRetryable(err)
	}

	// Apply options
	for _, option := range options {
		option(client)
	}

	return client
}

// getCredentials retrieves API credentials from the key store
func (c *Client) getCredentials() (*apikeystore.APIKeyCredentials, error) {
	creds, err := c.keyStore.GetAPIKey(c.keyID)
	if err != nil {
		return nil, fmt.Errorf("failed to get API credentials: %w", err)
	}
	return creds, nil
}

// callPublicAPI makes a request to a public API endpoint with retries
func (c *Client) callPublicAPI(ctx context.Context, method, path string, params map[string]string) ([]byte, error) {
	var result []byte
	err := retry.Do(ctx, func() error {
		respBody, err := c.doPublicAPICall(ctx, method, path, params)
		if err != nil {
			// Determine if error is retryable
			var apiErr *APIError
			if errors.As(err, &apiErr) && apiErr.IsRetryable() {
				return retry.NewRetryableError(err)
			}
			return err
		}
		result = respBody
		return nil
	}, c.retryOptions)

	if err != nil {
		return nil, err
	}
	return result, nil
}

// doPublicAPICall makes a single request to a public API endpoint
func (c *Client) doPublicAPICall(ctx context.Context, method, path string, params map[string]string) ([]byte, error) {
	// Apply rate limiting
	c.publicRateLimiter.Wait()

	// Construct URL with query parameters
	url := c.baseURL + path
	req, err := http.NewRequestWithContext(ctx, method, url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Add query parameters
	if params != nil && len(params) > 0 {
		q := req.URL.Query()
		for k, v := range params {
			q.Add(k, v)
		}
		req.URL.RawQuery = q.Encode()
	}

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, &APIError{
			Message:    fmt.Sprintf("failed to execute request: %v", err),
			ErrorType:  ErrNetwork,
			StatusCode: 0,
		}
	}
	defer resp.Body.Close()

	// Read response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, &APIError{
			Message:    fmt.Sprintf("failed to read response body: %v", err),
			ErrorType:  ErrNetwork,
			StatusCode: resp.StatusCode,
		}
	}

	// Check for error response
	if resp.StatusCode != http.StatusOK {
		apiErr := parseAPIError(body, resp.StatusCode)
		return nil, apiErr
	}

	return body, nil
}

// callPrivateAPI makes a request to a private API endpoint requiring authentication with retries
func (c *Client) callPrivateAPI(ctx context.Context, method, path string, params map[string]string, body interface{}) ([]byte, error) {
	var result []byte
	err := retry.Do(ctx, func() error {
		respBody, err := c.doPrivateAPICall(ctx, method, path, params, body)
		if err != nil {
			// Determine if error is retryable
			var apiErr *APIError
			if errors.As(err, &apiErr) && apiErr.IsRetryable() {
				return retry.NewRetryableError(err)
			}
			return err
		}
		result = respBody
		return nil
	}, c.retryOptions)

	if err != nil {
		return nil, err
	}
	return result, nil
}

// doPrivateAPICall makes a single request to a private API endpoint requiring authentication
func (c *Client) doPrivateAPICall(ctx context.Context, method, path string, params map[string]string, body interface{}) ([]byte, error) {
	// Apply rate limiting
	c.privateRateLimiter.Wait()

	// Get API credentials
	creds, err := c.getCredentials()
	if err != nil {
		return nil, &APIError{
			Message:    fmt.Sprintf("failed to get API credentials: %v", err),
			ErrorType:  ErrAuth,
			StatusCode: 0,
		}
	}

	// Add timestamp parameter for signature
	if params == nil {
		params = make(map[string]string)
	}
	timestamp := strconv.FormatInt(time.Now().UnixMilli(), 10)
	params["timestamp"] = timestamp

	// Create request
	url := c.baseURL + path
	var reqBody io.Reader

	// Handle request body for POST/PUT methods
	var jsonBody []byte
	if body != nil && (method == http.MethodPost || method == http.MethodPut) {
		jsonBody, err = json.Marshal(body)
		if err != nil {
			return nil, &APIError{
				Message:    fmt.Sprintf("failed to marshal request body: %v", err),
				ErrorType:  ErrInvalidRequest,
				StatusCode: 0,
			}
		}
		reqBody = bytes.NewReader(jsonBody)
	}

	req, err := http.NewRequestWithContext(ctx, method, url, reqBody)
	if err != nil {
		return nil, &APIError{
			Message:    fmt.Sprintf("failed to create request: %v", err),
			ErrorType:  ErrInvalidRequest,
			StatusCode: 0,
		}
	}

	// Add query parameters and calculate signature
	q := req.URL.Query()
	queryString := ""

	// Add all parameters to query string for signature
	for k, v := range params {
		q.Add(k, v)
	}
	queryString = q.Encode()

	// Calculate HMAC SHA256 signature
	h := hmac.New(sha256.New, []byte(creds.SecretKey))
	h.Write([]byte(queryString))
	signature := hex.EncodeToString(h.Sum(nil))

	// Add signature to query parameters
	q.Add("signature", signature)
	req.URL.RawQuery = q.Encode()

	// Set headers
	req.Header.Set("X-MBX-APIKEY", creds.APIKey)
	if reqBody != nil {
		req.Header.Set("Content-Type", "application/json")
	}

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, &APIError{
			Message:    fmt.Sprintf("failed to execute request: %v", err),
			ErrorType:  ErrNetwork,
			StatusCode: 0,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, &APIError{
			Message:    fmt.Sprintf("failed to read response body: %v", err),
			ErrorType:  ErrNetwork,
			StatusCode: resp.StatusCode,
		}
	}

	// Check for error response
	if resp.StatusCode != http.StatusOK {
		apiErr := parseAPIError(respBody, resp.StatusCode)
		return nil, apiErr
	}

	return respBody, nil
}

// parseAPIError parses an API error response
func parseAPIError(body []byte, statusCode int) *APIError {
	var errResp struct {
		Code    int    `json:"code"`
		Message string `json:"msg"`
	}

	if err := json.Unmarshal(body, &errResp); err != nil {
		// Couldn't parse the error response
		return &APIError{
			Message:    fmt.Sprintf("HTTP error %d: %s", statusCode, string(body)),
			ErrorType:  ErrUnknown,
			StatusCode: statusCode,
		}
	}

	// Determine error type based on code and status
	errorType := ErrUnknown
	switch {
	case statusCode == 429:
		errorType = ErrRateLimit
	case statusCode == 401 || statusCode == 403:
		errorType = ErrAuth
	case statusCode >= 500:
		errorType = ErrServer
	case statusCode >= 400 && statusCode < 500:
		// Map common error codes
		switch errResp.Code {
		case -1121, -1122:
			errorType = ErrInvalidRequest
		case -2010, -2011:
			errorType = ErrInsufficientFunds
		case -2013:
			errorType = ErrOrderNotFound
		case -1100, -1101, -1102, -1103:
			errorType = ErrInvalidRequest
		case -1104, -1105, -1106:
			errorType = ErrInvalidRequest
		}
	}

	return &APIError{
		Code:       errResp.Code,
		Message:    errResp.Message,
		ErrorType:  errorType,
		StatusCode: statusCode,
	}
}
</file>

<file path="internal/platform/mexc/websocket/client.go">
package websocket

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/neo/crypto-bot/pkg/ratelimiter"
)

const (
	// WebSocket endpoints
	mexcWSBaseURL = "wss://wss.mexc.com/ws"

	// Reconnection parameters
	reconnectDelay    = 5 * time.Second
	pingInterval      = 20 * time.Second
	maxReconnectTries = 5

	// Message types
	msgTypePing        = "ping"
	msgTypePong        = "pong"
	msgTypeSubscribe   = "sub"
	msgTypeUnsubscribe = "unsub"
)

// Client represents a WebSocket client for the MEXC exchange
type Client struct {
	conn             *websocket.Conn
	url              string
	subscriptions    map[string]bool
	mu               sync.RWMutex
	isConnected      bool
	reconnectTries   int
	ticker           *model.TickerCache
	ctx              context.Context
	cancel           context.CancelFunc
	messageHandler   func([]byte) error
	reconnectHandler func() error
	rateLimiter      *ratelimiter.TokenBucket
}

// NewClient creates a new WebSocket client
func NewClient(ctx context.Context, ticker *model.TickerCache) *Client {
	// Create a rate limiter with MEXC's WebSocket API limits (10 requests per second)
	limiter := ratelimiter.NewTokenBucket(10, 20)

	ctx, cancel := context.WithCancel(ctx)
	return &Client{
		url:           mexcWSBaseURL,
		subscriptions: make(map[string]bool),
		ticker:        ticker,
		ctx:           ctx,
		cancel:        cancel,
		rateLimiter:   limiter,
	}
}

// Connect establishes a WebSocket connection to MEXC
func (c *Client) Connect() error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if c.isConnected {
		return nil
	}

	dialer := websocket.DefaultDialer
	conn, _, err := dialer.Dial(c.url, nil)
	if err != nil {
		c.reconnectTries++
		return fmt.Errorf("failed to connect to WebSocket: %w", err)
	}

	c.conn = conn
	c.isConnected = true
	c.reconnectTries = 0

	// Start handling messages in a separate goroutine
	go c.handleMessages()

	// Start ping/pong heartbeat to keep connection alive
	go c.keepAlive()

	// Resubscribe to all previous subscriptions after reconnect
	if len(c.subscriptions) > 0 {
		for channel := range c.subscriptions {
			if err := c.sendSubscribeRequest(channel); err != nil {
				log.Printf("Failed to resubscribe to %s: %v", channel, err)
			}
		}
	}

	return nil
}

// Disconnect closes the WebSocket connection
func (c *Client) Disconnect() error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if !c.isConnected || c.conn == nil {
		return nil
	}

	c.cancel()
	c.isConnected = false

	// Close the connection
	err := c.conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
	if err != nil {
		return fmt.Errorf("failed to send close message: %w", err)
	}

	return c.conn.Close()
}

// IsConnected returns the connection status
func (c *Client) IsConnected() bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.isConnected
}

// SubscribeToTicker subscribes to ticker updates for a symbol
func (c *Client) SubscribeToTicker(symbol string) error {
	channel := fmt.Sprintf("spot@public.ticker.v3.api@%s", symbol)
	return c.subscribe(channel)
}

// SubscribeToKlines subscribes to kline updates for a symbol and interval
func (c *Client) SubscribeToKlines(symbol string, interval model.KlineInterval) error {
	intervalStr := ""
	switch interval {
	case model.KlineInterval1m:
		intervalStr = "Min1"
	case model.KlineInterval5m:
		intervalStr = "Min5"
	case model.KlineInterval15m:
		intervalStr = "Min15"
	case model.KlineInterval30m:
		intervalStr = "Min30"
	case model.KlineInterval1h:
		intervalStr = "Min60"
	case model.KlineInterval4h:
		intervalStr = "Hour4"
	case model.KlineInterval1d:
		intervalStr = "Day1"
	case model.KlineInterval1w:
		intervalStr = "Week1"
	default:
		return fmt.Errorf("unsupported kline interval: %s", interval)
	}

	channel := fmt.Sprintf("spot@public.kline.v3.api@%s@%s", symbol, intervalStr)
	return c.subscribe(channel)
}

// SubscribeToOrderBook subscribes to order book updates for a symbol
func (c *Client) SubscribeToOrderBook(symbol string) error {
	channel := fmt.Sprintf("spot@public.bookTicker.v3.api@%s", symbol)
	return c.subscribe(channel)
}

// internal subscribe method to handle subscriptions
func (c *Client) subscribe(channel string) error {
	if err := c.ensureConnected(); err != nil {
		return err
	}

	// Add to subscriptions map
	c.mu.Lock()
	c.subscriptions[channel] = true
	c.mu.Unlock()

	return c.sendSubscribeRequest(channel)
}

// Unsubscribe removes a subscription
func (c *Client) Unsubscribe(channel string) error {
	if err := c.ensureConnected(); err != nil {
		return err
	}

	// Remove from subscriptions map
	c.mu.Lock()
	delete(c.subscriptions, channel)
	c.mu.Unlock()

	return c.sendUnsubscribeRequest(channel)
}

// ensureConnected checks and establishes connection if needed
func (c *Client) ensureConnected() error {
	c.mu.RLock()
	isConnected := c.isConnected
	c.mu.RUnlock()

	if !isConnected {
		return c.Connect()
	}
	return nil
}

// handleMessages processes incoming WebSocket messages
func (c *Client) handleMessages() {
	for {
		select {
		case <-c.ctx.Done():
			return
		default:
			if !c.IsConnected() {
				time.Sleep(100 * time.Millisecond)
				continue
			}

			_, message, err := c.conn.ReadMessage()
			if err != nil {
				log.Printf("Error reading message: %v", err)
				c.handleDisconnect()
				return
			}

			// Handle the received message
			if err := c.processMessage(message); err != nil {
				log.Printf("Error processing message: %v", err)
			}
		}
	}
}

// keepAlive sends ping messages periodically to keep the connection alive
func (c *Client) keepAlive() {
	ticker := time.NewTicker(pingInterval)
	defer ticker.Stop()

	for {
		select {
		case <-c.ctx.Done():
			return
		case <-ticker.C:
			if !c.IsConnected() {
				continue
			}

			pingMsg := map[string]any{"method": msgTypePing}
			if err := c.sendMessage(pingMsg); err != nil {
				log.Printf("Failed to send ping: %v", err)
				c.handleDisconnect()
			}
		}
	}
}

// handleDisconnect manages reconnection logic
func (c *Client) handleDisconnect() {
	c.mu.Lock()
	defer c.mu.Unlock()

	// Already handling reconnect or intentionally disconnected
	if !c.isConnected || c.ctx.Err() != nil {
		return
	}

	c.isConnected = false
	if c.conn != nil {
		_ = c.conn.Close()
		c.conn = nil
	}

	// Try to reconnect
	go func() {
		for c.reconnectTries < maxReconnectTries {
			time.Sleep(reconnectDelay)

			if err := c.Connect(); err != nil {
				log.Printf("Failed to reconnect (attempt %d/%d): %v",
					c.reconnectTries, maxReconnectTries, err)
			} else {
				log.Printf("Successfully reconnected after %d attempts", c.reconnectTries)
				return
			}
		}
		log.Printf("Failed to reconnect after %d attempts, giving up", maxReconnectTries)
	}()
}

// sendMessage sends a message to the WebSocket connection
func (c *Client) sendMessage(msg any) error {
	// Check if we have enough tokens in the rate limiter
	c.rateLimiter.Wait()

	c.mu.RLock()
	defer c.mu.RUnlock()

	if !c.isConnected || c.conn == nil {
		return errors.New("not connected to WebSocket")
	}

	// Send the message
	data, err := json.Marshal(msg)
	if err != nil {
		return fmt.Errorf("failed to marshal message: %w", err)
	}

	if err := c.conn.WriteMessage(websocket.TextMessage, data); err != nil {
		return fmt.Errorf("failed to send message: %w", err)
	}

	return nil
}

// sendSubscribeRequest sends a subscription request
func (c *Client) sendSubscribeRequest(channel string) error {
	msg := map[string]any{
		"method": msgTypeSubscribe,
		"params": []string{channel},
		"id":     time.Now().UnixNano(),
	}
	return c.sendMessage(msg)
}

// sendUnsubscribeRequest sends an unsubscription request
func (c *Client) sendUnsubscribeRequest(channel string) error {
	msg := map[string]any{
		"method": msgTypeUnsubscribe,
		"params": []string{channel},
		"id":     time.Now().UnixNano(),
	}
	return c.sendMessage(msg)
}

// processMessage handles incoming messages based on their type
func (c *Client) processMessage(data []byte) error {
	// Skip empty messages
	if len(data) == 0 {
		return nil
	}

	// Parse the raw message to determine its type
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("failed to parse message: %w", err)
	}

	// Handle pong response
	if _, ok := rawMsg["pong"]; ok {
		return nil
	}

	// Handle data messages
	if chdata, ok := rawMsg["data"]; ok {
		if symbol, ok := rawMsg["symbol"]; ok {
			var symbolStr string
			if err := json.Unmarshal(symbol, &symbolStr); err != nil {
				return fmt.Errorf("failed to parse symbol: %w", err)
			}

			// Determine the channel type
			if _, ok := rawMsg["ticker"]; ok {
				return c.handleTickerUpdate(symbolStr, chdata)
			} else if _, ok := rawMsg["kline"]; ok {
				return c.handleKlineUpdate(symbolStr, chdata)
			} else if _, ok := rawMsg["bookTicker"]; ok {
				return c.handleOrderBookUpdate(symbolStr, chdata)
			}
		}
	}

	// No specific handler matched
	return nil
}

// handleTickerUpdate processes ticker updates from the WebSocket
func (c *Client) handleTickerUpdate(symbol string, data json.RawMessage) error {
	var tickerData struct {
		Symbol             string `json:"symbol"`
		LastPrice          string `json:"lastPrice"`
		PriceChange        string `json:"priceChange"`
		PriceChangePercent string `json:"priceChangePercent"`
		HighPrice          string `json:"highPrice"`
		LowPrice           string `json:"lowPrice"`
		Volume             string `json:"volume"`
		QuoteVolume        string `json:"quoteVolume"`
		OpenPrice          string `json:"openPrice"`
		PrevClosePrice     string `json:"prevClosePrice"`
		BidPrice           string `json:"bidPrice"`
		BidQuantity        string `json:"bidQty"`
		AskPrice           string `json:"askPrice"`
		AskQuantity        string `json:"askQty"`
		TradeCount         int64  `json:"count"`
		Timestamp          int64  `json:"timestamp"`
	}

	if err := json.Unmarshal(data, &tickerData); err != nil {
		return fmt.Errorf("failed to unmarshal ticker data: %w", err)
	}

	// Convert string values to float64
	lastPrice := convertStringToFloat64(tickerData.LastPrice)
	priceChange := convertStringToFloat64(tickerData.PriceChange)
	priceChangePercent := convertStringToFloat64(tickerData.PriceChangePercent)
	highPrice := convertStringToFloat64(tickerData.HighPrice)
	lowPrice := convertStringToFloat64(tickerData.LowPrice)
	volume := convertStringToFloat64(tickerData.Volume)
	quoteVolume := convertStringToFloat64(tickerData.QuoteVolume)
	openPrice := convertStringToFloat64(tickerData.OpenPrice)
	prevClosePrice := convertStringToFloat64(tickerData.PrevClosePrice)
	bidPrice := convertStringToFloat64(tickerData.BidPrice)
	bidQty := convertStringToFloat64(tickerData.BidQuantity)
	askPrice := convertStringToFloat64(tickerData.AskPrice)
	askQty := convertStringToFloat64(tickerData.AskQuantity)

	// Create ticker object
	ticker := &model.Ticker{
		Symbol:             symbol,
		LastPrice:          lastPrice,
		PriceChange:        priceChange,
		PriceChangePercent: priceChangePercent,
		HighPrice:          highPrice,
		LowPrice:           lowPrice,
		Volume:             volume,
		QuoteVolume:        quoteVolume,
		OpenPrice:          openPrice,
		PrevClosePrice:     prevClosePrice,
		BidPrice:           bidPrice,
		BidQty:             bidQty,
		AskPrice:           askPrice,
		AskQty:             askQty,
		Count:              tickerData.TradeCount,
		Timestamp:          time.Unix(0, tickerData.Timestamp*int64(time.Millisecond)),
	}

	// Update ticker cache
	c.ticker.UpdateTicker(ticker)

	return nil
}

// handleKlineUpdate processes kline updates from the WebSocket
func (c *Client) handleKlineUpdate(symbol string, data json.RawMessage) error {
	var klineData struct {
		Symbol    string `json:"symbol"`
		Interval  string `json:"interval"`
		OpenTime  int64  `json:"startTime"`
		CloseTime int64  `json:"endTime"`
		Open      string `json:"open"`
		High      string `json:"high"`
		Low       string `json:"low"`
		Close     string `json:"close"`
		Volume    string `json:"volume"`
		Amount    string `json:"amount"` // Quote volume
		TradeNum  int64  `json:"tradeNum"`
		IsClosed  bool   `json:"isClosed"`
	}

	if err := json.Unmarshal(data, &klineData); err != nil {
		return fmt.Errorf("failed to unmarshal kline data: %w", err)
	}

	// Convert interval string to model.KlineInterval
	var interval model.KlineInterval
	switch klineData.Interval {
	case "Min1":
		interval = model.KlineInterval1m
	case "Min5":
		interval = model.KlineInterval5m
	case "Min15":
		interval = model.KlineInterval15m
	case "Min30":
		interval = model.KlineInterval30m
	case "Min60", "Hour1":
		interval = model.KlineInterval1h
	case "Hour4":
		interval = model.KlineInterval4h
	case "Day1":
		interval = model.KlineInterval1d
	case "Week1":
		interval = model.KlineInterval1w
	default:
		return fmt.Errorf("unknown kline interval: %s", klineData.Interval)
	}

	// Convert string values to float64
	open := convertStringToFloat64(klineData.Open)
	high := convertStringToFloat64(klineData.High)
	low := convertStringToFloat64(klineData.Low)
	close := convertStringToFloat64(klineData.Close)
	volume := convertStringToFloat64(klineData.Volume)
	quoteVolume := convertStringToFloat64(klineData.Amount)

	// Create kline object
	_ = &model.Kline{
		Symbol:      symbol,
		Interval:    interval,
		OpenTime:    time.Unix(0, klineData.OpenTime*int64(time.Millisecond)),
		CloseTime:   time.Unix(0, klineData.CloseTime*int64(time.Millisecond)),
		Open:        open,
		High:        high,
		Low:         low,
		Close:       close,
		Volume:      volume,
		QuoteVolume: quoteVolume,
		TradeCount:  klineData.TradeNum,
		IsClosed:    klineData.IsClosed,
	}

	// Note: We're not updating any cache for klines in this implementation
	// This could be extended to store klines in a similar cache structure

	return nil
}

// handleOrderBookUpdate processes order book updates from the WebSocket
func (c *Client) handleOrderBookUpdate(symbol string, data json.RawMessage) error {
	var orderBookData struct {
		Symbol       string     `json:"symbol"`
		LastUpdateID int64      `json:"lastUpdateId"`
		Bids         [][]string `json:"bids"` // [price, quantity]
		Asks         [][]string `json:"asks"` // [price, quantity]
	}

	if err := json.Unmarshal(data, &orderBookData); err != nil {
		return fmt.Errorf("failed to unmarshal order book data: %w", err)
	}

	// Create bids
	bids := make([]model.OrderBookEntry, 0, len(orderBookData.Bids))
	for _, bid := range orderBookData.Bids {
		if len(bid) < 2 {
			continue
		}
		price := convertStringToFloat64(bid[0])
		quantity := convertStringToFloat64(bid[1])
		bids = append(bids, model.OrderBookEntry{
			Price:    price,
			Quantity: quantity,
		})
	}

	// Create asks
	asks := make([]model.OrderBookEntry, 0, len(orderBookData.Asks))
	for _, ask := range orderBookData.Asks {
		if len(ask) < 2 {
			continue
		}
		price := convertStringToFloat64(ask[0])
		quantity := convertStringToFloat64(ask[1])
		asks = append(asks, model.OrderBookEntry{
			Price:    price,
			Quantity: quantity,
		})
	}

	// Create order book
	_ = &model.OrderBook{
		Symbol:       symbol,
		LastUpdateID: orderBookData.LastUpdateID,
		Bids:         bids,
		Asks:         asks,
		Timestamp:    time.Now(),
	}

	// Note: We're not updating any cache for order books in this implementation
	// This could be extended to store order books in a similar cache structure

	return nil
}

// Utility function to convert string to float64
func convertStringToFloat64(s string) float64 {
	var f float64
	_, err := fmt.Sscanf(s, "%f", &f)
	if err != nil {
		return 0.0
	}
	return f
}
</file>

<file path="internal/usecase/account_uc.go">
package usecase

import (
	"context"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog"
)

// AccountUsecase defines the interface for account operations
type AccountUsecase interface {
	GetWallet(ctx context.Context, userID string) (*model.Wallet, error)
	GetBalanceHistory(ctx context.Context, userID string, asset model.Asset, days int) ([]*model.BalanceHistory, error)
	RefreshWallet(ctx context.Context, userID string) error
}

// accountUsecase implements the AccountUsecase interface
type accountUsecase struct {
	mexcAPI    port.MexcAPI
	walletRepo port.WalletRepository
	logger     zerolog.Logger
}

// NewAccountUsecase creates a new account usecase
func NewAccountUsecase(
	mexcAPI port.MexcAPI,
	walletRepo port.WalletRepository,
	logger zerolog.Logger,
) AccountUsecase {
	return &accountUsecase{
		mexcAPI:    mexcAPI,
		walletRepo: walletRepo,
		logger:     logger.With().Str("component", "account_usecase").Logger(),
	}
}

// GetWallet gets the user's wallet
func (uc *accountUsecase) GetWallet(ctx context.Context, userID string) (*model.Wallet, error) {
	// First try to get from DB
	wallet, err := uc.walletRepo.GetByUserID(ctx, userID)
	if err != nil {
		uc.logger.Error().Err(err).Str("userID", userID).Msg("Failed to get wallet from DB")

		// If not found or other error, try to get from API
		wallet, err = uc.mexcAPI.GetAccount(ctx)
		if err != nil {
			uc.logger.Error().Err(err).Str("userID", userID).Msg("Failed to get wallet from API")
			return nil, err
		}

		// Set the user ID
		wallet.UserID = userID

		// Save to DB
		if err := uc.walletRepo.Save(ctx, wallet); err != nil {
			uc.logger.Error().Err(err).Str("userID", userID).Msg("Failed to save wallet to DB")
			// Continue anyway since we have the wallet data
		}
	}

	return wallet, nil
}

// GetBalanceHistory gets the user's balance history for a specific asset
func (uc *accountUsecase) GetBalanceHistory(ctx context.Context, userID string, asset model.Asset, days int) ([]*model.BalanceHistory, error) {
	// Calculate time range
	endTime := time.Now()
	startTime := endTime.AddDate(0, 0, -days)

	// Get from repository
	history, err := uc.walletRepo.GetBalanceHistory(ctx, userID, asset, startTime, endTime)
	if err != nil {
		uc.logger.Error().Err(err).Str("userID", userID).Str("asset", string(asset)).Int("days", days).Msg("Failed to get balance history")
		return nil, err
	}

	return history, nil
}

// RefreshWallet refreshes the user's wallet from the exchange
func (uc *accountUsecase) RefreshWallet(ctx context.Context, userID string) error {
	// Get from API
	wallet, err := uc.mexcAPI.GetAccount(ctx)
	if err != nil {
		uc.logger.Error().Err(err).Str("userID", userID).Msg("Failed to refresh wallet from API")
		return err
	}

	// Set the user ID
	wallet.UserID = userID

	// Save to DB
	if err := uc.walletRepo.Save(ctx, wallet); err != nil {
		uc.logger.Error().Err(err).Str("userID", userID).Msg("Failed to save refreshed wallet to DB")
		return err
	}

	return nil
}
</file>

<file path="internal/usecase/ai_uc.go">
package usecase

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/neo/crypto-bot/internal/domain/model"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog"
)

// AIUsecase handles AI-related operations
type AIUsecase struct {
	aiService                port.AIService
	conversationMemoryRepo   port.ConversationMemoryRepository
	embeddingRepo            port.EmbeddingRepository
	logger                   zerolog.Logger
}

// NewAIUsecase creates a new AIUsecase
func NewAIUsecase(
	aiService port.AIService,
	conversationMemoryRepo port.ConversationMemoryRepository,
	embeddingRepo port.EmbeddingRepository,
	logger zerolog.Logger,
) *AIUsecase {
	return &AIUsecase{
		aiService:              aiService,
		conversationMemoryRepo: conversationMemoryRepo,
		embeddingRepo:          embeddingRepo,
		logger:                 logger.With().Str("component", "ai_usecase").Logger(),
	}
}

// Chat sends a message to the AI and returns a response
func (uc *AIUsecase) Chat(ctx context.Context, userID, message, conversationID string) (*model.AIMessage, error) {
	// Create a new conversation if conversationID is empty
	if conversationID == "" {
		conversation := &model.AIConversation{
			ID:        uuid.New().String(),
			UserID:    userID,
			Title:     generateTitle(message),
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		}
		
		if err := uc.conversationMemoryRepo.SaveConversation(ctx, conversation); err != nil {
			uc.logger.Error().Err(err).Msg("Failed to save new conversation")
			return nil, err
		}
		
		conversationID = conversation.ID
	}
	
	// Create user message
	userMessage := &model.AIMessage{
		ID:            uuid.New().String(),
		ConversationID: conversationID,
		Role:          "user",
		Content:       message,
		Timestamp:     time.Now(),
	}
	
	// Save user message
	if err := uc.conversationMemoryRepo.SaveMessage(ctx, userMessage); err != nil {
		uc.logger.Error().Err(err).Msg("Failed to save user message")
		return nil, err
	}
	
	// Get conversation history
	messages, err := uc.conversationMemoryRepo.GetMessages(ctx, conversationID, 10, 0)
	if err != nil {
		uc.logger.Error().Err(err).Msg("Failed to get conversation history")
		return nil, err
	}
	
	// Convert messages to AIMessage slice
	aiMessages := make([]model.AIMessage, len(messages))
	for i, msg := range messages {
		aiMessages[i] = *msg
	}
	
	// Send message to AI with history
	response, err := uc.aiService.ChatWithHistory(ctx, aiMessages)
	if err != nil {
		uc.logger.Error().Err(err).Msg("Failed to get AI response")
		return nil, err
	}
	
	// Save AI response
	if err := uc.conversationMemoryRepo.SaveMessage(ctx, response); err != nil {
		uc.logger.Error().Err(err).Msg("Failed to save AI response")
		// Don't return error here, we still want to return the response to the user
	}
	
	// Update conversation title if it's the first message
	if len(aiMessages) <= 2 {
		conversation, err := uc.conversationMemoryRepo.GetConversation(ctx, conversationID)
		if err == nil {
			conversation.Title = generateTitle(message)
			_ = uc.conversationMemoryRepo.SaveConversation(ctx, conversation)
		}
	}
	
	return response, nil
}

// GetConversation retrieves a conversation by ID
func (uc *AIUsecase) GetConversation(ctx context.Context, userID, conversationID string) (*model.AIConversation, error) {
	conversation, err := uc.conversationMemoryRepo.GetConversation(ctx, conversationID)
	if err != nil {
		return nil, err
	}
	
	// Check if the conversation belongs to the user
	if conversation.UserID != userID {
		return nil, errors.New("unauthorized access to conversation")
	}
	
	return conversation, nil
}

// ListConversations lists conversations for a user
func (uc *AIUsecase) ListConversations(ctx context.Context, userID string, limit, offset int) ([]*model.AIConversation, error) {
	return uc.conversationMemoryRepo.ListConversations(ctx, userID, limit, offset)
}

// DeleteConversation deletes a conversation
func (uc *AIUsecase) DeleteConversation(ctx context.Context, userID, conversationID string) error {
	// Check if the conversation belongs to the user
	conversation, err := uc.conversationMemoryRepo.GetConversation(ctx, conversationID)
	if err != nil {
		return err
	}
	
	if conversation.UserID != userID {
		return errors.New("unauthorized access to conversation")
	}
	
	return uc.conversationMemoryRepo.DeleteConversation(ctx, conversationID)
}

// GenerateInsight generates an insight based on provided data
func (uc *AIUsecase) GenerateInsight(ctx context.Context, userID, insightType string, data map[string]interface{}) (*model.AIInsight, error) {
	// Add user ID to data
	data["user_id"] = userID
	
	// Generate insight
	insight, err := uc.aiService.GenerateInsight(ctx, insightType, data)
	if err != nil {
		uc.logger.Error().Err(err).Str("insightType", insightType).Msg("Failed to generate insight")
		return nil, err
	}
	
	return insight, nil
}

// GenerateTradeRecommendation generates a trade recommendation
func (uc *AIUsecase) GenerateTradeRecommendation(ctx context.Context, userID string, data map[string]interface{}) (*model.AITradeRecommendation, error) {
	// Add user ID to data
	data["user_id"] = userID
	
	// Generate trade recommendation
	recommendation, err := uc.aiService.GenerateTradeRecommendation(ctx, data)
	if err != nil {
		uc.logger.Error().Err(err).Msg("Failed to generate trade recommendation")
		return nil, err
	}
	
	return recommendation, nil
}

// ExecuteFunction executes a function call from the AI
func (uc *AIUsecase) ExecuteFunction(ctx context.Context, functionCall model.AIFunctionCall) (*model.AIFunctionResponse, error) {
	return uc.aiService.ExecuteFunction(ctx, functionCall)
}

// Helper functions

// generateTitle generates a title for a conversation based on the first message
func generateTitle(message string) string {
	// Simple implementation: use the first 30 characters of the message
	title := message
	if len(title) > 30 {
		title = title[:30] + "..."
	}
	return title
}
</file>

<file path="internal/usecase/market_data.go">
package usecase

import (
	"context"
	"time"

	"github.com/neo/crypto-bot/internal/domain/model/market"
	"github.com/neo/crypto-bot/internal/domain/port"
	"github.com/rs/zerolog"
)

// MarketDataUseCase implements use cases for market data
type MarketDataUseCase struct {
	marketRepo port.MarketRepository
	symbolRepo port.SymbolRepository
	cache      port.MarketCache
	logger     *zerolog.Logger
}

// NewMarketDataUseCase creates a new MarketDataUseCase
func NewMarketDataUseCase(
	marketRepo port.MarketRepository,
	symbolRepo port.SymbolRepository,
	cache port.MarketCache,
	logger *zerolog.Logger,
) *MarketDataUseCase {
	return &MarketDataUseCase{
		marketRepo: marketRepo,
		symbolRepo: symbolRepo,
		cache:      cache,
		logger:     logger,
	}
}

// GetLatestTickers returns the latest tickers from cache or database
func (uc *MarketDataUseCase) GetLatestTickers(ctx context.Context) ([]market.Ticker, error) {
	// Try to get from cache first
	if tickers := uc.cache.GetAllTickers(); len(tickers) > 0 {
		uc.logger.Debug().Int("count", len(tickers)).Msg("Retrieved tickers from cache")
		return tickers, nil
	}

	// Fall back to database
	tickers, err := uc.marketRepo.GetAllTickers(ctx)
	if err != nil {
		return nil, err
	}

	// Store in cache for next time
	for _, ticker := range tickers {
		uc.cache.SetTicker(ticker.Exchange, ticker.Symbol, ticker)
	}

	uc.logger.Debug().Int("count", len(tickers)).Msg("Retrieved tickers from database")
	return tickers, nil
}

// GetTicker returns the latest ticker for a specific symbol from cache or database
func (uc *MarketDataUseCase) GetTicker(ctx context.Context, exchange, symbol string) (*market.Ticker, error) {
	// Try to get from cache first
	if ticker := uc.cache.GetTicker(exchange, symbol); ticker != nil {
		uc.logger.Debug().
			Str("exchange", exchange).
			Str("symbol", symbol).
			Msg("Retrieved ticker from cache")
		return ticker, nil
	}

	// Fall back to database
	ticker, err := uc.marketRepo.GetTicker(ctx, exchange, symbol)
	if err != nil {
		return nil, err
	}

	if ticker != nil {
		// Store in cache for next time
		uc.cache.SetTicker(exchange, symbol, *ticker)
	}

	uc.logger.Debug().
		Str("exchange", exchange).
		Str("symbol", symbol).
		Bool("found", ticker != nil).
		Msg("Retrieved ticker from database")
	return ticker, nil
}

// GetCandles returns historical candles for a specific symbol
func (uc *MarketDataUseCase) GetCandles(
	ctx context.Context,
	exchange string,
	symbol string,
	interval market.Interval,
	startTime time.Time,
	endTime time.Time,
	limit int,
) ([]market.Candle, error) {
	// Try to get from cache if the time range is recent
	// Only use cache for last 24h data and if limit is reasonable
	now := time.Now()
	isRecent := startTime.After(now.Add(-24 * time.Hour))
	useCache := isRecent && limit <= 200

	if useCache {
		cacheKey := exchange + ":" + symbol + ":" + string(interval)
		if candles := uc.cache.GetCandles(cacheKey); len(candles) > 0 {
			// Filter candles by time range
			var filteredCandles []market.Candle
			for _, c := range candles {
				if (c.OpenTime.Equal(startTime) || c.OpenTime.After(startTime)) &&
					(c.OpenTime.Equal(endTime) || c.OpenTime.Before(endTime)) {
					filteredCandles = append(filteredCandles, c)
				}
			}

			if len(filteredCandles) > 0 {
				// Ensure we don't return more than the limit
				if limit > 0 && len(filteredCandles) > limit {
					filteredCandles = filteredCandles[len(filteredCandles)-limit:]
				}
				uc.logger.Debug().
					Str("exchange", exchange).
					Str("symbol", symbol).
					Str("interval", string(interval)).
					Int("count", len(filteredCandles)).
					Msg("Retrieved candles from cache")
				return filteredCandles, nil
			}
		}
	}

	// Fall back to database
	candles, err := uc.marketRepo.GetCandles(ctx, exchange, symbol, interval, startTime, endTime, limit)
	if err != nil {
		return nil, err
	}

	// Store in cache for next time if it's recent data
	if isRecent && len(candles) > 0 {
		cacheKey := exchange + ":" + symbol + ":" + string(interval)
		uc.cache.SetCandles(cacheKey, candles)
	}

	uc.logger.Debug().
		Str("exchange", exchange).
		Str("symbol", symbol).
		Str("interval", string(interval)).
		Int("count", len(candles)).
		Msg("Retrieved candles from database")
	return candles, nil
}

// GetAllSymbols returns all available trading symbols
func (uc *MarketDataUseCase) GetAllSymbols(ctx context.Context) ([]market.Symbol, error) {
	// Try to get from cache first
	const cacheKey = "all_symbols"
	if cached, ok := uc.cache.Get(cacheKey); ok {
		if symbols, ok := cached.([]market.Symbol); ok {
			uc.logger.Debug().Int("count", len(symbols)).Msg("Retrieved symbols from cache")
			return symbols, nil
		}
	}

	// Fall back to database
	symbols, err := uc.symbolRepo.GetAll(ctx)
	if err != nil {
		return nil, err
	}

	// Store in cache for next time
	uc.cache.Set(cacheKey, symbols, 1*time.Hour) // Symbols don't change often

	uc.logger.Debug().Int("count", len(symbols)).Msg("Retrieved symbols from database")
	return symbols, nil
}

// GetSymbolInfo returns detailed information for a specific trading symbol
func (uc *MarketDataUseCase) GetSymbolInfo(ctx context.Context, symbol string) (*market.Symbol, error) {
	// Try to get from cache first
	cacheKey := "symbol_" + symbol
	if cached, ok := uc.cache.Get(cacheKey); ok {
		if symbolInfo, ok := cached.(*market.Symbol); ok && symbolInfo != nil {
			uc.logger.Debug().Str("symbol", symbol).Msg("Retrieved symbol info from cache")
			return symbolInfo, nil
		}
	}

	// Fall back to database
	symbolInfo, err := uc.symbolRepo.GetBySymbol(ctx, symbol)
	if err != nil {
		return nil, err
	}

	// Store in cache for next time
	if symbolInfo != nil {
		uc.cache.Set(cacheKey, symbolInfo, 1*time.Hour) // Symbols don't change often
	}

	uc.logger.Debug().
		Str("symbol", symbol).
		Bool("found", symbolInfo != nil).
		Msg("Retrieved symbol info from database")
	return symbolInfo, nil
}
</file>

<file path="migrations/000001_create_initial_schema.down.sql">
DROP TABLE IF EXISTS positions;
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS balance_histories;
DROP TABLE IF EXISTS balances;
DROP TABLE IF EXISTS wallets;
DROP TABLE IF EXISTS orderbook_entries;
DROP TABLE IF EXISTS orderbooks;
DROP TABLE IF EXISTS candles;
DROP TABLE IF EXISTS tickers;
DROP TABLE IF EXISTS symbols;
</file>

<file path="migrations/000001_create_initial_schema.up.sql">
CREATE TABLE IF NOT EXISTS wallets (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Add indices
    INDEX idx_wallets_user_id (user_id),
    INDEX idx_wallets_exchange (exchange),
    
    -- Ensure unique wallet per user per exchange
    UNIQUE KEY uk_wallet_user_exchange (user_id, exchange)
);

CREATE TABLE IF NOT EXISTS balances (
    id SERIAL PRIMARY KEY,
    wallet_id BIGINT NOT NULL,
    asset VARCHAR(20) NOT NULL,
    free DECIMAL(24, 8) NOT NULL DEFAULT 0,
    locked DECIMAL(24, 8) NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Add foreign key constraint
    CONSTRAINT fk_balances_wallet
        FOREIGN KEY (wallet_id)
        REFERENCES wallets (id)
        ON DELETE CASCADE,
        
    -- Add indices
    INDEX idx_balances_wallet_id (wallet_id),
    INDEX idx_balances_asset (asset),
    
    -- Ensure unique asset per wallet
    UNIQUE KEY uk_balance_wallet_asset (wallet_id, asset)
);

CREATE TABLE IF NOT EXISTS balance_histories (
    id SERIAL PRIMARY KEY,
    wallet_id BIGINT NOT NULL,
    asset VARCHAR(20) NOT NULL,
    balance_type VARCHAR(10) NOT NULL,
    amount DECIMAL(24, 8) NOT NULL,
    reason VARCHAR(100),
    txid VARCHAR(100),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Add foreign key constraint
    CONSTRAINT fk_balance_histories_wallet
        FOREIGN KEY (wallet_id)
        REFERENCES wallets (id)
        ON DELETE CASCADE,
        
    -- Add indices
    INDEX idx_balance_histories_wallet_id (wallet_id),
    INDEX idx_balance_histories_asset (asset),
    INDEX idx_balance_histories_created_at (created_at)
);

CREATE TABLE IF NOT EXISTS orders (
    id SERIAL PRIMARY KEY,
    order_id VARCHAR(100),
    client_order_id VARCHAR(100) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(10) NOT NULL,
    type VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL,
    time_in_force VARCHAR(10),
    price DECIMAL(24, 8),
    quantity DECIMAL(24, 8) NOT NULL,
    executed_qty DECIMAL(24, 8) NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Add indices
    INDEX idx_orders_order_id (order_id),
    INDEX idx_orders_client_order_id (client_order_id),
    INDEX idx_orders_symbol (symbol),
    INDEX idx_orders_status (status),
    INDEX idx_orders_created_at (created_at)
);

CREATE TABLE IF NOT EXISTS positions (
    id SERIAL PRIMARY KEY,
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(10) NOT NULL,
    type VARCHAR(20) NOT NULL,
    entry_price DECIMAL(24, 8) NOT NULL,
    quantity DECIMAL(24, 8) NOT NULL,
    closed_qty DECIMAL(24, 8) NOT NULL DEFAULT 0,
    realized_pnl DECIMAL(24, 8) NOT NULL DEFAULT 0,
    unrealized_pnl DECIMAL(24, 8) NOT NULL DEFAULT 0,
    status VARCHAR(20) NOT NULL,
    entry_order_id VARCHAR(100),
    exit_order_id VARCHAR(100),
    open_time TIMESTAMP,
    close_time TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Add indices
    INDEX idx_positions_symbol (symbol),
    INDEX idx_positions_status (status),
    INDEX idx_positions_entry_order_id (entry_order_id),
    INDEX idx_positions_exit_order_id (exit_order_id),
    INDEX idx_positions_open_time (open_time),
    INDEX idx_positions_close_time (close_time)
);

-- Add market data tables

-- Table for trading symbols
CREATE TABLE IF NOT EXISTS symbols (
    symbol VARCHAR(50) PRIMARY KEY,
    base_asset VARCHAR(20) NOT NULL,
    quote_asset VARCHAR(20) NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL,
    min_price DECIMAL(24,8) NOT NULL,
    max_price DECIMAL(24,8) NOT NULL,
    price_precision INT NOT NULL,
    min_qty DECIMAL(24,8) NOT NULL,
    max_qty DECIMAL(24,8) NOT NULL,
    qty_precision INT NOT NULL,
    allowed_order_types TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_symbol_exchange ON symbols(exchange);

-- Table for ticker data
CREATE TABLE IF NOT EXISTS tickers (
    id VARCHAR(100) PRIMARY KEY,
    symbol VARCHAR(50) NOT NULL,
    price DECIMAL(24,8) NOT NULL,
    volume DECIMAL(24,8) NOT NULL,
    high24h DECIMAL(24,8) NOT NULL,
    low24h DECIMAL(24,8) NOT NULL,
    price_change DECIMAL(24,8) NOT NULL,
    percent_change DECIMAL(24,8) NOT NULL,
    last_updated TIMESTAMP WITH TIME ZONE NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_ticker_symbol ON tickers(symbol);
CREATE INDEX IF NOT EXISTS idx_ticker_exchange ON tickers(exchange);
CREATE INDEX IF NOT EXISTS idx_ticker_updated ON tickers(last_updated);

-- Table for candlestick data
CREATE TABLE IF NOT EXISTS candles (
    id SERIAL PRIMARY KEY,
    symbol VARCHAR(50) NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    interval VARCHAR(10) NOT NULL,
    open_time TIMESTAMP WITH TIME ZONE NOT NULL,
    close_time TIMESTAMP WITH TIME ZONE NOT NULL,
    open DECIMAL(24,8) NOT NULL,
    high DECIMAL(24,8) NOT NULL,
    low DECIMAL(24,8) NOT NULL,
    close DECIMAL(24,8) NOT NULL,
    volume DECIMAL(24,8) NOT NULL,
    quote_volume DECIMAL(24,8) NOT NULL,
    trade_count BIGINT NOT NULL,
    complete BOOLEAN NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_candle_symbol ON candles(symbol);
CREATE INDEX IF NOT EXISTS idx_candle_exchange ON candles(exchange);
CREATE INDEX IF NOT EXISTS idx_candle_interval ON candles(interval);
CREATE INDEX IF NOT EXISTS idx_candle_opentime ON candles(open_time);

-- Table for orderbook data
CREATE TABLE IF NOT EXISTS orderbooks (
    id SERIAL PRIMARY KEY,
    symbol VARCHAR(50) NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    last_updated TIMESTAMP WITH TIME ZONE NOT NULL,
    sequence_num BIGINT NOT NULL,
    last_update_id BIGINT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_orderbook_symbol ON orderbooks(symbol);
CREATE INDEX IF NOT EXISTS idx_orderbook_exchange ON orderbooks(exchange);
CREATE INDEX IF NOT EXISTS idx_orderbook_updated ON orderbooks(last_updated);

-- Table for orderbook entries (bids and asks)
CREATE TABLE IF NOT EXISTS orderbook_entries (
    id SERIAL PRIMARY KEY,
    orderbook_id INT NOT NULL,
    type VARCHAR(10) NOT NULL, -- 'bid' or 'ask'
    price DECIMAL(24,8) NOT NULL,
    quantity DECIMAL(24,8) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (orderbook_id) REFERENCES orderbooks(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_orderbook_entry ON orderbook_entries(orderbook_id);
CREATE INDEX IF NOT EXISTS idx_entry_type ON orderbook_entries(type);
</file>

<file path="pkg/ratelimiter/ratelimiter.go">
package ratelimiter

import (
	"sync"
	"time"
)

// TokenBucket represents a token bucket rate limiter
type TokenBucket struct {
	rate       float64    // tokens per second
	capacity   float64    // bucket capacity
	tokens     float64    // current number of tokens
	lastUpdate time.Time  // last time tokens were added
	mu         sync.Mutex // mutex for concurrent access
}

// NewTokenBucket creates a new token bucket rate limiter
func NewTokenBucket(rate float64, capacity float64) *TokenBucket {
	return &TokenBucket{
		rate:       rate,
		capacity:   capacity,
		tokens:     capacity,
		lastUpdate: time.Now(),
	}
}

// Allow returns true if a request is allowed, and consumes a token
func (t *TokenBucket) Allow() bool {
	return t.AllowN(1)
}

// AllowN returns true if n requests are allowed, and consumes n tokens
func (t *TokenBucket) AllowN(n float64) bool {
	t.mu.Lock()
	defer t.mu.Unlock()

	now := time.Now()
	elapsed := now.Sub(t.lastUpdate).Seconds()
	t.lastUpdate = now

	// Add tokens based on elapsed time
	t.tokens += elapsed * t.rate
	if t.tokens > t.capacity {
		t.tokens = t.capacity
	}

	// Check if we have enough tokens
	if t.tokens < n {
		return false
	}

	// Consume tokens
	t.tokens -= n
	return true
}

// WaitN waits until n tokens are available and then consumes them
func (t *TokenBucket) WaitN(n float64) {
	for {
		t.mu.Lock()
		now := time.Now()
		elapsed := now.Sub(t.lastUpdate).Seconds()
		t.lastUpdate = now

		// Add tokens based on elapsed time
		t.tokens += elapsed * t.rate
		if t.tokens > t.capacity {
			t.tokens = t.capacity
		}

		// If we have enough tokens, consume them and return
		if t.tokens >= n {
			t.tokens -= n
			t.mu.Unlock()
			return
		}

		// Calculate how long to wait for the required tokens
		waitTime := time.Duration((n - t.tokens) / t.rate * float64(time.Second))
		t.mu.Unlock()

		// Wait for tokens to replenish
		time.Sleep(waitTime)
	}
}

// Wait waits until a token is available and then consumes it
func (t *TokenBucket) Wait() {
	t.WaitN(1)
}

// GetTokens returns the current number of tokens in the bucket
func (t *TokenBucket) GetTokens() float64 {
	t.mu.Lock()
	defer t.mu.Unlock()

	now := time.Now()
	elapsed := now.Sub(t.lastUpdate).Seconds()

	// Add tokens based on elapsed time
	tokens := t.tokens + elapsed*t.rate
	if tokens > t.capacity {
		tokens = t.capacity
	}

	return tokens
}

// RateLimiterMap manages multiple rate limiters by key
type RateLimiterMap struct {
	limiters map[string]*TokenBucket
	rate     float64
	capacity float64
	mu       sync.Mutex
}

// NewRateLimiterMap creates a new rate limiter map
func NewRateLimiterMap(rate float64, capacity float64) *RateLimiterMap {
	return &RateLimiterMap{
		limiters: make(map[string]*TokenBucket),
		rate:     rate,
		capacity: capacity,
	}
}

// Get returns a rate limiter for the given key
func (r *RateLimiterMap) Get(key string) *TokenBucket {
	r.mu.Lock()
	defer r.mu.Unlock()

	limiter, exists := r.limiters[key]
	if !exists {
		limiter = NewTokenBucket(r.rate, r.capacity)
		r.limiters[key] = limiter
	}

	return limiter
}

// Allow returns true if a request is allowed for the given key
func (r *RateLimiterMap) Allow(key string) bool {
	return r.Get(key).Allow()
}

// Wait waits until a token is available for the given key
func (r *RateLimiterMap) Wait(key string) {
	r.Get(key).Wait()
}
</file>

<file path="pkg/retry/retry_test.go">
package retry

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestRetryableError(t *testing.T) {
	// Test creating and checking retryable errors
	baseErr := errors.New("base error")
	retryableErr := NewRetryableError(baseErr)

	// Test Error method
	assert.Contains(t, retryableErr.Error(), baseErr.Error())

	// Test Unwrap method
	assert.Equal(t, baseErr, retryableErr.Unwrap())

	// Test IsRetryable function
	assert.True(t, IsRetryable(retryableErr))
	assert.False(t, IsRetryable(baseErr))
}

func TestConstantBackoff(t *testing.T) {
	backoff := &ConstantBackoff{
		Interval: 100 * time.Millisecond,
	}

	// Test that backoff returns the same interval regardless of attempt
	assert.Equal(t, 100*time.Millisecond, backoff.NextBackoff(0))
	assert.Equal(t, 100*time.Millisecond, backoff.NextBackoff(1))
	assert.Equal(t, 100*time.Millisecond, backoff.NextBackoff(5))
}

func TestExponentialBackoff(t *testing.T) {
	backoff := &ExponentialBackoff{
		InitialInterval: 100 * time.Millisecond,
		MaxInterval:     10 * time.Second,
		Multiplier:      2.0,
		RandomFactor:    0.0, // No randomness for testing
	}

	// Test backoff intervals with multiplier=2
	assert.Equal(t, 100*time.Millisecond, backoff.NextBackoff(0))
	assert.Equal(t, 200*time.Millisecond, backoff.NextBackoff(1))
	assert.Equal(t, 400*time.Millisecond, backoff.NextBackoff(2))
	assert.Equal(t, 800*time.Millisecond, backoff.NextBackoff(3))

	// Test max interval cap
	assert.Equal(t, 10*time.Second, backoff.NextBackoff(10)) // Should exceed max and be capped
}

func TestRetryDoWithSuccess(t *testing.T) {
	// Test retry operation that succeeds
	attempts := 0
	err := Do(context.Background(), func() error {
		attempts++
		return nil // Success
	}, nil) // Use default options

	assert.NoError(t, err)
	assert.Equal(t, 1, attempts) // Should only attempt once
}

func TestRetryDoWithPermanentError(t *testing.T) {
	// Test retry operation with a non-retryable error
	attempts := 0
	permanentErr := errors.New("permanent error")
	err := Do(context.Background(), func() error {
		attempts++
		return permanentErr // Non-retryable
	}, nil) // Use default options

	assert.Error(t, err)
	assert.Equal(t, 1, attempts) // Should only attempt once
}

func TestRetryDoWithRetryableError(t *testing.T) {
	// Test retry operation with a retryable error
	attempts := 0
	retryableErr := NewRetryableError(errors.New("retryable error"))
	err := Do(context.Background(), func() error {
		attempts++
		if attempts < 3 {
			return retryableErr // Retryable error for first 2 attempts
		}
		return nil // Success on 3rd attempt
	}, &RetryOptions{
		MaxAttempts: 3,
		BackoffStrategy: &ConstantBackoff{
			Interval: 1 * time.Millisecond, // Fast for testing
		},
		RetryIf: IsRetryable,
	})

	assert.NoError(t, err)
	assert.Equal(t, 3, attempts) // Should attempt 3 times total
}

func TestRetryDoWithMaxAttemptsExceeded(t *testing.T) {
	// Test retry operation that reaches max attempts without success
	attempts := 0
	retryableErr := NewRetryableError(errors.New("retryable error"))
	err := Do(context.Background(), func() error {
		attempts++
		return retryableErr // Always return retryable error
	}, &RetryOptions{
		MaxAttempts: 3,
		BackoffStrategy: &ConstantBackoff{
			Interval: 1 * time.Millisecond, // Fast for testing
		},
		RetryIf: IsRetryable,
	})

	assert.Error(t, err)
	assert.Equal(t, 3, attempts) // Should attempt 3 times total
	assert.Contains(t, err.Error(), "all 3 attempts failed")
}

func TestRetryDoWithContextCancellation(t *testing.T) {
	// Test retry operation with context cancellation
	attempts := 0
	ctx, cancel := context.WithCancel(context.Background())
	retryableErr := NewRetryableError(errors.New("retryable error"))

	go func() {
		time.Sleep(50 * time.Millisecond)
		cancel() // Cancel after a short delay
	}()

	err := Do(ctx, func() error {
		attempts++
		time.Sleep(10 * time.Millisecond) // Ensure at least one attempt
		return retryableErr               // Always return retryable error
	}, &RetryOptions{
		MaxAttempts: 10, // More than we'll actually do due to cancellation
		BackoffStrategy: &ConstantBackoff{
			Interval: 100 * time.Millisecond, // Long enough to ensure context cancellation
		},
		RetryIf: IsRetryable,
	})

	assert.Error(t, err)
	assert.ErrorIs(t, err, context.Canceled)
	assert.True(t, attempts > 0, "Should have attempted at least once")
}

func TestCustomRetryIfFunction(t *testing.T) {
	// Test custom retryIf function
	customErr := errors.New("custom error")
	customRetryIf := func(err error) bool {
		return errors.Is(err, customErr)
	}

	attempts := 0
	err := Do(context.Background(), func() error {
		attempts++
		if attempts < 3 {
			return customErr // Custom retryable error
		}
		return nil // Success
	}, &RetryOptions{
		MaxAttempts: 3,
		BackoffStrategy: &ConstantBackoff{
			Interval: 1 * time.Millisecond,
		},
		RetryIf: customRetryIf,
	})

	assert.NoError(t, err)
	assert.Equal(t, 3, attempts)
}
</file>

<file path="pkg/retry/retry.go">
package retry

import (
	"context"
	"errors"
	"fmt"
	"math"
	"math/rand"
	"time"
)

// RetryableError is an error that indicates the operation should be retried
type RetryableError struct {
	Err error
}

func (e *RetryableError) Error() string {
	return fmt.Sprintf("retryable error: %v", e.Err)
}

func (e *RetryableError) Unwrap() error {
	return e.Err
}

// IsRetryable checks if an error is retryable
func IsRetryable(err error) bool {
	var retryableErr *RetryableError
	return errors.As(err, &retryableErr)
}

// NewRetryableError creates a new retryable error
func NewRetryableError(err error) *RetryableError {
	return &RetryableError{Err: err}
}

// BackoffStrategy defines a strategy for calculating backoff time between retries
type BackoffStrategy interface {
	NextBackoff(attempt int) time.Duration
}

// ConstantBackoff implements a constant backoff strategy
type ConstantBackoff struct {
	Interval time.Duration
}

func (b *ConstantBackoff) NextBackoff(_ int) time.Duration {
	return b.Interval
}

// ExponentialBackoff implements an exponential backoff strategy
type ExponentialBackoff struct {
	InitialInterval time.Duration
	MaxInterval     time.Duration
	Multiplier      float64
	RandomFactor    float64
}

func (b *ExponentialBackoff) NextBackoff(attempt int) time.Duration {
	// Calculate backoff time
	backoff := float64(b.InitialInterval) * math.Pow(b.Multiplier, float64(attempt))

	// Add jitter
	if b.RandomFactor > 0 {
		backoff = backoff * (1 + b.RandomFactor*(rand.Float64()*2-1))
	}

	// Ensure backoff doesn't exceed max interval
	if backoff > float64(b.MaxInterval) {
		backoff = float64(b.MaxInterval)
	}

	return time.Duration(backoff)
}

// RetryOptions defines options for retry operations
type RetryOptions struct {
	MaxAttempts     int
	BackoffStrategy BackoffStrategy
	RetryIf         func(error) bool
}

// DefaultRetryOptions returns default retry options
func DefaultRetryOptions() *RetryOptions {
	return &RetryOptions{
		MaxAttempts: 3,
		BackoffStrategy: &ExponentialBackoff{
			InitialInterval: 100 * time.Millisecond,
			MaxInterval:     10 * time.Second,
			Multiplier:      2.0,
			RandomFactor:    0.2,
		},
		RetryIf: IsRetryable,
	}
}

// Do executes the provided function with retries based on the provided options
func Do(ctx context.Context, fn func() error, opts *RetryOptions) error {
	if opts == nil {
		opts = DefaultRetryOptions()
	}

	var lastErr error

	for attempt := 0; attempt < opts.MaxAttempts; attempt++ {
		err := fn()
		if err == nil {
			return nil
		}

		lastErr = err

		// Check if error is retryable
		if opts.RetryIf != nil && !opts.RetryIf(err) {
			return err
		}

		// Check if we've reached max attempts
		if attempt >= opts.MaxAttempts-1 {
			break
		}

		// Calculate backoff time
		backoff := opts.BackoffStrategy.NextBackoff(attempt)

		// Create a timer for backoff
		timer := time.NewTimer(backoff)
		defer timer.Stop()

		// Wait for backoff timer or context cancellation
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-timer.C:
			// Continue with the next attempt
		}
	}

	return fmt.Errorf("all %d attempts failed, last error: %w", opts.MaxAttempts, lastErr)
}
</file>

<file path="go.mod">
module github.com/neo/crypto-bot

go 1.24.2

require (
	github.com/gin-gonic/gin v1.10.0
	github.com/gorilla/websocket v1.5.3
	github.com/joho/godotenv v1.5.1
	github.com/rs/zerolog v1.34.0
	github.com/spf13/viper v1.20.1
	github.com/stretchr/testify v1.10.0
	gorm.io/driver/sqlite v1.5.7
	gorm.io/gorm v1.25.12
)

require (
	github.com/bytedance/sonic v1.13.2 // indirect
	github.com/bytedance/sonic/loader v0.2.4 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/fsnotify/fsnotify v1.9.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.26.0 // indirect
	github.com/go-viper/mapstructure/v2 v2.2.1 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-colorable v0.1.14 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-sqlite3 v1.14.22 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/sagikazarmark/locafero v0.9.0 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.14.0 // indirect
	github.com/spf13/cast v1.7.1 // indirect
	github.com/spf13/pflag v1.0.6 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	golang.org/x/arch v0.16.0 // indirect
	golang.org/x/crypto v0.37.0 // indirect
	golang.org/x/net v0.39.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
</file>

</files>
