# Go Crypto Bot - Product Requirements Document (PRD)

---

# üåê Overview
Go Crypto Bot is an advanced, hexagonally-architected trading bot that automates cryptocurrency trading strategies on the MEXC exchange. It is built for traders who want to execute trades automatically based on predefined strategies with a strong emphasis on performance, reliability, and safety. Developers and financial analysts can use it as a framework to implement, test, and evaluate trading models.

The product solves the need for consistent, emotionless trading by applying rule-based logic and machine-driven decision-making. It removes the need for constant manual oversight while giving users full transparency, configurability, and risk control.

---

# üìä Core Features

## Exchange Integration
- **What it does**: Interfaces with MEXC REST and WebSocket APIs
- **Why it's important**: Enables live trading and data collection
- **How it works**: Token-bucket rate limiter, reconnect logic, caching, authenticated requests

## Trading Strategy Framework
- **What it does**: Manages how trading decisions are made
- **Why it's important**: Supports multiple dynamic strategies for different market conditions
- **How it works**: Pluggable strategy interface, regime detection, signal generation

## Risk Management
- **What it does**: Prevents overexposure and manages losses
- **Why it's important**: Preserves capital and enables sustainable trading
- **How it works**: Position sizing, stop-loss/trailing stop, daily loss caps, drawdown monitoring

## Portfolio Management
- **What it does**: Tracks holdings and valuations in real time
- **Why it's important**: Traders need visibility into their current positions and performance
- **How it works**: Calculates real-time P&L, portfolio value, and exposure metrics

## Backtesting Framework
- **What it does**: Allows strategies to be tested against historical data
- **Why it's important**: Helps validate strategy performance before risking real capital
- **How it works**: Loads historical data (CSV/DB), simulates trades, computes Sharpe ratio, drawdown, etc.

## Notification System
- **What it does**: Sends real-time alerts
- **Why it's important**: Keeps traders informed of critical events
- **How it works**: Async worker pool, integration with Telegram/Slack, templated messages

## User Interfaces
- **What it does**: Enables users to interact with the bot via CLI, API, and Dashboard
- **Why it's important**: Provides flexible control options for different user roles
- **How it works**: RESTful API (Gin), WebSocket streams, CLI with Cobra, React dashboard (mobile-optimized)

---

# üìà User Experience

## User Personas
- **Traders**: Want automation, risk control, and performance visibility
- **Developers**: Extend the bot with new strategies or APIs
- **Analysts**: Review historical and live trade data

## Key User Flows
1. **Configuration**
   - Set MEXC API keys
   - Choose strategy and risk parameters
   - Enable notifications

2. **Live Trading**
   - Bot starts scanning market
   - Generates signals and places trades
   - Monitors position P&L, risk, drawdown

3. **Monitoring**
   - Dashboard displays live positions, risk, and alerts
   - Users receive real-time updates via Slack/Telegram

4. **Backtesting**
   - Select strategy and dataset
   - Simulate trades
   - View report with charts and metrics

## UI/UX Considerations
- Intuitive CLI and REST API for tech-savvy users
- Modern, mobile-friendly dashboard
- Clear status indicators and actionable alerts
- Secure credential storage and session management

---

# ‚öñÔ∏è Technical Architecture

## System Components
- **Domain Layer**: Entities, value objects, interfaces (ports)
- **Application Layer**: Use case orchestration, transactions, services
- **API Layer**: REST, WebSocket, OpenAPI
- **CLI Layer**: Command-driven control and monitoring
- **Infrastructure Layer**: MEXC integration, TursoDB (SQLite-compatible), caching, auth, notifications
- **Cross-Cutting**: Logging (zap), config, metrics, error tracking

## Data Models
- `Account`, `Order`, `Position`, `ClosedPosition`, `BalanceHistory`, `Ticker`, `Strategy`, `RiskParameters`

## APIs and Integrations
- MEXC REST/WebSocket
- Telegram Bot API, Slack API
- Clerk authentication (OAuth2, RBAC)

## Infrastructure Requirements
- Go 1.21+
- **TursoDB** (SQLite-compatible, edge-first database)
- Docker for local/cloud deployment
- GitHub Actions for CI/CD
- Zap for structured logging

---

# üìÜ Development Roadmap

## Phase 1: Foundation (MVP)
- Set up hexagonal architecture
- Build MEXC client (REST + WebSocket)
- Implement account, trade, and position services
- CLI interface for trading and monitoring
- NewCoinStrategy as baseline
- TursoDB + schema migrations
- Unit test coverage + CI/CD pipeline

## Phase 2: Advanced Trading
- Strategy framework and factory pattern
- Add BreakoutStrategy and VolumeSpikeStrategy
- Full risk management suite (sizing, exposure, limits)
- Notification system (Telegram, Slack)
- Backtest framework with metrics and CLI commands

## Phase 3: UX & Extensions
- Clerk-based auth and RBAC
- REST + WebSocket API endpoints with Huma
- React dashboard with real-time data
- Mobile optimization
- Strategy visualization tools
- ML module (coin behavior, pattern detection)
- Multi-exchange support with adapter pattern

---

# ‚öõ Logical Dependency Chain
1. Domain model + repository interfaces
2. MEXC API client + caching
3. Application services: Trade, Account, Position
4. Strategy interface + base implementation (NewCoin)
5. CLI interface for controlling bot
6. Risk management integration
7. REST API with real-time updates
8. Backtesting tools and analytics
9. Notification engine
10. Dashboard frontend and ML enhancements

---

# ‚ö† Risks and Mitigations

## Technical Challenges
- **MEXC instability**: Add retry logic, exponential backoff, circuit breaker
- **Concurrency bugs**: Test with Go race detector, sync primitives
- **API testing**: Use mocks/stubs for exchange simulation

## MVP Definition
- Focus only on MEXC, single strategy, CLI/REST interfaces
- Delay ML, dashboard, multi-exchange until Phase 3

## Resource Constraints
- Modular code design for parallel feature development
- Strong test suite to reduce future bugs and regressions

---

# üîπ Appendix

## Research Findings
- NewCoin launches often drive high early volatility
- Volume spikes are reliable breakout indicators
- Drawdown limits are crucial for strategy robustness

## Technical Specifications
- Auth: Clerk + JWT + OAuth
- DB: **TursoDB** with soft delete and indexing
- CLI: Cobra
- API: Gin + Huma
- Logging: zap

## Example Endpoints
- `GET /api/v1/account`
- `POST /api/v1/positions`
- `POST /api/v1/strategies/backtest`

## CLI Commands
- `account`, `positions`, `trade`, `backtest`, `config`, `bot`

---

# üìÖ Summary
Go Crypto Bot is a scalable, testable, and modular bot framework for crypto trading automation. Its hexagonal architecture enables rapid development of reliable features while ensuring clear separation of concerns, safe trading execution, and long-term extensibility.

